

---
id: meshcloud.policies
title: Policies
---

## Introduction: What are Policies?

A policy describes a restriction between two objects. You can only define a
policy on certain objects by using their defined tags. These particular objects
are called policy subjects.

> **Workspace**, **Project**, **User/Group** and **LandingZone** are policy
> subjects

For ease of use, we restrict the combinations of policy subjects which do not
make sense. Each policy describes which [tag](meshcloud.metadata-tags.md) values
have to be present on both policy subjects to comply with the policy. By setting
an [evaluation strategy](meshcloud.policies.md#policy-evaluation-strategy) you
can decide how the policy subjects are evaluated against each other.

Policies are enforced in various places wherever you edit a tag of a policy
subject or change a relation to another policy subject like assigning a user to
a workspace. Operators can learn more about configuring policies
[here](administration.policies.md).

### Authoritative and Affected Subject

The terms authoritative and affected subject shall make clear in which direction
the policy will be evaluated.

We have a limited selection of authoritative and affected subject combinations.
Valid combinations are

| Authoritative Subject | Affected Subject       |
| --------------------- | ---------------------- |
| Workspace             | Project                |
|                       | User/Group (Principal) |
|                       | LandingZone            |
|                       | Building Block         |
| Project               | User/Group (Principal) |
|                       | LandingZone            |

You can find the authoritative subject on the left side and the affected subject
on the right side. In general, the authoritative subject restricts the affected
subject depending on a selected evaluation strategy and the chosen tags.

### Policy Evaluation Strategy

A policy evaluation strategy describes how authoritative and affected policy
subjects shall be evaluated in the context of a policy. In that way, you can
decide in which form the tag values have to be present on both policy subjects
to comply with the policy. As mentioned before, policies are built on top of
meshStack's [tagging](./meshcloud.metadata-tags.md) system. By that system, you
can allow your tag to only have one value or multiple values. For the
evaluation, all tags are treated as arrays: no matter if there are no values, a
single value, or multiple values. This means you can also create a policy that
evaluates a single-select tag against a multi-select tag.

> **Null sets rule**: If _neither_ subject has the tag defined in your policy,
> your policy subjects are evaluated as compliant with that policy. This allows
> introducing additional tags and policies over existing objects without making
> them incompliant.

There are two different selectable evaluation options `Subset` and
`Intersection`.

#### Subset

Describes an evaluation strategy that the tag values of the affected subject
**must be a non-empty subset** of the authoritative subject tag values. The
evaluation of a `Subset` is successful if the affected subject is only tagged
with values which are also present in the tag values of the authoritative
subject.

> The Subset evaluation strategy is useful for modeling "clearances" with tags.
> A common use case is clearing workspaces to allow access to certain
> environments/stages and landing zone types using a multi-select tag at the
> workspace level. Policies with a subset evaluation strategy ensure all
> projects, landing zones, building blocks, etc. stay within the bounds of that
> clearance.

**Example:** In this example, we're looking at a policy between a project's
`environment` tag, and a workspace's `environment` tag with the following
allowed values: `dev`, `qa`, and `prod`. The project is the affected subject and
the workspace is the authoritative subject.

| Workspace<br> _authoritative_ | Project<br> _affected_ | Result | Explanation                                                                 |
| ----------------------------- | ---------------------- | ------ | --------------------------------------------------------------------------- |
| `prod`                        | `prod`                 | ✓      | `prod` is present on both Project and Workspace                             |
| `dev`, `qa`                   | `prod`                 | ✖      | Project `prod` is not present on Workspace `qa`,`dev`                       |
| `dev`                         | < empty >              | ✖      | Project has no tag values, the subset is empty                              |
| < empty >                     | `dev`                  | ✖      | Workspace has no tag values, Project `dev` is not a subset                  |
| < empty >                     | < empty >              | ✓      | Null sets rule: Both subjects have no tag values, the policy passes         |
| `qa`, `dev`                   | `prod`, `qa`           | ✖      | Project `prod` is not present in Workspace `qa`,`dev`                       |
| `qa`, `dev`                   | `dev`, `qa`            | ✓      | `dev`, `qa` is present on both Project and Workspace, order does not matter |

#### Intersection

Describes an evaluation strategy that the tag values of the affected subject
**must have a non-empty intersection** with the tag values of the authoritative
subject tag values. The evaluation of an `Intersection` is successful if at
least one tag value is present on both policy subjects or if both sets are
empty.

> The Intersection evaluation strategy is useful for modeling "compatibilities"
> with tags. Common use cases are modeling access to landing zones/services or
> enforcing the use of specific "admin" principals/user groups for prod
> environments.

Example:

In this example, we're looking at a policy between a User/Group `environment`
tag, and a workspace's `environment` tag with the following allowed values:
`dev`, `qa`, and `prod`. The User/Group is the affected subject and the
workspace is the authoritative subject.

| Workspace<br> _authoritative_ | User/Group<br> _affected_ | Result | Explanation                                                         |
| ----------------------------- | ------------------------- | ------ | ------------------------------------------------------------------- |
| `prod`                        | `prod`                    | ✓      | `prod` is present on User/Group and Workspace                       |
| `dev`, `qa`                   | `prod`                    | ✖      | User/Group `prod` is not present on Workspace `qa`,`dev`            |
| `dev`                         | < empty >                 | ✖      | No overlapping value, the intersection is empty                     |
| < empty >                     | `dev`                     | ✖      | No overlapping value, the intersection is empty                     |
| < empty >                     | < empty >                 | ✓      | Null sets rule: Both subjects have no tag values, the policy passes |
| `qa`, `dev`                   | `prod`, `qa`              | ✓      | User/Group `qa` is present in Workspace `qa`,`dev`                  |
| `qa`, `dev`                   | `dev`, `qa`               | ✓      | `dev`, `qa` is present on User/Group and Workspace                  |

### Policies for Users/Groups

Users and WorkspaceUserGroups are treated as a common "Principal" object when it
comes to policies. You can only define a policy for "User/Group". Those policies
will always apply to both subject types. It is not possible to define a policy
that only matches users, but not WorkspaceUserGroups. The reason for that is
that you can assign both subject types (users and WorkspaceUserGroups) to
workspaces and projects. If you want to restrict this access to, e.g., only
allow access to production for certain users and groups, the policy always has
to apply to both subject types. It wouldn't make sense to restrict only the
assignment of groups, but you could still assign any user. Because of that, you
can only select "User/Group" as a policy subject in a policy.

Users exist on a global level and are not related to a specific workspace. If
you want to define a policy to only provide certain users/groups access to,
e.g., production projects, the following aspects have to be considered:

1. If a user is globally defined to have access to any production project, you
   can add the production environment tag to that user, so this user gets access
   to all production projects in all workspaces.
2. If you want to maintain per workspace who has access to production projects,
   you have to use [WorkspaceUserGroups](./meshcloud.workspace.md#user-groups)
   for that. It is not possible to assign a single user certain tags within a
   certain workspace.
3. To provide easy access to "unrestricted" projects (e.g. those with the
   environment "dev" and "qa") we provide
   [default tags](./meshstack.metadata-tags.md#tags-on-meshusers) for users.
   meshStack makes sure that these default tags are applied to all users.

### What can I achieve with policies?

Based on your tags defined in the policies, you can

- restrict (new) projects to a workspace
- restrict the new _assignments_ of users/groups to workspaces
- restrict the new _assignments_ of users/groups to projects
- restrict the new _assignments_ of LandingZones to projects

### When am I impacted by policies?

> If your organization has no policies defined, the information below is not
> relevant.

We will discuss the possible places here where you may encounter policies when
doing any of the following actions:

1. Creating a new project
   1. When adding a platform with a LandingZone to a new project, all policies
      are evaluated between a 'project' and a 'LandingZone'
   2. When adding a new user or WorkspaceUserGroup to a workspace, all policies
      are evaluated between the 'workspace' and the 'User/Group'.
   3. Upon saving a new project, all policies are evaluated between 'workspace'
      and 'project'.
2. Editing a project
   1. When adding a new tenant with a LandingZone, all policies are evaluated
      between the 'project' and the selected 'LandingZone'.
   2. When adding a new user or WorkspaceUserGroup to a project, all policies
      are evaluated between the 'project' and the 'User/Group'.
   3. When changing a tag value (e.g., changing the environment) of a project,
      **all** policies related to the project are evaluated as it impacts many
      policy subjects. The following policy subjects will be evaluated against
      the project:
      - the workspace the project lives in
      - all assigned LandingZones
      - all assigned users
      - all attached WorkspaceUserGroups
3. Adding a user or WorkspaceUserGroup to a workspace. All policies are
   evaluated between 'workspace' and 'User/Group'.

> In the meshPanel, non-compliant choices are disabled or excluded in the lookup
> case of the users/groups.

### What happens when I violate a policy?

It might happen, consciously or unconsciously, that you violate one or more
policies. At every place in the meshPanel that is mentioned above this section,
we prevent you from committing a violation by disabling non-compliant choices or
excluding them from the lookup in case of the users/groups. Via the meshPanel,
you will therefore barely come across a violation. But there are some cases in
which we can't disable the non-compliant choices for you. Thus, we prevent you
from finalizing the violation by prompting an error message explaining which
policy or policies you violated, and why.

Take this policy violation as an example (see the picture below), where we have
a policy defined on 'workspace' and 'project' with the evaluation strategy
'Subset', both on the `environment` tag.

![Example Policy Error Message](assets/mesh_policies/policies_example_error_message.png)

The project called 'my-example-project-prod' now only has environment `prod` set
and the workspace 'managed-workspace' the project lives in, has environments
`dev`, `test` and `qa` defined. This means there is a mismatch as `<prod>` is
not inside `<dev, test, qa>`. To solve this problem, we have to pick an
environment that is defined on the workspace, e.g., `dev`. After picking a valid
environment value, we can save the project again, and (if we don't violate any
further policies) the project tag is successfully saved, including the right
compliance for your organization! ✅

### Are there any other places where policies are enforced?

Besides end-users being impacted at the places above, there are also other
places where policy violations could be caused. For example, while editing tags
of the authoritative policy subjects like workspace or project. Your tag choices
might not be compliant with your existing assignments anymore. These violations
will be logged. The diagram below describes all possible relationships between
policy subjects and the behavior that is expected depending on the change of a
subject.

```mermaid
flowchart TB
    subgraph Legend
    start1["blocking violation on new assignments of"]:::legendClass --> stop1[ ]:::legendClass
    start2["logging violation of existing assignments on"]:::legendClass -.-> stop2[ ]:::legendClass
    start3["blocking violation on creation and editing of"]:::legendClass --> stop3[ ]:::legendClass
    end
    subgraph In case of policies violation
    direction TB
      Workspace:::authoritativeClass --> Project
      Workspace --> User/Group
      Project --> User/Group
      Project:::authoritativeClass --> LandingZone
      LandingZone -.-> Project
      User/Group -.-> Workspace
      User/Group -.-> Project

    end

classDef authoritativeClass fill:#dae8fc;
classDef legendClass height:0px;
linkStyle 2 stroke: blue;
linkStyle 3 stroke: blue;
```

> If you have a policy between the workspace and project. Editing project tags
> still causes a blocking violation if not compliant with a workspace.

### Policy Examples

> The information below might be more relevant for administrators, but
> nevertheless it should give you a rough idea of how policies could be
> implemented.

Your organization is fully free to define policies across the entire meshStack.
A few common use cases are:

1. Enforcing that a project is used for an environment that is also defined on
   its workspace.

   Imagine a workspace with `environment=[sandbox, test]`. If there is a policy
   in place between workspaces and projects on the environment tag, users cannot
   create new projects that use an environment that is not available on the
   workspace, for example `environment=[prod]`.

   > You can configure the environment tag as immutable. Immutable means that
   > the tag values of the environment tag can only be set during the creation
   > of the policy subject. It can't be changed afterward. With this
   > configuration, you can ensure the subject is always compliant with its
   > existing assignments.

2. Enforcing that a project only has users/groups that are allowed access highly
   confidential projects or production projects.

3. Enforcing that a project only has LandingZones assigned to it that are meant
   for the environment of the project.

4. Enforcing that a project only has LandingZones assigned to it that are meant
   for the given business unit of the project.


---


---
id: meshcloud.landing-zones
title: Landing Zones
---

Landing Zones describe a set of policies that are automatically applied to [tenants created for a meshProject](./meshcloud.project.md). They relate to a "bootstrap" configuration in the meshPlatform, that sets
up and configures the cloud tenant according to policies and requirements of your company.

Typical use-cases for Landing Zones are setting up cloud tenants to restrict administrative privileges
over core configuration like identity and access management. This ensures company policies with regards to authentication
and authorization are consistently enforced across all cloud tenants. Other common use cases include cloud service or
region restrictions to ensure compliance regarding data processing restrictions.

Another use-case is defining default quotas in private cloud environments that are directly applied to your [meshTenant](./meshcloud.tenant.md) after creation.
This allows your Platform Operators to provide you direct access with a limited scope. When you require a higher quota, you can create a [quota request](./meshcloud.tenant-quota.md), which must be [approved](meshcloud.tenant-quota.md#approval-of-tenant-quota-requests) by a platform operator.

Platform Operators can provide multiple Landing Zones per meshPlatform. This allows e.g. different setups
for a Dev, QA and Production stage. Landing zones can also consume project meta-data like cost-center or similar attributes
and use it.

> Only your Platform Operators can configure Landing Zones and control their content. Your operations team
> can provide details how Landing Zones are used in your meshcloud installation.

## Using Landing Zones

Workspace managers can choose a Landing zone when [adding meshTenants](./meshcloud.project.md#adding-meshtenants) to a meshProject.
It is not possible to change the chosen Landing Zone of an existing meshTenant. The only way of doing so is by removing the meshTenant and creating another by re-adding the same meshPlatform to the Project again.


---


---
id: meshstack.aws.sso-setup
title: SSO Setup
---

> This guide was written for AWS SSO, which has a new name AWS IAM Identity Center. The guide is still valuable and applicable.

## Enable AWS SSO

Switch to AWS Console and search for `sso`, now choose `AWS Single Sign-on`

![assets/aws_sso_setup/aws_single_sign_on.png](assets/aws_sso_setup/aws_single_sign_on.png)

Now choose `Enable AWS SSO`

![assets/aws_sso_setup/aws_enable_sso.png](assets/aws_sso_setup/aws_enable_sso.png)

## Configure an External IdP

Configure the identity source by clicking on `Choose your identity source`

![assets/aws_sso_setup/aws_choose_identity_source.png](assets/aws_sso_setup/aws_choose_identity_source.png)

Now choose `change` on `Identity source`

![assets/aws_sso_setup/aws_change_identity_source.png](assets/aws_sso_setup/aws_change_identity_source.png)

Select `External identity provider`

![assets/aws_sso_setup/aws_set_identity_source_external.png](assets/aws_sso_setup/aws_set_identity_source_external.png)

Download `AWS SSO SAML metadata` to later use this metadata for configuration in your source IdP (e.g. AAD). Leave this tab open, as you also need to add the IdP SAML metadata later on. But at first we have to get this metadata from the IdP.

## Configure AAD as IdP for AWS SSO

This section describes how to set up AWS SSO with Azure Active Directory. Make sure that you have the "Application Administrator" role in Azure assigned to you. Even if you are "Global Administrator", you require additionally this role.

### Create an Enterprise Registration in AAD

Go to `Enterprise applications` on Azure, click on `New application` and search for `aws` and choose `AWS Single Sign-on`

![assets/aws_sso_setup/azure_create_enterprise_application.png](assets/aws_sso_setup/azure_create_enterprise_application.png)

Follow the steps in AAD under Getting Started. Mandatory are only the first 3 steps. Conditional Access and Self service are optional.

![assets/aws_sso_setup/aad_getting_started.png](assets/aws_sso_setup/aad_getting_started.png)

#### 1. Assign users and groups

You have to assign users who shall have access to the enterprise application. Ideally you can build some automation to add the required users to the enterprise application.

#### 2. Set Up SSO via SAML

Pick SAML as the SSO method. Use the `AWS SSO SAML metadata` you downloaded before from AWS. Upload it into `Single Sign-On` page on Azure with the `Upload metadata file` button.

![assets/aws_sso_setup/azure_upload_metadata.png](assets/aws_sso_setup/azure_upload_metadata.png)

Click Save in the "Basic SAML Configuration" dialog. You may need to reload the page now, as Azure may still show "Required" for the Reply URL, but that is just a display issue in Azure.

Next you have to download the SAML `Federation Metadata XML`.

![assets/aws_sso_setup/azure_download_certificate.png](assets/aws_sso_setup/azure_download_certificate.png)

After downloading the `Federation Metadata XML` file from Azure you must upload it into your `AWS SSO Identity Source` as `IdP SAML metadata`. This configuration can also be set manually to do that use the Azure `Login URL` as the AWS `IdP sign-in URL` and `Azure AD Identifier` as the `IdP Issuer URL`.

#### 3. Provisioning

Automatic provisioning can be set via `SCIM`. Select `enable automatic provisioning` on AWS SSO service to get the `Tenant URL` and `Access Token` to configure SCIM on Azure AD Enterprise Application from `AWS Single Sign-on | Provisioning` tab. These secrets must be also shared with meshcloud Operator to configure the replicator service.

![assets/aws_sso_setup/azure_tenant_url_secret_token.png](assets/aws_sso_setup/azure_tenant_url_secret_token.png)

> An important precondition regarding the automated user provisioning to AWS SSO is, that the userName in AWS SSO will be set to the [euid](meshstack.identity-federation.md#externally-provisioned-identities). This limitation is caused by AWS SSO only allowing to filter on userNames to find users. Azure AD attributes can be mapped to AWS SSO service with `Mappings` configuration.
![assets/aws_sso_setup/azure_mappings.png](assets/aws_sso_setup/azure_mappings.png)

Disable the Group sync in Azure by clicking on the "Provision Azure Active Directy Groups" mapping and disable it in the details screen. Usually only groups managed by meshStack will be used and also they will be created by meshStack.

When `Provision Azure Active Directory Users` button is clicked, the following page shows userPrincipalName to userName mapping cannot be deleted because it is mandatory attribute and it has to be synchronized however any `Azure Active Directory Attribute` can be mapped to `userName`.
![assets/aws_sso_setup/azure_sso_attiribute_mapping.png](assets/aws_sso_setup/azure_sso_attiribute_mapping.png)

> In the `Settings` section of the `Provisioning` you could define the scope of users. You could switch to using not only users assigned to the Enterprise Application, but all users of the directory. The problem with this provisioning approach is that SSO login via SAML won't be possible, because only users assigned to the enterprise application are allowed to log in via SAML.

![assets/aws_sso_setup/azure_replication.png](assets/aws_sso_setup/azure_replication.png)

Once you configure "Provisioning", you should click `Start provisioning` and it will replicate your Users and Groups into AWS SSO. After this point this service will replicate the users every 40 minutes however you can always use `Provision on demand` or `Restart provisioning` buttons to run that replication.

![assets/aws_sso_setup/aws_users.png](assets/aws_sso_setup/aws_users.png)

## Create AWS SSO Permission Sets

In order to assign groups created by meshStack to a certain Permission Set on an AWS account, you have to create according Permission Sets in AWS SSO.

![assets/aws_sso_setup/permission_sets.png](assets/aws_sso_setup/permission_sets.png)

By default three project roles are available in meshStack: Project Admin, Project User, Project Reader. If you don't have
specific PermissionSets in mind yet, a good starting point is to provide the following defaults for the three roles. When creating
a new Permission Set you can select "Use an existing job function policy" and then select the following job function policies:

- AdministratorAccess
- PowerUserAccess
- ViewOnlyAccess

These `permission set` ARNs will be used by replicator as default policies. Customers can modify their policies later without affecting ARN to decide which policies they want to assign their users.


---


---
id: meshstack.gcp.index
title: Integration
---

Google Cloud Platform (GCP) is a public cloud platform provided by Google.
meshStack supports project creation, configuration, access control and cost management for GCP.

## Integration Overview

> The recommended way to set up GCP as a meshPlatform is via the public terraform [GCP meshPlatform Module](https://github.com/meshcloud/terraform-gcp-meshplatform). If you decide to use it, you do not need the steps below.

To enable integration with GCP, Platform operators configure one or multiple `meshPlatform`s of `PlatformType` GCP in the [Platform Administration](./administration.platforms.md) in meshPanel.

Google Cloud Platform relies on [Google Cloud Identity (GCI)](https://cloud.google.com/identity/) for authentication and authorization. meshStack can seamlessly integrate with GCI and various hybrid identity setups.
Organizations already using Google Cloud Directory Sync or Google Workspace can use meshStack with an [externally provisioned identities](./meshstack.identity-federation.md) configuration.

meshcloud helps organizations implement Google Cloud Platform in line with [governance best-practices](https://cloud.google.com/docs/enterprise/best-practices-for-enterprise-organizations) by integrating with the GCP [Organization Resource Hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy) and [Organization Policy Service](https://cloud.google.com/resource-manager/docs/organization-policy/overview) using [Landing Zones](./meshstack.gcp.landing-zones.md).

In order to plan and execute a successful integration of GCP using meshcloud, organizations need to consider the following parts described in the sections below.

> As part of an integration project meshcloud typically delivers a configuration tailored to your organization's specific requirements using infrastructure as code (IaC) tools. The descriptions below serve as a general reference.

## Cloud Identity Setup

Cloud Identity "Free" is sufficient for automated GCP IAM management through meshStack. meshStack does not require Cloud Identity Premium nor Google Workspace features.

We recommend using [externally provisioned identities](./meshstack.identity-federation.md) with GCP.

## Organization Setup

Platform Operators need to set up a GCP Organization to be used by meshStack. Please review the official GCP documentation on [creating and managing organizations](https://cloud.google.com/resource-manager/docs/creating-managing-organization).


## How to integrate GCP as a meshPlatform into meshStack

This is described in the Guide section under [How to integrate a meshPlatform into meshStack](meshstack.how-to.integrate-meshplatform.md).


---


---
id: meshstack.identity-lookup
title: Identity Lookup
---

> The recommended way to set up [user provisioning via SCIM](./meshstack.user-group-provisioning.md). The instructions below are not needed if users are provisioned via SCIM.

meshStack allows Workspace Managers to [quickly onboard team members](./meshcloud.workspace.md#invite-users-to-a-meshworkspace-team) with an assisted onboarding workflow.
This onboarding workflow features an autocomplete and search for user identities in an enterprise user directory. We call this search process identity lookup.

<!--snippet:mesh.meshfed.web.identity-lookup-->

The following configuration options are available at `mesh.meshfed.web.identity-lookup`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let IdentityLookup =
    {-
      Configure identity lookup to support invitation workflow.

        provider:
            Configure the identity provider to use as a source for identity lookup.

        deny-assigning-other-users:
            Controls the behavior of self-service user invitations (e.g. workspace role assignments from meshPanel).
            When true, users can only invite other users listed in the identity provider.
            When false, users can create invitations also for users not listed in the identity provider.
    -}
      { provider : Optional IdentityProvider
      , deny-assigning-other-users : Bool
      }
```
<!--Example-->
```dhall
let example
    : IdentityLookup
    =
      -- do not use identity lookup, in this case it's important to allow assigning other users
      { provider = None IdentityProvider
      , deny-assigning-other-users = False
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

Partners have the option of disabling the invitation of users that are not listed in the identity provider. They can do so by setting the `deny-assigning-other-users` configuration option to `true`.

If you have Identity Lookup configured, the panel user search functionality will lookup users from two sources: the meshStack database, and the enterprise directory. In order to identify the same user coming from the two sources as the same user, meshStack uses the username or the email. In other words, if a user looked up from the enterprise directory has the same username or the same email as a user from meshStack database, meshStack will treat that user to be the same and will not consider them as two different users in the Identity Lookup.

## Supported Identity Providers

meshStack supports configuring either of the following identity providers as identity lookup source.

<!--snippet:mesh.meshfed.identitylookup.identityprovider#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let IdentityProvider =
      < Azure : AzureIdentity
      | Gcd : GcdIdentity
      | GcdEuid : GcdIdentityAndEuid
      >
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Azure Active Directory

In order to use Azure lookup functionality, you must create a new service principal as described in [Azure Service Principal Setup](./meshstack.azure.index.md#service-principal-setup) and assign the following required permissions as an **application permission**:

- `User.Read.All`

> You will also need to grant admin consent in AAD in order to activate the  `User.Read.All` permission.

Operators must then configure the service principal credentials and user lookup configuration as follows.

<!--snippet:mesh.meshfed.identitylookup.azure.creds#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AzureCreds =
    {-
      Setting this configuration enables the use of an AAD as a user lookup source to allow
      autocomplete of user information when adding new users to workspaces.

        aad-tenant:
            The active directory tenant. Its either a UID of the AAD or its domain
            like devmeshcloud.onmicrosoft.com

        client-id:
            The client id of the service principal

        client-secret:
            The credentials of the service principal


    -}
      { aad-tenant : Text
      , client-id : Text
      , client-secret : Secret.Type
      , guestLookup : Optional AzureGuestDetection
      , euidSchemaExtensionUpdate : Optional AzureEuidExtensionSchema
      , euidUserAttributeUpdate : Optional AzureEuidUserAttribute
      , usernameAttributeUpdate : Optional AzureUsernameAttributeUpdate
      , emailAttributeUpdate : Optional AzureEmailAttributeUpdate
      }

let AzureIdentity = { azure : AzureCreds }
```
<!--Example-->
```dhall
let example
    : AzureCreds
    = { aad-tenant = "devmeshcloud.onmicrosoft.com"
      , client-id = "f112f31-248a-4461-1269-0f13164acb95"
      , client-secret = Secret.fromTerraform "client_secret"
      , guestLookup = None AzureGuestDetection
      , euidSchemaExtensionUpdate = None AzureEuidExtensionSchema
      , euidUserAttributeUpdate = None AzureEuidUserAttribute
      , usernameAttributeUpdate = None AzureUsernameAttributeUpdate
      , emailAttributeUpdate = None AzureEmailAttributeUpdate
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

With this initial config is present, Partners can set up the following optional settings to customize the way meshStack provisions user accounts from identity lookup.

To provision new meshUsers as [guest users](./administration.users.md#guest-users), configure the guest detection.

<!--snippet:mesh.meshfed.identitylookup.azure.guest#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AzureGuestDetection =
    {-
      When adding/inviting a new meshUser check AAD User attributes data to determine if the meshUser shall be provisioned as a guest user in meshStack.

      Attention: This check is only performe on the first attempt when a user is added/invited
      to a workspace. If this check is configured after some users were initially added to a
      workspace they are not detected as guest users.

        guestProperty:
            The AAD's custom attribute which is checked against the guestValue.
            This can be any attribute that can be retrieved via the MS Graph API GET user $select query parameter
            https://docs.microsoft.com/en-us/graph/api/user-get?view=graph-rest-1.0&tabs=http

        guestValue:
            If the AAD custom attribute matches this value, the user is considered to be a guest.
    -}
      { guestProperty : Text, guestValue : Text }
```
<!--Example-->
```dhall
let exampleUsingOnlyUserType
    : AzureGuestDetection
    =
      -- use only the AAD userType to determine meshUser guest status
      { guestProperty = "userType", guestValue = "Guest" }

let exampleWithSchmaExtension
    : AzureGuestDetection
    =
      -- Note that meshStack implicitly adds an additional check for userType=Guest
      -- when configuring a custom guestProperty. This configuration will thus check
      -- userType=Guest && extension_1234_supplierContractType=contractor
      { guestProperty = "extension_1234_supplierContractType"
      , guestValue = "contractor"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

To use an AAD attribute as euid

<!--snippet:mesh.meshfed.identitylookup.azure.euid-user-attribute#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AzureEuidUserAttribute =
    {-
      When adding/inviting a new user to a workspace a (custom) attribute property from the users AAD
      schema can be used to fill in his euid. For a list of user attributes for the AAD user object
      see:

      https://docs.microsoft.com/en-us/graph/api/resources/user?view=graph-rest-1.0#json-representation

      Attention: This check is only performed on the first attempt when a user is added/invited
      to a workspace. If this check is configured after some users were initially added to a
      workspace their euid's are not udpated.

        userAttributeName:
            The AAD's user (custom) attribute.
    -}
      { userAttributeName : Text }
```
<!--Example-->
```dhall
let example
    : AzureEuidUserAttribute
    = { userAttributeName = "mailNickname" }
```
<!--END_DOCUSAURUS_CODE_TABS-->

To use an attribute from the AAD extension schema as euid

<!--snippet:mesh.meshfed.identitylookup.azure.euid-extension-schema#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AzureEuidExtensionSchema =
    {-
      When adding/inviting a new user to a workspace a custom attribute property from the users AAD
      extension schema can be used to fill in his euid.

      Attention: This check is only performed on the first attempt when a user is added/invited
      to a workspace. If this check is configured after some users were initially added to a
      workspace their euid's are not udpated.

        euidExtensionSchemaProperty:
            The name of the extension schema property which is used as EUID value.

        euidExtensionSchemaIdentifier:
            The identifier of the custom schema which should be used to extract the value out of.
            See: https://docs.microsoft.com/en-us/graph/api/schemaextension-post-schemaextensions
    -}
      { euidExtensionSchemaProperty : Text
      , euidExtensionSchemaIdentifier : Text
      }
```
<!--Example-->
```dhall
let example
    : AzureEuidExtensionSchema
    = { euidExtensionSchemaProperty = "uniqueid"
      , euidExtensionSchemaIdentifier = "extkvbmkofy_mySchema"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

To use an AAD attribute other than userPrincipalName attribute, which is the default, as the meshUsers' username (Note that this cannot be used together with AzureEmailAttributeUpdate)

<!--snippet:mesh.meshfed.identitylookup.azure.username-property-update#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AzureUsernameAttributeUpdate =
    {-
      When adding/inviting a new user to a workspace a custom attribute property from the users AAD
      extension schema can be used to fill in his username.

      Cannot be used together with an AzureEmailAttributeUpdate.

        propertyToUse:
            The name of the user property which is used as the username value. E.g. 'mailNickname'.

        formatString:
            A Java String#format compatible string to replace/modify the found property with. For example to add a prefix to
            the property value set it to 'myprefix-%s'
    -}
      { propertyToUse : Text, formatString : Optional Text }
```
<!--Example-->
```dhall
let example
    : AzureUsernameAttributeUpdate
    =
      {- To use the email as the meshUser's username -}
      { propertyToUse = "mail", formatString = None Text }
```
<!--END_DOCUSAURUS_CODE_TABS-->

To use an AAD attribute, other than the  "mail" attribute which is the default, as the meshUsers' email (Note that this cannot be used together with AzureUsernameAttributeUpdate)

<!--snippet:mesh.meshfed.identitylookup.azure.email-property-update#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AzureEmailAttributeUpdate =
    {-
      When adding/inviting a new user to a workspace a custom attribute property from the users AAD
      extension schema can be used to fill in his email.

      Cannot be used together with an AzureUsernameAttributeUpdate.

        propertyToUse:
            The name of the user property which is used as the email value. E.g. 'userPrincipalName'.

    -}
      { propertyToUse : Text }
```
<!--Example-->
```dhall
let example
    : AzureEmailAttributeUpdate
    = {- If the userPrincipalName is a secondary email that you want to set as meshUser's email -}
      { propertyToUse = "userPrincipalName" }
```
<!--END_DOCUSAURUS_CODE_TABS-->

> As mentioned above, both AzureEmailAttributeUpdate and AzureUsernameAttributeUpdate cannot be used at the same time. This is because  meshStack requires either the standard username (which is the userPrincipalName), or the standard email to be used as the user's username or email to uniquely identify a user already in meshStack and coming from AAD lookup.

### Google Cloud Identity

In order to use Google Cloud Directory (also called Google Cloud Identity) as a lookup provider you need to provide these credentials:

<!--snippet:mesh.meshfed.identitylookup.gcd.creds#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let GcdCreds =
    {-
      Setting this configuration enables the use of an GCD as a user lookup source to allow
      autocomplete of user information when adding new users to workspaces.

        domain:
            The domain used for cloud identity directory-groups created and managed by meshStack.
            meshStack maintains separate groups for each meshProject role on each managed GCP project.

        customer-id:
            The client id of the service principal

        service-account-credentials-b64:
            The credentials of the service principal
    -}
      { domain : Text
      , customer-id : Text
      , service-account-credentials-b64 : Secret.Type
      }
```
<!--Example-->
```dhall
let example
    : GcdCreds
    = { domain = "example.com"
      , customer-id = "customer-id"
      , service-account-credentials-b64 =
          Secret.fromTerraform "gcp_credentials"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

The GCD Service User needs read access to the [GCD Directory API](https://developers.google.com/admin-sdk/directory/v1/get-start/getting-started).

If this initial config if present you can decide to set up the following optional user identity steps:

<!--snippet:mesh.meshfed.identitylookup.gcd.euid#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let GcdEuid =
    {-
      When adding/inviting a new user to a workspace a custom attribute property from the users GCD
      custom schema can be used to fill in his euid.

      Attention: This check is only performed on the first attempt when a user is added/invited
      to a workspace. If this check is configured after some users were initially added to a
      workspace their euid's are not udpated anymore.

        euidCustomSchema:
            The name of the extension schema which contains the EUID value.

        euidProperty:
            The name of the custom schema property which is used as EUID value.
    -}
      { euidCustomSchema : Text, euidProperty : Text }
```
<!--Example-->
```dhall
let example
    : GcdEuid
    = { euidCustomSchema = "schema-containing-euid"
      , euidProperty = "euid-property"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->



---


---
id: meshstack.building-blocks.private-runners
title: Private Runners
---

Private runners can be used to execute building blocks in your own cloud environment to enable access to resources that are not publicly accessible.

These runners are still operated by meshcloud but run outside of your meshStack.
Otherwise private runners operate like regular runners and connects to meshStack via meshStack API. 

When using a private runner it will run all building blocks from your meshStack.

## Requirements for private runners

To use private runners meshcloud operators need access to an environment with

- network access to your meshStack,
- internet access for sourcing building block code and requirements (e.g. Terraform providers),
- a way to run container based workloads (e.g. Kubernetes),
- a way to facilitate automatic updates to the runner.

## Communication between private runners and meshStack

The private runner connects to the parent meshStack to receive building block executions.
Since the private runner opens a connection to your meshStack, inbound connections to the runner are not needed.

```mermaid
graph LR

subgraph meshStack
  API
end

subgraph private network
  runner[private runner]
end

runner --HTTPS via public internet--> API
```


---


---
id: administration.delete-tenants
title: Delete Tenants
---

The process for [deleting a tenant](meshcloud.tenant.md#delete-a-meshtenant) always starts by putting the tenant in the deletion queue from the workspace view.

## Tenant Deletion Process

The behavior for deletion depends on the configuration defined in the landing zone of the tenant's platform. The tenant deletion process has the following stages described in the sections below.

### Request

Application teams owning a workspace can start the tenant deletion process by deleting the tenant from their project.
This places the tenant on the tenant deletion queue.

Until tenant deletion is approved, meshStack will continue replicating the tenant but will disable all
assigned project roles. This has the effect that application teams will loose access to the tenant in the cloud platform.

### Approval

meshStack assigns the status "Requires approval" to tenants entering the tenants deletion queue.
By default, an operator must manually [approve tenant deletion](#processing-the-tenant-deletion-queue) from the "Deleted Tenants" view in the admin area.
You can configure meshStack to auto-approve tenant deletion requests in the settings of the respective landing zone.

Configuring this setting per landing zone allows you to adapt the tenant deletion behavior to your
specific needs. For example, you might not want to be involved with each single deletion request for  a sandbox landing zone that is intended for experimentation. But perhaps your organization requires a more
careful process for deleting tenants in a landing zone hosting production workloads.

Once a tenant deletion was approved, it's not possible to abort the tenant deletion process.

> If you have the Open Service Broker marketplace experience enabled, the OSB Marketplace tenants are automatically approved and deleted.

### Deletion Replication

After approving tenant deletion, meshStack assigns the tenant status "Pending deletion".
In this status meshStack will verify if the tenant still exist and attempt to delete any IAM groups, permissions and other artifacts managed by meshStack for this tenant. 

By default, an operator must manually perform the deletion of the cloud tenant itself directly in the cloud platform.
You can configure meshStack to automatically perform the deletion of the tenant in the settings of the respective landing zone.

Once meshStack has confirmed the tenant was deleted (or entered a Suspended/Disabled state as part of the platform's deletion process), meshStack will conclude the deletion process and set the tenant status to "Deleted".

> **Warning**: Operators shold consider automated tenant deletion carefully as most cloud platforms will
> delete any workload together with the tenant. This can lead to irrecoverable loss of data. In some 
> platforms (AWS, Azure, GCP) workload can be recovered for a limited period after deletion. Please
> review your platform's documentation for details.

Please be aware that meshStack itself does not delete nor touch any of the cloud resources in the tenant. Depending on the cloud platform, this can lead to situations where billing does not stop
immediately once a tenant is deleted.

## Processing the Tenant Deletion Queue

To open the tenant deletion queue, follow these steps:

1. Navigate to the **Administration** Area.
2. Click on **Deleted Tenants** under **Platforms**. You can see a list of deleted tenants and tenants in the deletion queue.

### Approving Tenant Deletion

You can filter tenants that require approval by selecting the status column and choosing the dropdown option `Requires approval`.

As a partner or a platform operator, you have the option to either confirm or decline the deletion of the tenant. For either decision, you can also enter an optional comment which is limited to 255 characters.

Depending on the configuration of the tenant's landing zone, meshStack will ask you to confirm whether you want meshStack to perform the tenant deletion automatically or that you will manually perform deletion in the cloud platform.

> When a user marks a project for deletion, the project will be automatically deleted once all tenants of that project have been successfully deleted.

### Rejecting Tenant Deletion

If you choose to decline the deletion, you can do so by clicking on the decline button. When you decline tenant deletion, the tenant will be reinstantiated in its project. meshStack will also re-enable any project role bindings on the tenant. This has the effect that application teams will re-gain access to the tenant in the cloud platform.

### Review Deleted Tenants

You can filter tenants that were deleted successfully by selecting the status column and choosing the dropdown option `Deleted`.

---


---
id: meshstack.backup
title: Backup
---

meshcloud will operate your meshStack installation as a managed service for you. This includes the facilitation of backups for the data stored in your environment.

## Standard Backup Configuration

Backup are facilitated once a day. Backup files will be stored for 30 days. Depending on the cloud platform hosting the meshStack environment
the backup files will be stored in the available object storage of the cloud provider (e.g. AWS S3, GCP Cloud Storage) using an appropriate data encryption method supported by the provider (e.g. key based encryption).

> If you have deviating requirements regarding backup frequency and/or retention please contact support@meshcloud.io.
> It is also possible to provide you access to the object storage in order to transfer the files in a central backup solution within your organization.


---


---
id: administration.workspace-services
title: Workspace Services
---

> Please note that the following functionality is only available to meshStacks that have the **Service Economy** module activated.
> Reach out to your Customer Success representative if you are interested in using this module.

## Workspace Services

As an admin you can view all services that are offered by workspaces through their [Service Management Area](./marketplace.service-management-area.md).
You can find this view in the Admin Area by going to "Workspace Services" under "Marketplace" on the left sidebar.

![Workspace Services Overview](./assets/service-management-area/workspace-services-overview.png)

These are all Platforms & Building Blocks that exist in the organization. The list contains everything, including services
that are not approved and globally available yet, or that have been rejected.

A workspace service can have one of the following states:

- Requires Approval: The service is not globally available and requires approval from you or another admin.
- Rejected: The service is not globally available and has been rejected by you or another admin.
- Approved & Published: The service was approved and is globally available in the marketplace.

## Approval Workflow

To review a service, open the Workspace Services view. Services that require your approval or have been rejected are
automatically at the top of the page.

![Workspace Services](./assets/service-management-area/workspace-services.png)

Upon selecting a service, you will be directed to its Control Plane. From there, you can either reject the publication request, or approve it, making the service accessible to all workspaces within your organization.

![Approval](./assets/service-management-area/service-approval.png)


---


---
id: administration.unmanaged-tenants
title: Unmanaged Tenants
---

## What is an unmanaged tenant?

Workload that is running indefinitely without anyone's awareness can be an easy way to burn through cloud budget. This is otherwise
known as 'Shadow IT'. To make it easier to spot this kind of workload, meshStack offers a table view of all tenants that are unmanaged.

The definition of an unmanaged tenant is a cloud tenant that is not related to any meshWorkspace & meshProject. In other words, it does not
have any organizational metadata applied to it, and it is "unknown" who owns the tenant from a meshStack perspective.

> If you recently started using meshStack, you will most likely have a lot of unmanaged tenants. This is fine
> as you are still working on starting to manage these tenants via meshStack.

## Viewing unmanaged tenants

Viewing unmanaged tenants can be easily done within the administration area. In the sidebar on the left, navigate to 'Platforms' -> 'Unmanaged Tenants'.

A table will open up with all unmanaged tenants that are known to meshStack. This list is refreshed on a daily basis.

It is also recorded when the unmanaged tenant was last observed. If the unmanaged tenant has not been observed for a few days meshStack will
assume that it has been deleted in the cloud platform and will remove it from the list.

The screenshot below depicts how the unmanaged tenant list could look like.

![Unmanaged Tenants](assets/unmanaged-tenants.png)

## Assigning Unmanaged Tenants

It is recommended to manage all your tenants via meshStack, so they are assigned a clear ownership, and you benefit from the full Tenant Management
capabilities that meshStack has to offer.

You can easily assign an unmanaged tenant to a project in meshStack by doing the following:

- Click the "Assign to project" button as depicted in the screenshot
- In the prompt that opens up, select to which workspace & project this tenant should belong
- Select the Landing Zone that should be applied to this tenant.
  - The Landing Zone will automatically be applied after the first tenant replication and the
    tenant will e.g. be assigned in the resource hierarchy in the cloud platform

![Unmanaged Tenant Assignment](assets/unmanaged-tenants-assignment.png)

Tenants that are assigned into meshStack are removed from the unmanaged tenants list and shown in the tenants list instead.

Alternatively, if you prefer building an automation or an "as Code"-approach, you can use the [meshTenant API Import](https://docs.meshcloud.io/api/#_meshtenant).

### Unmanaged AWS tenants

To import an unmanaged AWS account into a Workspace and Project, the account must be configured for meshStack integration. This configuration involves setting up an IAM role with a trust relationship to the root or master account of the AWS organization to which the account belongs.

Create the IAM role named `MeshstackAccountAccessRole` in the unmanaged account and assign the AWS managed IAM Policy `AdministratorAccess` to it. Once the account import is complete, the IAM role's permissions will be reduced to the required level.

Add the following trust relationship to the IAM role `MeshstackAccountAccessRole`, substituting `ROOT_ACCOUNT_ID` with the AWS account ID of the organization's master or root account.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::<ROOT_ACCOUNT_ID>:role/MeshfedServiceRole"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

Once the role is established, the unmanaged AWS account can be assigned to a project, allowing you to proceed with the steps outlined above.


---


---
id: administration.service-brokers
title: Open Service Brokers (OSB)
---

To manage Open Service Brokers that are available in the system go to the Service Broker page of **Marketplace** section of the **Administration** area .

All available Service Brokers are listed here, even the [private](meshstack.meshmarketplace.development.md#register-your-service-broker) ones. This provides Partners with an overview about all Service Brokers in the system.

## Approve Service Broker

When a User [publishes](meshstack.meshmarketplace.development.md#publish-your-service-broker) a Service Broker, Partner has to approve the Service Broker first. To approve a Service Broker, the **check** button for the according Service Broker must be clicked. After approval, the services of the approved Service Broker will be available for all Users in the Marketplace Catalog.



---


---
id: meshstack.how-to.change-workspace-owner
title: How to change the Workspace Owner of a meshWorkspace via API
---

This how-to guide is targeted at Cloud Foundation Partners. You need a meshObject API user with permissions `Get any meshObject`, `Import any supported meshObject`, and `Allow assignment of the Workspace Owner role to a user or group` to run through the steps below.

If the meshWorkspace does not have a Workspace Owner yet, you can add yourself as a Workspace Manager and assign yourself the Workspace Owner role via the panel.

If the meshWorkspace has a single Workspace Owner set, you do not need to use a meshObjectCollection and can start at step 3.

If the meshWorkspace has two Workspace Owners set, you need to follow all three steps.

## Step 1: Create a meshObjectCollection

Follow [API docs](/api/#mesh_object_collection_create) to create a meshObjectCollection.

```sh
curl --location --request POST 'https://backend-url/api/meshobjectcollections' \
--header 'Content-Type:  application/vnd.meshcloud.api.meshobjectcollection.v1+json;charset=UTF-8' \
--header 'Authorization: Basic xyz' \
--data-raw '{
"name": "collection-my-workspace-customer-owners",
"owner": "partner@meshcloud.io",
"description": "This is a meshObjectCollection."
}'
```

## Step 2: Import existing Workspace Owners into the meshObjectCollection

Import the existing [meshWorkspaceUserBindings](/api/index.html#_meshworkspaceuserbinding) for the Workspace Owners into the meshObjectCollection.
Importing is done by specifying the [meshObjectCollection](/api/index.html#mesh_object_declarative_import) in the request URL.

```sh
curl --location --request PUT 'https://backend-url/api/meshobjects?meshObjectCollection=collection-my-workspace-customer-owners&owner=partner@meshcloud.io' \
--header 'Content-Type:  application/vnd.meshcloud.api.meshobjects.v1+yaml;charset=UTF-8' \
--header 'Accept:  application/vnd.meshcloud.api.meshobjects.v1+json' \
--header 'Authorization: Basic xyz' \
--data-raw 'apiVersion: v1
kind: meshWorkspaceUserBinding
roleRef:
  name: Workspace Owner
targetRef:
  name: my-workspace
subjects:
  - name: partner-old@meshcloud.io'
```

## Step 3: Set yourself as Workspace Owner

Set yourself as Workspace Owner.

```sh
# If you skipped steps 1 and 2, replace the first line of the command below with:
# curl --location --request PUT 'https://backend-url/api/meshobjects \
# If you went through steps 1 and 2, run the command as is:
curl --location --request PUT 'https://backend-url/api/meshobjects?meshObjectCollection=collection-my-workspace-customer-owners&owner=partner@meshcloud.io' \
--header 'Content-Type:  application/vnd.meshcloud.api.meshobjects.v1+yaml;charset=UTF-8' \
--header 'Accept:  application/vnd.meshcloud.api.meshobjects.v1+json' \
--header 'Authorization: Basic xyz' \
--data-raw 'apiVersion: v1
kind: meshWorkspaceUserBinding
roleRef:
  name: Workspace Owner
targetRef:
  name: my-workspace
subjects:
  - name: partner-new@meshcloud.io'
```


---


---
id: meshstack.customizing
title: Customizing
---

meshStack allows Partners to customise the user experience according to the needs of their organisation.

## Message of the Day

Partners can configure an optional "message of the day" to be displayed in meshPanel.
This is useful to communicate important information such as newly available cloud platforms or known issues to every user visiting meshPanel.

Note that Platform Operators can also use [platform notifications](./administration.platforms.md#platform-notifications) as an alternative to target messages only at users that consume a specific cloud platform.

<!--snippet:mesh.panel.environment.motd-->

The following configuration options are available at `mesh.panel.environment.motd`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let MessageOfTheDay =
    {-
        message:
            The "message of the day" message you want to display. This can also include html tags.
            The "message of the day" message is shown on the home screen of meshPanel for anonymous as well
            as authenticated users.

        startTime:
            The date and time after which to begin showing the message.
            Must be a JavaScript Date.parse() compatible string.

        endTime:
            The date and time after which to stop showing the message.
            Must be a JavaScript Date.parse() compatible string.
    -}
      { message : Text, startTime : Text, endTime : Text }
```
<!--Example-->
```dhall
let example
    : Optional MessageOfTheDay
    = Some
        { message =
            "The Likvid Bank Cloud Foundation Team wishes you a meshi <a href=\"https://en.wikipedia.org/wiki/Christmas\">Christmas</a>."
        , startTime = "2019-12-23 00:00"
        , endTime = "2019-12-27 00:00"
        }

let exampleNoMessage
    : Optional MessageOfTheDay
    = None MessageOfTheDay
```
<!--END_DOCUSAURUS_CODE_TABS-->

## Customizable Payment Method Validation

As every organization has its unique accounting and cost allocation processes, it is possible to alter several aspects of the payment method functionality. For payment methods that are of the type 'COST_CENTER', the configuration below provides customization for this type of payment method (configuration is stored under `panel.ui.costCenter`)

<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
{
    {- An alias for the definition 'cost center' that your organization might use. }
    alias : Text

    {- A custom RegEx pattern that validates the user's input. }
  , validationPattern : Text

    {- The error message that should be displayed when the user's input does not match the validationPattern. }
  , validationErrorMsg : Text
}
```
<!--Example-->
```dhall
{
    alias = "ACME Center"
  , validationPattern = "\\d{6}"
  , validationErrorMsg = "You entered an invalid ACME Center number, this should be exactly six digits."
}
```
<!--END_DOCUSAURUS_CODE_TABS-->

Additionally, there is the configuration for the payment methods of type 'COST_LIMITATION'. This can be found under `panel.ui.costLimitation`

<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
{
    {- Alias(es) for the list of payment method settings that are stored as key-value pairs. This is useful for
       creating more human readable text values of certain payment method settings inside the meshPanel. }
    aliases : List { mapKey : Text, mapValue : Text }
}
```
<!--Example-->
```dhall
{
    aliases =
    [ { mapKey = "costCenter", mapValue = "ACME Cost Center" }
    , { mapKey = "anotherValue", mapValue = "Some custom value" }
    ]
}
```
<!--END_DOCUSAURUS_CODE_TABS-->


## Customizable Descriptions

Depending on your meshStack implementation, it may be helpful for you to customize error descriptions to guide
end-users towards resolving common problems in self-service. meshStack therefore provides the following configuration
options in `panel.ui`.

> Note: You can use sanitized HTML in all of these settings. This is useful to create links and apply minimal formatting.

```dhall
{
    {- Generic error message displayed when meshPanel can't connect to backend services. Configure this if users need to e.g. use a certain VPN or browser with CAs pre-installed.-}
    connectivityError : Text
    {- Displayed when users are required to sign in before registering in self-service. Configure this to explain users which IDP/Credential they need to provide -}
  , idpRegister : Optional Text

    {- Displayed when users are required to sign in before accepting an invite. Configure this to explain users which IDP/Credential they need to provide -}
  , idpAcceptCustomerUserRoleRequest : Optional Text
    {- Displayed in when users provide a cost center that's already used by another meshStack workspace. Configure this e.g. to encourage users to register only one meshWorkspace per cost center. -}
  , duplicateCostCenter : Optional Text
    {- Display a configurable confidentiality label in the meshPanel navbar, e.g. "internal" or "secret". -}
  , confidentialityLevel : Optional Text
    {- Display a notification that users accept platform ToS when they create a meshProject. Configure this if you need to inform end-users about custom ToS that apply to cloud platforms available in your meshStack implementation.. -}
  , platformTermsNote : Optional Text
}
```


---


---
id: meshcloud.project
title: meshProject
---

meshProjects are multi-cloud enabled projects that allow teams to manage and scale cloud resources across all [meshPlatforms](meshcloud.platforms.md) made available to their [meshWorkspace](meshcloud.workspace.md).

> Only users with the role [Workspace Manager](meshcloud.workspace.md#assign-meshworkspace-roles) or [Workspace Owner](meshcloud.workspace.md#assign-meshworkspace-roles) have access to the administrative functionality described in this section.

## Create a new meshProject

We wrote an extensive guide on how to create a new meshProject [here](./meshstack.how-to.create-project.md).

## Manage meshProjects

In your [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace) under the **Projects** tab you will find all meshProjects of your meshWorkspace.
To manage a project, click the name of the meshProject to open the project control plane.

![Project Control Plane](assets/project/control-plane.png)

In the project control plane you can manage your tenants, payment information and the assigned users and groups of the project.

## Replication of Project Users

The following diagram shows how access rights and project [replication](./meshcloud.tenant.md) result in the correct project access for your users.

![Project User Role Replication](assets/project-user-roles.png)

Projects have a representation in each cloud platform that we call [meshTenant](./meshcloud.tenant.md). Azure Subscriptions, AWS Accounts and Cloud Foundry Spaces are all examples of Tenants. Each meshProject can have at most one Tenant in cloud platforms enabled for the project.
meshcloud uses orchestration to ensure users assigned to a meshProject always have the same role on all Tenants associated with the Project.

### Adding meshTenants

The edit screen of a project shows the list of all active [meshTenants](./meshcloud.tenant.md). Via a dropdown below this list, new meshTenants can be created by selecting the according [meshPlatform](meshcloud.platforms.md). They will be added to the project when clicking the `+` button. Depending on the configuration of the [meshPlatform](meshcloud.platforms.md), users may also have to select a [Landing Zone](meshcloud.landing-zones.md) for this platform.

When adding a [meshPlatform](meshcloud.platforms.md) to a meshProject, meshStack creates a representation of the meshProject for that meshPlatform. This representation is called a [meshTenant](meshcloud.tenant.md) and is an isolated cloud environment e.g. an AWS Account, Azure Subscription or Cloud Foundry Space.

[meshPlatforms](meshcloud.platforms.md) can also be removed from the project with some limitations. All resources in the [meshTenant](meshcloud.tenant.md) (i.e. OpenStack instances, Cloud Foundry Apps, etc.) have to be deleted manually before removing a meshPlatform. For a single meshTenant removal on a project, the same rules apply that are described in [Project Deletion](#delete-a-meshproject)

### Editing Payment and Project Settings

You can configure one or multiple [payment methods](meshcloud.payment-methods.md) for you meshWorkspace. For a meshProject you have to select a specific one, so the project resources can be billed via a specific payment method and to a specific billing address.

You also have the option of setting a substitute payment method on a project. This feature is enabled via a configuration in meshStack. A job that runs daily will check if the already assigned payment method is expired and if it is, will replace it with the substitute payment method. In that case, the substitute payment will be set to `None`.

Depending on the configuration of your meshStack implementation, you may be able to edit additional project [metadata tags](./meshcloud.metadata-tags.md) here.

## Access Control on a meshProject

Before being able to assign a user or [user groups](meshcloud.workspace.md#user-groups) to a meshProject, the user or group must have been [invited to the meshWorkspace](meshcloud.workspace.md#invite-users-to-a-meshworkspace-team). By adding a group, all users of this group will be provided access to the meshProject. In the **Project Access** section of the project edit screen all users and groups of the project are listed and new ones can be added. When adding/changing or removing a user or a group, all users and members will be informed via email about this change of access rights they have.
While adding users or groups or updating roles on a project an expiration date can be set. All expired and soon expired roles will be listed under projects/expired access.
Soon expired access (expiration date < 7 days) will be highlighted with **yellow** and expired access will be highlighted with **red**.

If [4-eye-principle](meshstack.authorization.md#user-project-role-approval) is activated in your meshStack installation, an additional approval might be necessary, before a user or group is actually assigned/remove/updated on a project.

### Assign user to a meshProject

In the **Project Access** section you can find a type-ahead `Search for a workspace user or group` field at the bottom. You search for users via their first and last name, email address and username. Groups can be found via their group name and identifier. You have to select the user or group you want to assign in the dropdown. Also select a project role. Press the `+` to add the user or group to the project. Note that only users with a valid account on the meshPanel can access your projects. You can assign multiple project roles to a user or a group on the same project.

### Project Roles

Project roles grant a configured set of permissions in cloud platforms used by the project. Project roles can be configured according to existing requirements or policies, by default the following roles are used:

- **Project Reader**: A read-only user, like a controller or similar.
- **Project User**: A default user, like a developer, who can manage resources in the cloud platform.
- **Project Admin**: An admin user, who can also change configurations of the project in the cloud platform.

### Update Project Role

You can change the Project Role, by choosing a different role in the dropdown at the **Project Access** section, and clicking the **disc** icon afterwards to save the change.

### Expiration of a user or group assignment

An expiration date can be set for an assignment to a project. When this expiration date is reached, access to the project will be revoked. An expiration date can be set directly when assigning a user or group to the project. It can also be updated any time.

Workspace Managers are informed about project role assignments that will expire soon via dashboard notifications on the my project screen and in the Account Dashboard.
Via "Projects" -> "Expired Access", the expired or soon to expire role assignments are listed and can be extended.

### Unassign user or group from a meshProject

In the **Project Access** section you can click the `-` button in the row of a user or group to remove them from the project. The users and members will not be able to access this project in meshPortal and the cloud platforms anymore. You can add the user or group to your project again later on and all related users will get access again.

## Delete a meshProject

If you would like to delete a project that is no longer used, open the corresponding project, navigate to **Deletion**. The project deletion will be finalized when the deletion of all meshTenants in the project has been performed successfully. If you want to keep the project but delete one or more individual tenants, you can also [delete a single meshTenant](meshcloud.tenant.md#delete-a-meshtenant) on the tenant control plane.

The [deletion procedure](meshcloud.tenant.md#delete-a-meshtenant) of your meshProject depends on the variety of meshTenants. There 3 possible cases:

1. a project contains exclusively tenants where we don't support automatic deletion (AWS, GCP, Azure, Kubernetes, OpenShift)
2. a project contains exclusively OpenStack, Cloud Foundry and OSB Services meshTenants
3. a project contains a project containing a combination of 1. and 2.

**1. Non-automatic deletion**: If the project contains tenants on which a partner or a platform operator will have to perform manual deletion actions. Your project is deleted, when all tenant deletions have been confirmed by the partner or platform operator.

**2. Automatic deletion**: The system will perform a check to see if any resources exist in the tenants of the project being deleted. If resources do exist in any of those platform tenants, you will be informed about them and have to manually delete those resources. Once you have performed the manual resource deletion, you can confirm the project deletion by entering the identifier of your project.

**3. Combination of the above**: If a projects contains a combination of tenants from 1. and 2. the tenants which don't require manual deletion are deleted automatically. For the other tenants the manual deletion step is necessary.

> Your meshProject is not deleted when any meshTenant requiring a manual deletion has been declined. This means, your meshProject will be available on the workspace control plane containing only the meshTenants whose deletion had been declined.


---


---
id: meshstack.building-pipeline-integration
title: Connecting meshStack and a Pipeline
---

In this section you may find information about how to:

1. Trigger a pipeline via meshStack to deploy and delete resources
2. Update users on the progress of an external automation 

## Trigger a Pipeline

Please find below the steps that are required to trigger an external automation via meshStack.

### 1. Preparation

At the moment we don't provide a native integration into any CI/CD tooling but we offer a neat way to trigger external systems via Building Blocks. In order to trigger a pipeline you may use the Terraform Building Block template below as a place to start. The module below can be used to trigger Github actions, we call this module "Trigger Module".

The strucutre of the module is as follows:

- [**main.tf**](./assets/terraform_examples/pipeline_main.tf): Calls webhooks that are used to trigger Github actions via `terraform apply` and `terraform destroy`
- [**variables.tf**](./assets/terraform_examples/pipeline_var.tf): Variables necessary for the integration with GitHub

Host your version of the module in a repository of your choice.

### 2. Creating the Building Block Definition

In order to provide an existing automation you already got covered in a pipeline triggered by meshStack you need to prepare a Building Block Definition. You have to create this Definition in one of the workspaces that have "service management" enabled. Make sure to use the Building Block Definition of type Terraform/OpenTofu and provide the information for the repository hosting your version of the "Trigger Module".

We advise to use a distinct name for the Building Block Definition that describes the outcome of the automation in the pipeline.

### 3. Publish to the Marketplace

Now you may [publish](./marketplace.service-management-area.md#publishing) the Building Block to the **marketplace**. Now a new service will appear in the marketplace that when ordered will trigger your pipeline.

## Update Status of a Building Block

With meshStack you have the ability to provide custom status to you users to update them about the progress of the pipeline execution e.g. AWS bucket was create or inform them about issues during the execution. 

> In order to do that you must have [API keys](meshstack.how-to-API-keys.md) for workspaces enabled. If this is not the case please reach out to your administrators.

### Building Block Run and Steps

In meshStack the execution of a Building Block from beginning till end is called a **run**. A run can have multiple **steps**. You have complete freedom about the granularity of information you share with your users.

We have issued API documentation [here](/api/index.html#mesh_buildingblockrun).

#### Available States for Runs and Steps

meshStack comes with some defined statuses for Building Block runs and steps that provide users insights about the current situation. You can use them as you see fit. Available statuses are:

- IN_PROGRESS: When a Building Block run has been started and is in progress
- SUCCEEDED: When a Building Block run or step has been successfully completed
- FAILED: When a Building Block run or step has failed to complete
- PENDING: When a Building Block run has been started but is waiting for an external system

When ever a run was successful but meshStack did not receive a success for one or more steps meshStack shows a warning to the operator and user.

#### Operator and User Messages

Besides a status meshStack can also show custom user message in the workspace consuming the service and operator messages to the provider of the Building Block Definition.

---


---
id: administration.meshstack-settings
title: meshStack Settings
---

To change Settings for the meshStack go to the "meshStack Settings" section of the Administration area.

## Change Logo

Partner Admins and Partner Employees can access the meshStack Settings to change the logo on the top left of the panel.

### Upload a new Logo

Click the button "Browse" to find a new logo on your system and upload this logo, which will be shown on the top-left of the panel to all users of your company.

Please make sure your image fits the following requirements:
Only images with .png extension are allowed.
Maximum dimensions allowed are 1000x500 px.
The size of the image should not be more than 250 KB.

### Reset Logo

After clicking the "Reset Logo" button, the logo will be reset to the default logo, which is usually the meshcloud logo.
This change will be visible to all users of your company.


---


---
id: meshstack.aws.index
title: Integration
---

AWS is a public cloud platform provided by Amazon Web Services.
meshStack supports account creation, configuration, access control and cost management for AWS.

## Integration Overview

To enable integration with AWS, Platform Operators configure one or multiple `meshPlatform`s of `PlatformType` AWS in the [Platform Administration](./administration.platforms.md) in meshPanel.

meshStack uses [AWS Organizations](https://aws.amazon.com/organizations/) to provision and manage AWS Accounts for [meshProjects](./meshcloud.project.md). To use AWS with a meshStack deployment, operators will need an AWS [management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html) acting as the parent of all accounts managed by meshStack. The complete meshStack setup contains three dedicated accounts:

* management account: organization management account, the account that hosts the AWS Organization. `meshfed-service-user` needs to assume a role in this account to perform tasks such as new account provisioning.`meshfed-service-user` (Replicator User)
* meshcloud account: meshStack will use this account to host the IAM users used by meshStack. `meshfed-service-user` (Replicator User) lives in this account. We have a dedicated account for this user so that meshcloud can easily roll the credentials of the user when needed.
* automation account: meshStack will use this account to manage CloudFormation that are used in [Landing Zones](./meshcloud.landing-zones.md).

```mermaid
graph LR;
    subgraph Organization Account
        meshfedServiceRole("🪖 MeshfedServiceRole");
        costExplorerServiceRole("🪖 MeshCostExplorerServiceRole");
    end
    subgraph meshcloud Account
        replicatorUser["👤 ReplicatorUser & AccessKey"];
        costExplorerUser["👤 CostExplorerUser & AccessKey"];
    end
    replicatorUser--Trusted Entity with External-id-->meshfedServiceRole;
    costExplorerUser--Trusted Entity with External-id-->costExplorerServiceRole;
    subgraph Automation Account
        meshfedAutomationRole("🪖 MeshfedAutomationRole");
    end
    replicatorUser--Trusted Entity with External-id-->meshfedAutomationRole
```

### IAM Roles and Service Control Policies

meshStack replicates meshProject roles as AWS IAM roles to AWS SSO. Platform Operators can configure the mapping of these roles via meshLandingZones.

When configuring these roles, Platform Operators must take care to correctly guard against privilege escalation and maintain project sandboxing. Operators should also consider leveraging [Service Control Policies](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_scp.html) to simplify role configuration and set up a guarded boundary for the maximum of permissions granted to any role.

## How to integrate AWS as a meshPlatform into meshStack

This is described in the Guide section under [How to integrate a meshPlatform into meshStack](meshstack.how-to.integrate-meshplatform.md).


---


---
id: meshstack.how-to.manage-partner-level-permissions
title: How to manage partner level permissions
---

If you are not familiar with what a Partner User is, please check the [official meshcloud documentation](administration.index.md).

## Pre-Requisites

- Permissions: Your user needs the Partner Admin role in the Partner Workspace to assign other users administration and/or privileged roles

## Step to Step Guide

1. Login into the meshPanel and navigate to the Administration Area. Open the Admin Area by clicking on the `ADMIN AREA` button in the top navigation and go to the Admin Access page in the Access Control section where you can onboard further privileged users
![Select Admin Area in the top navigation bar](./assets/partner/navigate-to-access-control.png "Go to the Admin Area")
2. At the end of the `Current Access` list will be a input field. Type in the first-, last-name or email address to find and select the user you want to ad and dadicated role form the list.


---


---
id: meshcloud.metadata-tags
title: Metadata Tags
---

Organizations can configure meshStack to collect, attach and distribute organization-specific metadata
to objects in the [meshModel](meshcloud.index.md). Currently, [meshWorkspaces](meshcloud.workspace.md), [meshProjects](meshcloud.project.md), [meshLandingZones](meshcloud.landing-zones.md) and [meshPaymentMethods](./meshcloud.payment-methods.md) support this metadata.

Depending on the configuration of the administrators, some of these tags will be applied directly on to the meshTenant(s) in the cloud platform.

Metadata consists of key-value pairs called **Tags**. Administrators influence the available tags by [configuring organization tags](meshstack.metadata-tags.md) in the Administration area.

These tags are displayed in the meshPanel in their respective places and they can be recognized by green bubbles that display the name and value of the tag. Take these meshWorkspaces tags as an example, which are visible in the workspace home screen:
![Example Tags](assets/metadata_tags/mesh_workspace_example_tags.png)

As you can see with the **environment** tag (with **dev**, **test** and **qa** as values), it is also possible for tags to have multiple values.

## Integration in meshPanel

meshPanel seamlessly integrates any tags that can be set by allowing users to input the tag values in self-service on the relevant screens, e.g. the project creation wizard and the project edit screen. From a users' point of view, there's no difference between properties defined in meshStack's meshModel or defined in the [tag editor](meshstack.metadata-tags.md).

## Tags restricted to Administrators

Administrators can configure tags so that only [Partner users](./administration.index.md) can edit them. These tags are called **restricted tags**. End-users cannot edit restricted tags in meshPanel, but they can view them at anytime. Partner users can view and edit restricted and unrestricted tags.

The [administration documentation](./administration.index.md) provides further details on how partner users can edit restricted tags.

## Immutable tags

Administrators can configure immutable tags. This means that we allow the selection of specific tag values only during the creation process of [meshWorkspaces](meshcloud.workspace.md), [meshProjects](meshcloud.project.md), [meshLandingZones](meshcloud.landing-zones.md) and [meshPaymentMethods](./meshcloud.payment-methods.md). Afterwards it is no longer possible to edit the selected values. Also administrators cannot change immutable tag values after creation.
For example if you create a meshProject with **environment** tag **dev** then you can't change the meshProject to **prod**. If you want a meshProject with **environment** tag **dev** then you need to create a new meshProject.

## Enforce organizational policies using tags

Beside providing valuable metadata, tags can also be used to enforce organizational [policies](meshcloud.policies.md) in your meshstack. A common use case for this is enforcing that a meshWorkspace can only create meshProjects for which it has one of the environment tag values set. If a meshWorkspace has environment `dev` and `qa`, it is possible to enforce that users only create meshProjects for these environments but not for e.g. `prod` projects (until an adminstrator gives the meshWorkspace a `prod` environment tag). The environment tag on the meshWorkspace should also be a restricted tag in this case to ensure only partners can influence this behavior.

To learn more, read the [policies](./meshcloud.policies.md) page for other use cases and explanations.


---


---
id: meshcloud.chargeback-v2
title: Chargeback 2.0 Key Changes and Limitations
---

## Overview

This documentation provides an overview of the changes introduced with **Chargeback 2.0**, detailing the reasons for the update, key improvements, required actions, and limitations. The transition to Chargeback 2.0 will take effect by **the end of January 2025 (calendar week 4)**, with the January chargeback finalized under the new system.

## Why the Change Was Needed

Historically, any late bills or corrections (e.g., from cloud providers) arriving after chargeback statements were finalized were deferred to the next period. This approach often led to confusion and inaccuracies, making it difficult to understand the true impact of these late adjustments on final charges. Chargeback 2.0 addresses this issue by integrating late adjustments directly into the finalized statements of the relevant period, ensuring a more accurate and transparent representation of usage and costs. 

## Key Improvements

- **Inclusion of Late Cost Data**

Late bills or other corrections will now be **included in the month they apply to**, even after the chargeback statement has been finalized. Previously, late charges were carried over to the next period, leading to potential confusion and delayed visibility.

**Example:**
If an Azure charge for September 2024 usage is received after the chargeback statement has been finalized on October 6, 2024, this charge will be reflected in the **September chargeback statement**. The statement will show an **"Updated"** label to indicate that changes have been applied.

- **Applying Payment Methods Retroactively**

If a project doesn’t have a payment method because the previous one expired and no new method has been set, chargeback statements will not be generated for that project. However, tenant usage reports will still be created. Once you set a new payment method, the system retroactively generates chargeback statements for all the months that were missing them, using the newly added payment method.

For example, let’s say it’s February 2025, and your payment method for 2024 expired. If you haven’t added a new one yet, no chargeback statements will be generated for January and February 2025, but tenant usage reports will still be available without an associated payment method. Now imagine you add a new payment method at the end of March 2025. In this case, the system will regenerate tenant usage reports and produce chargeback statements for January, February, and March 2025, applying the new payment method to those months.

- **Transparency in meshStack**

In the **meshStack**, updates to finalized chargeback statements will be marked. When corrections are made, you will see an **"Updated" label** in the status column of the **Chargeback Statements page**. The **Generation Date** column will show the latest update date.

**What this means for you:**

    - Changes will be highlighted directly in meshStack for quick identification.
    - You can view in meshStack all ****updates that happened from your previous data retrieval by navigating to the Chargeback page, sorting generated at the column, and choosing only **updated** status chargeback statements.
    - When viewing the updated chargeback statement, you can navigate to the section displaying **canceled chargeback statements** and **compare** them with the current version to identify specific updates.

![Overview](assets/chargeback-v2/overview.png)
![Details](assets/chargeback-v2/details.png)

- **API and CSV Export Updates**

A new version of the **meshTenantUsageReport API (v3)** will be released, providing additional fields and more detailed responses. This will help make integrations and data handling more efficient.

- **API Enhancements**: More data points, including tags, payment method IDs, tenant IDs, platform type, and more will be available. So meshTenantUsageReport will include all parameters and responses same as for meshChargebacks API and more, so please use meshTenantUsageReport instead for your automation.
- **CSV Export**: Only the latest data will be included in CSV exports without the previous one for your convenience

> Please note also that moving tenant functionality is available only for those who are on the Chargeback 2.0 version
> 

## What action do you need to take

### **Update Your Integration**

- **API Update**: If you use the **meshTenantUsageReport API**, switch to the new **v3 API** to take advantage of expanded data fields and enhanced features. Also starting from March 1, 2025 v2 will not be available for usage anymore. 
- **Late Bills via API**: To track changes made to past periods after your last financial reports use **meshTenantUsageReport API by** specifying the **period** and using the **finalizedAfter** parameter to identify any updates that occurred after your last financial reports. For example, if your chargeback finalization date is on the 6th of the month and you have done your report on 07.11.2024 by collecting data via API, then you can next time specify the period 2024-11 and finalizedAfter 07.11.2024, so that you will have all data for November that finalized after your report. So data from **meshTenantUsageReport API** can be used for further processing with both, the cost-forward method, where you apply corrections to future months, and the cost-backward method, where you apply corrections to the period in which the costs were originally incurred.

> Please note that you can switch back to Chargeback 1.0 by navigating to the **Settings** and then the **Configuration** page. However, starting **March 1, 2025**, Chargeback 2.0 will become the default version, and the option to revert to Chargeback 1.0 will no longer be available.
> 

## Limitations of Chargeback 2.0

While Chargeback 2.0 significantly improves the transparency and accuracy of chargeback statements, there are a few limitations to consider:

### Cost Backward approach in meshstack UI

As mentioned earlier, you can use the API to collect costs that changed after the finalization date and apply corrections to future periods. However, in the panel, we use the cost-backward approach, so chargebacks and TUPRs are updated for the original usage month. Late bills and other corrections are now reflected in the correct month, with their status updated, even after the chargeback statement is finalized.

For example, in the screenshot below, costs were updated on 20.11.2024 for the October chargeback. These updates were applied to the October period and not carried over to the November chargeback.

![Update overview](assets/chargeback-v2/update-overview.png)

### **Period for meshTenantUsageReport and meshChargeback APIs**

The **meshTenantUsageReport API v3** will no longer use **specific dates** (e.g. `2024-12-01Z`) within the **period
parameter** or in the response. Instead, the period will be displayed in a simplified monthly format (e.g., `2024-12`)
for your convenience.

For the **meshChargeback API**, the day of the month remains a part of the period both in the API response and in
the query parameter, which means you'll have to specify the period parameter as e.g. `2024-10-01Z`. Please note,
however, that the day always has to be specified as `01`, whereas previously, the finalization date (e.g. `2024-10-06Z`) was
specified.

### **Environmental Data Reporting**

**Environmental report data** will be attached to the chargeback statement for the next month. This is due to delays in receiving the environmental data from Google Cloud. For example, data from August will appear in the **September chargeback statement**.

### **CSV Exports**

Currently, only the latest finalized data is reflected in CSV exports without differences between the previous and current versions of chargeback statements.

### Customizable exports

For some customers, our support team has been preparing Excel files for reporting. Unfortunately, this service will no longer be available due to technical limitations. We now recommend using the **meshTenantUsageReport APIs** for providing data for reports instead.


---


---
id: meshstack.how-to.integrate-meshplatform-aws-manually
title: How to manually integrate AWS as meshPlatform
---

> The recommended way to set up AWS as a meshPlatform is via the public terraform [AWS meshPlatform Module](https://github.com/meshcloud/terraform-aws-meshplatform). The steps below are not needed if you decide to use it.

## Set up AWS Account 1: meshcloud

The meshStack AWS Connector uses a dedicated set of IAM credentials to work with AWS APIs on behalf of meshStack. To create these credentials, create a user in IAM with these specifications:

* User name: `meshfed-service-user`
* AWS access type: Programmatic access - with an access key

This user should have the following policy attached to assume the respective roles in the management account and in the automation account. Replace the MANAGEMENT_ACCOUNT_ID, AUTOMATION_ACCOUNT_ID and EXTERNAL_ID placeholders accordingly.

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "",
            "Effect": "Allow",
            "Action": "sts:AssumeRole",
            "Resource": "arn:aws:iam::<<MANAGEMENT_ACCOUNT_ID>>:role/MeshfedServiceRole",
            "Condition": {
                "StringEquals": {
                    "sts:ExternalId": "<<EXTERNAL_ID>>"
                }
            }
        },
        {
            "Sid": "",
            "Effect": "Allow",
            "Action": "sts:AssumeRole",
            "Resource": "arn:aws:iam::<<AUTOMATION_ACCOUNT_ID>>:role/MeshfedAutomationRole",
            "Condition": {
                "StringEquals": {
                    "sts:ExternalId": "<<EXTERNAL_ID>>"
                }
            }
        }
    ]
}
```

Platform Operators should generate a unique and random value for `EXTERNAL_ID`, e.g. a GUID. meshStack AWS Connector will supply this [ExternalId](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html) only when accessing organization member accounts from a privileged (system) context. Using the ExternalId therefore increases the security of member accounts in your organization.

Platform Operators need to securely inject the generated credentials and `EXTERNAL_ID` into the configuration of the AWS Connector.

### Workload Identity Federation

Instead of using explicit credentials you can also configure identity federation to allow specific identities representing meshStack access to the role assumption policy you created in the previous step.

First, setup an identity provider in the meshcloud AWS account (IAM → access management → identity providers).
Select "OpenID Connect" and enter "provider URL" (issuer) and "audience" values as they are shown by meshStack when selecting "Workload Identity Federation" for authentication during AWS platform config.

Create a role with the role assumption policy from the previous step and assign the following trust policy.
We'll call it the identity federation role:

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "<meshStack identity provider ARN>"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringEquals": {
                    "<meshStack identity provider name>:sub": "<replicator subject from meshStack>",
                    "<meshStack identity provider name>:aud": "<audience from meshStack>"
                }
            }
        }
    ]
}
```

This allows one specific identity (the replicator subject) with a specific audience to assume this role.

## Set up AWS Account 2: Management

> Security Note: The demonstrated IAM Policies implement the minimum of configuration required to produce
> a working AWS integration using meshStack AWS Connector. This setup is based on the [default AWS Organization configuration](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_accounts_access.html).
> We advise Platform Operators to determine the specific needs and requirements for their usage of AWS and implement more restrictive
> roles and policies.

This `MeshfedServiceRole` should be created in the management account with the following policy attached.

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "StsAccessMemberAccount",
            "Effect": "Allow",
            "Action": "sts:AssumeRole",
            "Resource": "arn:aws:iam::*:role/MeshstackAccountAccessRole"
        },
        {
            "Sid": "OrgManagementAccess1",
            "Effect": "Allow",
            "Action": [
                "organizations:UntagResource",
                "organizations:TagResource",
                "organizations:MoveAccount",
                "organizations:ListTagsForResource",
                "organizations:ListParents",
                "organizations:ListOrganizationalUnitsForParent",
                "organizations:DescribeOrganizationalUnit",
                "organizations:DescribeAccount",
                "organizations:CreateOrganizationalUnit"
            ],
            "Resource": [
                "arn:aws:organizations::<<MANAGEMENT_ACCOUNT_ID>>:root/o-*/r-*",
                "arn:aws:organizations::*:ou/o-*/ou-*",
                "arn:aws:organizations::*:account/o-*/*"
            ]
        },
        {
            "Sid": "OrgManagementAccess2",
            "Effect": "Allow",
            "Action": [
                "organizations:ListRoots",
                "organizations:ListAccounts",
                "organizations:DescribeCreateAccountStatus",
                "organizations:CreateAccount"
            ],
            "Resource": "*"
        },
        {
            "Sid": "OrgManagementAccessSSO",
            "Effect": "Allow",
            "Action": [
                "sso:ListAccountAssignments",
                "sso:CreateAccountAssignment",
                "sso:DescribeAccountAssignmentCreationStatus"
            ],
            "Resource": [
              "<<AWS_SSO_INSTANCE_ARN>>",
              "arn:aws:sso:::permissionSet/*/*",
              "arn:aws:sso:::account/*"
            ]
        }
    ]
}
```

In order to enable meshStack to close AWS accounts as part of [tenant deletion](./administration.delete-tenants.md), please also include the following statement. We strongly recommend you constrain the permission to close accounts to those OUs you use in your landing zones using an [ResourceOrgPath](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor-view-data-orgs.html#access_policies_access-advisor-viewing-orgs-entity-path).

```json
{
    "Action": "organizations:CloseAccount",
    "Condition": {
        "ForAnyValue:StringLike": {
            "aws:ResourceOrgPaths": [
                "o-orgid/r-rootid/ou-ouid/*"
            ]
        }
    },
    "Effect": "Allow",
    "Resource": "arn:aws:organizations::*:account/o-*/*",
    "Sid": "OrgManagementAccessCloseAccount"
},
  ```

The following trust relationship needs to be attached to the MeshfedServiceRole so that the meshfed-service-user can assume the role.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::<<MESHCLOUD_ACCOUNT_ID>>:user/meshfed-service-user"
      },
      "Action": "sts:AssumeRole",
      "Condition": {
        "StringEquals": {
          "sts:ExternalId": "<<EXTERNAL_ID>>"
        }
      }
    }
  ]
}
```

> When using workload identity federation the principal must be set to the identity federation role instead: `arn:aws:iam::<<MESHCLOUD_ACCOUNT_ID>>:role/<IDENTITY_FEDERATION_ROLE>`


Replace `MESHCLOUD_ACCOUNT_ID` with the dedicated meshcloud AWS account id where the `meshfed-service-user` lives. Replace `EXTERNAL_ID` accordingly as well.

> For Enrollment with AWS Control Tower, the `MeshfedServiceRole` needs to have extra permissions to invoke the Account Factory.
> More information on that can be found at [AWS Guide](https://docs.aws.amazon.com/servicecatalog/latest/adminguide/controlling_access.html#permissions-end-users-console).
> To make use of these permissions, there must be an available launch path defined in AWS Service Catalog, as stated also in the [prerequisites](#aws-control-tower-integration).

## Set up AWS Account 3: Automation

The automation account should contain a `MeshfedAutomationRole`.

The following policy and trust relationship should be attached to the role so that `meshfed-service-user` can assume it in order to roll out CloudFormation stack instances in the newly provisioned accounts or to invoke a Lambda that would trigger account bootstrapping.

<!--DOCUSAURUS_CODE_TABS-->
<!--Policy-->
```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AutomationPolicy",
            "Effect": "Allow",
            "Action": [
                "lambda:InvokeFunction",
                "cloudformation:UpdateStackInstances",
                "cloudformation:ListStackInstances",
                "cloudformation:DescribeStackSet",
                "cloudformation:CreateStackInstances"
            ],
            "Resource": "*"
        }
    ]
}
```
<!--Trust relationship-->
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "",
      "Effect": "Allow",
      "Principal": {
         "AWS": "arn:aws:iam::<<MESHCLOUD_ACCOUNT_ID>>:user/meshfed-service-user"
      },
      "Action": "sts:AssumeRole",
      "Condition": {
        "StringEquals": {
          "sts:ExternalId": "<<EXTERNAL_ID>>"
        }
      }
    }
  ]
}
```
<!--END_DOCUSAURUS_CODE_TABS-->

> When using workload identity federation the trusted principal must be set to the identity federation role instead: `arn:aws:iam::<<MESHCLOUD_ACCOUNT_ID>>:role/<IDENTITY_FEDERATION_ROLE>`

In order to roll out CloudFormation Stack Instances in the newly provisioned accounts, create the `AWSCloudFormationStackSetAdministrationRole` as specified in the [documentation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html) and attach the following policy and trust relationship.

<!--DOCUSAURUS_CODE_TABS-->
<!--Policy-->
```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AllowAssumeCloudFormationExecutionOnAllAccounts",
            "Effect": "Allow",
            "Action": "sts:AssumeRole",
            "Resource": "arn:aws:iam::*:role/AWSCloudFormationStackSetExecutionRole"
        }
    ]
}
```
<!--Trust relationship-->
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "",
      "Effect": "Allow",
      "Principal": {
        "Service": "cloudformation.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```
<!--END_DOCUSAURUS_CODE_TABS-->

## Set up IAM

Currently meshStack supports 2 different ways of integrating AWS IAM with meshStack, either via [AWS SSO](#aws-sso) or [meshIdB](#meshidb-deprecated) (deprecated). The AWS SSO integration is the preferred integration as it allows using your company's central IdP to log in to AWS. This simplifies integration with meshStack, gives you more control over the AuthN part and improves UX for end-users when logging in to AWS.

### Using AWS SSO (recommended)

The integration with AWS SSO basically works like this: AuthN is done via the company's IdP. Additionally users will be synced via AWS SSO Automated Provisioning (SCIM) to AWS SSO. meshStack takes care of AuthZ. That means meshStack will create groups for every project role on a meshTenant in AWS SSO. meshStack will assign the according users to these groups. As a last step, meshStack assigns the created groups to the respective AWS account with configured PermissionSets.

Details about what needs to be configured inside AWS SSO can be found [here](meshstack.aws.sso-setup.md).

> An important precondition, regarding the automated user provisioning to AWS SSO, is that the userName in AWS SSO has to be set to the [euid](meshstack.identity-federation.md#externally-provisioned-identities). This limitation is caused by AWS SSO only allowing to filter userNames to find users. If an AAD is used as the IdP, that means the userPrincipalName in the AAD must be set to the [euid](meshstack.identity-federation.md#externally-provisioned-identities), as AAD will always set the userName in AWS SSO to its userPrincipalName.

The following configuration options are available in the AWS [Platform Connection Config](administration.platforms.md#platform-connection-config):

![AWS SSO Configuration](assets/platform_maintenance/aws-sso.png)

### Using meshIdB (deprecated)

As AWS SSO is a rather new AWS feature, meshStack integrated IAM for AWS differently in the past. This AWS IAM integration should not be used
for new integrations anymore. During replication meshStack configures meshIdB as an IdP within the managed account. Additionally according IAM
roles are created during replication (dependent on configuration either my meshStack or by a CF template or a lambda function that are configured.
in the Landing Zone). meshStack also sets up a trust relationship to meshIdB in order to allow SSO for the project users.
meshStack additionally creates according roles in the meshIdB so the AuthZ information on which accounts can be accessed
by which user are then part of the SAML token AWS receives after logging in via meshIdB.

The following configuration options are available in the AWS [Platform Connection Config](administration.platforms.md#platform-connection-config):

![AWS meshIdB Configuration](assets/platform_maintenance/aws-meshidb.png)

## Decide on Naming Patterns

You can define naming patterns based on the [String Templating](meshstack.replication-configuration.md#string-templating) syntax of meshStack for the following properties:

* Account Email Address: Please make sure to consider that this is limited to 64 characters
* Account Alias Pattern: The account alias must be unique across all of AWS. Platform Operators should therefore consider using a company-specific prefix together with a combination of meshWorkspace and meshProject identifier. You can decide if you want to enforce setting the account alias on every replication via a flag in the configuration.

## Identifier Configuration

Platform Operators that want to use AWS must configure their deployment to restrict identifier lengths to meet AWS requirements. The maximum allowed lengths are:

```yaml
customer_identifier_length: 16
project_identifier_length: 30
```

## Integrate AWS Control Tower

(also refer to [AWS Management Account Setup](#aws-management-account-setup))

A `PlatformInstance` can be configured to integrate with an existing AWS Control Tower setup.
In order to manage accounts created by meshStack with AWS Control Tower, these need to be "enrolled".
AWS Control Tower utilizes an Account Factory, to provide new accounts or enroll other accounts with it.
AWS Control Tower will create an Account Factory Product in AWS Service Catalog, that will be invoked to enroll accounts.
meshStack can be enabled to trigger the Account Factory via AWS Service Catalog.
The correct Id of the Account Factory Product needs to be specified in the enrollment configuration besides the management account Id.
meshStack will create new accounts as usual and in a later step will enroll them via the Account Factory with AWS Control Tower.

The following configuration options are available in the AWS [Platform Connection Config](administration.platforms.md#platform-connection-config):

![AWS Control Tower Enrollment](assets/platform_maintenance/aws-control-tower.png)

> In order to enroll created accounts with AWS Control Tower, **a Landing Zone must be configured**. The `Target Organization Unit Id` from the Landing Zone
> configuration must belong to a OU that is already enrolled with AWS Control Tower.
> Refer to [Landing Zone Configuration](./meshstack.aws.landing-zones.md#target-organization-unit-id) for more information.

The following prerequisites must be fulfilled for the enrollment to work:

1. A configured AWS Control Tower Service
2. All [AWS prerequisites](https://docs.aws.amazon.com/controltower/latest/userguide/enroll-account.html)
3. AWS Service Catalog needs to have an AWS Control Tower Account Factory Portfolio
4. The portfolio needs to contain an AWS Control Tower Account Factory Product
5. The AWS Control Tower Account Factory Product needs to have at least one active Provisioned Artifact (active version)
6. There needs to be a launch path with permissions to invoke the AWS Account Factory Product for meshStack access
7. `MeshfedServiceRole` requires the attached policies `AWSServiceCatalogEndUserFullAccess` and `AWSServiceCatalogAdminReadOnlyAccess` and in addition some extra permissions. These are also described in the [AWS Docs](https://docs.aws.amazon.com/controltower/latest/userguide/roles-how.html). We recommend attaching another custom policy to the `MeshfedServiceRole` that contains the following permissions:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AWSControlTowerAccountFactoryAccess",
      "Effect": "Allow",
      "Action": [
        "sso:GetProfile",
        "sso:CreateProfile",
        "sso:UpdateProfile",
        "sso:AssociateProfile",
        "sso:CreateApplicationInstance",
        "sso:GetSSOStatus",
        "sso:GetTrust",
        "sso:CreateTrust",
        "sso:UpdateTrust",
        "sso:GetPeregrineStatus",
        "sso:GetApplicationInstance",
        "sso:ListDirectoryAssociations",
        "sso:ListPermissionSets",
        "sso:GetPermissionSet",
        "sso:ProvisionApplicationInstanceForAWSAccount",
        "sso:ProvisionApplicationProfileForAWSAccountInstance",
        "sso:ProvisionSAMLProvider",
        "sso:ListProfileAssociations",
        "sso-directory:ListMembersInGroup",
        "sso-directory:AddMemberToGroup",
        "sso-directory:SearchGroups",
        "sso-directory:SearchGroupsWithGroupName",
        "sso-directory:SearchUsers",
        "sso-directory:CreateUser",
        "sso-directory:DescribeGroups",
        "sso-directory:DescribeDirectory",
        "sso-directory:GetUserPoolInfo",
        "controltower:CreateManagedAccount",
        "controltower:DescribeManagedAccount",
        "controltower:DeregisterManagedAccount",
        "s3:GetObject",
        "organizations:describeOrganization",
        "sso:DescribeRegisteredRegions"
      ],
      "Resource": "*"
    }
  ]
}
```

> During the enrollment process, we create a new role in the tenant account that grants permissions to management
> account to perform AWS Control Tower execution steps. You have to make sure that there is no Service Control Policy (SCP)
> enabled in AWS Organizations that prevents that.


## Set Minimum Access Rights on Provisioned Accounts

When provisioning a new account, a default role with administration privileges will be created in the new account. This role is by default named [OrganizationAccountAccessRole](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_accounts_access.html)
but the name can be configured via meshStack. The MeshfedServiceRole will assume this newly created role in the provisioned account to perform tasks such as setting the account alias or setting up the user roles. meshStack has the capability to self downgrade this role's permissions to a minimum. This can be configured via the `self-downgrade-access-role` configuration flag.
The downgraded role will have the following final policy attached (Note that the `accountId` and `accessRole` placeholders need to be populated with the value of the current account id and the configured access role name).

```json
{
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": [
            "iam:CreateSAMLProvider",
            "iam:GetSAMLProvider",
            "iam:UpdateSAMLProvider",
            "iam:DeleteSAMLProvider",
            "iam:ListSAMLProviders"
          ],
          "Resource": [
            "arn:aws:iam::{accountId}:saml-provider/*",
            "arn:aws:cloudformation:*:{accountId}:stack/meshstack-cf-access*"
          ]
        },
        {
          "Effect": "Allow",
          "Action": [
            "iam:ListAttachedRolePolicies",
            "iam:CreateAccountAlias",
            "iam:ListAccountAliases",
            "iam:DeleteAccountAlias",
            "iam:GetRole",
            "iam:CreateRole",
            "iam:AttachRolePolicy",
            "iam:UpdateAssumeRolePolicy"
          ],
          "Resource": "*"
        },
        {
          "Effect": "Allow",
          "Action": [
            "cloudformation:DescribeStacks"
          ],
          "Resource": "*"
        },
        {
          "Effect": "Allow",
          "Action": [
            "iam:DetachRolePolicy",
            "iam:DeleteRolePolicy",
            "iam:PutRolePolicy",
            "iam:ListRolePolicies"
          ],
          "Resource": "arn:aws:iam::{accountId}:role/{accessRole}"
        }
      ]
    }
```

As you can see, meshStack has the permissions to upgrade this role if needed. This is to ensure that any new features added to the product will have the required permissions. Any newly added permissions will be notified via the product release notes.

If you prefer that meshStack does not have the capability to upgrade its own role, you can choose to implement your own role downgrade mechanism, for example via a Lambda call, which is also supported by meshLandingZones. In this case the role auto downgrade feature can be disabled.

If you would like to audit the actions taken by this role, you can enable AWS CloudTrail on all the accounts provisioned by meshStack by using an AWS CloudFormation StackSet, which is also supported by meshLandingZones. With the auditing enabled, it will always be possible to identify at which point in time meshStack added additional rights to its role. It will help to easily identify that meshStack was only able to do certain actions given the rights assigned at a certain point in time.

## Set up IAM User for metering

```mermaid
graph LR;
    subgraph Organization Account
        meshfedServiceRole["MeshfedServiceRole"];
        costExplorerServiceRole["MeshCostExplorerServiceRole"];
    end
    subgraph meshcloud Account
        replicatorUser["ReplicatorUser & AccessKey"];
        costExplorerUser["CostExplorerUser & AccessKey"];
    end
    replicatorUser--Trusted Entity with External-id-->meshfedServiceRole;
    costExplorerUser--Trusted Entity with External-id-->costExplorerServiceRole;
    subgraph Automation Account
        meshfedAutomationRole["MeshfedAutomationRole"];
    end
    replicatorUser--Trusted Entity with External-id-->meshfedAutomationRole
```

For the purpose of metering, meshStack requires a user created in the `meshcloud` AWS account (same process as [here](#set-up-aws-account-1-meshcloud)).
A role  should be created in the AWS `management account` which has the following policies attached (This role will be referred to as `MeteringRole` from now on).

1. **MeshCostExplorerServiceRole's Access Policy**: This policy allows the Metering IAM user to call the AWS Cost Explorer API to read data required for metering. Note that Savings Plan and Reserved Instance related permissions are needed only if you have specific meshWorkspaces buying those directly, and you need to implement a cash-flow based Chargeback process for those. See [Reserved Reserved Instances & Savings Plans Guide](./meshstack.aws.reserved-instance-guide.md) for more details.
2. **CostExplorerUser's Assume Role Policy**: This policy allows CostExplorerUser IAM user to assume the IAM Role `MeshCostExplorerServiceRole`

<!--DOCUSAURUS_CODE_TABS-->
<!--Organization Account MeshCostExplorerServiceRole's Access Policy-->
```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "",
            "Effect": "Allow",
            "Action": [
                "ce:GetSavingsPlansUtilizationDetails",
                "ce:GetSavingsPlansUtilization",
                "ce:GetSavingsPlansCoverage",
                "ce:GetReservationUtilization",
                "ce:GetReservationCoverage",
                "ce:GetDimensionValues",
                "ce:GetCostAndUsage",
                "organizations:ListAccounts"
            ],
            "Resource": "*"
        }
    ]
}
```

<!--Meshcloud Account CostExplorerUser's Assume Role Policy-->
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::<<ORGANIZATION_ACCOUNT_ID>>:role/MeshCostExplorerServiceRole"
      },
      "Action": "sts:AssumeRole",
      "Condition": {
        "StringEquals": {
          "sts:ExternalId": "<<EXTERNAL_ID>>"
        }
      }
    }
  ]
}
```
<!--END_DOCUSAURUS_CODE_TABS-->


## Leverage Reserved Instances & Savings Plans

This section applies only if your application teams (represented by meshWorkspaces) pay you (the Cloud Foundation team), upfront to purchase Reserved Instances
and Savings Plans directly on their AWS accounts, which give them priority for consuming the RI or SP.
If this is the case, you can enable `reservedInstanceFairChargeback` and `savingsPlanFairChargeback` feature
flags to achieve the following. See [Reserved Reserved Instances & Savings Plans Guide](./meshstack.aws.reserved-instance-guide.md) for more details.

The upfront payments will be shown as line items in the tenant usage report for the month on which the Reserved Instance or Savings Plan starts.

meshStack also adds a discount which is equal to the `amortized upfront cost` to the relevant tenant usage report.
This line item will be added to the report every month until the end of the Reserved Instances or Savings Plan period.

To achieve this, meshStack collects the information about Reserved Instances and Savings Plans via the cost explorer API.


---


---
id: meshstack.kubernetes.index
title: Integration
---

meshStack supports namespace creation, configuration, access control, quota management and billing for Kubernetes.

Our Kubernetes integration is generally distribution-independent and is purely based on "vanilla" upstream Kubernetes services. Platform Operators should be able to successfully integrate any Kubernetes distribution of their chosing as long as it has the
required APIs (described below) and configuration options available.

The following Kubernetes distributions are supported and covered on this page:

- **Native Kubernetes** with [Identity Federation](meshstack.identity-federation.md#externally-provisioned-identities) using externally provisioned identities
- **Azure Kubernetes Services** with user authentication and authorization via AKS AAD integration

> meshStack additionally offers [OpenShift integration](./meshstack.openshift.index.md). Configuring OpenShift has some important differences to other Kubernetes distributions, so we cover it in a separate guide.

## Integration Overview

To enable integration with Kubernetes, Platform Operators configure one or multiple `meshPlatform`s of `PlatformType` Kubernetes or AKS in the [Platform Administration](./administration.platforms.md) in meshPanel.

## Prerequisites

### Supported Kubernetes versions

meshStack should work with any Kubernetes version and distribution that offers the following API versions:

- `core/v1`
- `rbac.authorization.k8s.io/v1`

meshStack has been specifically validated to work with RKE (Rancher Kubernetes Engine) and [AKS](#azure-kubernetes-services).

## meshStack Configuration

Your meshStack installation needs to be configured to restrict meshProject and meshWorkspace identifiers as follows:

- alphanumeric characters only
- maximum combined length of 63 characters

You can refer to the [official Documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names).


## Kubernetes Cluster Configuration

### meshStack Service Accounts

> The recommended way to set up Kubernetes as a meshPlatform is via the public terraform [Kubernetes meshPlatform Module](https://github.com/meshcloud/terraform-kubernetes-meshplatform). The steps below are not needed if you decide to use it.

The meshStack Kubernetes Modules use dedicated Kubernetes ServiceAccounts to work with Kubernetes APIs on behalf of meshStack.
To create these credentials, create the following objects via `kubectl apply` as a Cluster Administrator.

Service principals are located in configured namespaces. In the following YAML files we use the "meshcloud" namespace for the principals.
You can also define a different namespace if you prefer.
Before applying the YAML file, the namespace has to be created first via `kubectl create namespace meshcloud`.

#### Tenant Management

The tenant management component of meshStack requires the following principal.

```yaml
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: meshfed-service
  namespace: meshcloud
  annotations:
    io.meshcloud/meshstack.replicator-kubernetes.version: "1.0"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: meshfed-service
  annotations:
    io.meshcloud/meshstack.replicator-kubernetes.version: "1.0"
rules:
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - update
- apiGroups:
  - ""
  resources:
  - resourcequotas
  - resourcequotas/status
  verbs:
  - create
  - delete
  - deletecollection
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - appliedclusterresourcequotas
  - clusterresourcequotas
  - clusterresourcequotas/status
  verbs:
  - create
  - delete
  - deletecollection
  - get
  - list
  - update
  - watch
- apiGroups:
  - ""
  - rbac.authorization.k8s.io
  resources:
  - roles
  - rolebindings
  - clusterroles
  - clusterrolebindings
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  - rbac.authorization.k8s.io
  resources:
  - rolebindings
  verbs:
  - create
  - delete
  - update
- apiGroups:
  - ""
  - rbac.authorization.k8s.io
  resources:
  - clusterroles
  verbs:
  - bind
  resourceNames:
  # ATTENTION: Replace these roles with the actual ClusterRoles you want to map for meshProject roles
  - admin
  - edit
  - view
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: meshfed-service
  annotations:
    io.meshcloud/meshstack.replicator-kubernetes.version: "1.0"
subjects:
- kind: ServiceAccount
  name: meshfed-service
  namespace: meshcloud
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: meshfed-service
```

#### Metering

```yaml
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: meshfed-metering
  namespace: meshcloud
  annotations:
    io.meshcloud/meshstack.metering-kubernetes.version: "1.0"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: meshfed-metering
  annotations:
    io.meshcloud/meshstack.metering-kubernetes.version: "1.0"
rules:
- apiGroups:
  - ""
  resources:
  - pods
  - persistentvolumeclaims
  verbs:
  - get
  - list
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: meshfed-metering
  annotations:
    io.meshcloud/meshstack.metering-kubernetes.version: "1.0"
subjects:
- kind: ServiceAccount
  name: meshfed-metering
  namespace: meshcloud
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: meshfed-metering
```

### Service Account Token

Next, retrieve the access token for the service accounts:

```bash
kubectl get serviceaccount meshfed-service -n meshcloud -o json | jq '.secrets[].name' | grep token | xargs kubectl describe secret -n meshcloud
kubectl get serviceaccount meshfed-metering -n meshcloud -o json | jq '.secrets[].name' | grep token | xargs kubectl describe secret -n meshcloud
```

Platform Operators need to securely inject these access token into the configuration of the Kubernetes modules.

### Custom meshProject Roles

> If you want to use custom roles to be mapped to your meshProject roles (and not just the pre-defined `admin`, `edit` and `view` roles) you need to make sure to also list these roles in the Cluster Role binding section for the meshfed-service principal.

It is not allowed for the service-principal to bind roles granting more rights then itself has, so the right to bind these roles must be explicitly given.

For example if you plan to use a role named `my-custom-role` please change the relevant section in the tenant management document to:

```yml
- apiGroups:
  - ""
  - rbac.authorization.k8s.io
  resources:
  - clusterroles
  verbs:
  - bind
  resourceNames:
  - admin
  - edit
  - view
  - my-custom-role
```

### Access Control Integration

Integrating access control with meshStack requires different steps depending on your Kubernetes distribution.

#### Generic Kubernetes Distributions

meshStack will identify and assign users to roles in Kubernetes based on their `euid` (external user id) as described in [Identity Federation](meshstack.identity-federation.md#externally-provisioned-identities).
In practice this means that meshStack will replicate `ClusterRoleBinding` with subjects like

```yaml
subjects:
- kind: User
  name: "$euid"
  apiGroup: rbac.authorization.k8s.io
```

You will need to configure your Kubernetes distribution to map the same attribute value configured as `euid` in meshStack as the [subject identifier](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects) in your Kubernetes Cluster.
For example, if you're using an OIDC identity provider, configure the kube-apiserver `oidc-username-claim` to use the same attribute value used for meshUser's `euid`.
For more details, please review the [Kubernetes documentation](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) or your Kubernetes distribution's specific instructions.

#### Azure Kubernetes Services

If you're using AKS, choose the platform type AKS when configuring the meshPlatform. This enables you to use Azure AD integration with your AKS cluster.

To prepare your AKS Cluster follow the official instructions [AKS-managed Azure Active Directory integration](https://docs.microsoft.com/en-us/azure/aks/managed-aad).

You need the Azure CLI version 2.0.61 or later installed and configured. Run `az --version` to find the version. If you need to install or upgrade, see Install Azure CLI.

After a successful replication, users can then fetch their `kubectl` credentials via:

```bash
az aks get-credentials --resource-group myResourceGroup --name myAKSCluster --overwrite-existing
```

This credential information and some additional configuration around the azure tenant the AKS cluster is running in have to provided in the [Platform Connection Configuration](administration.platforms.md#platform-connection-config).


---


---
id: meshstack.how-to.onboard
title: How to onboard to meshStack 
---
This guide is designed for application team members who are not yet assigned to any Workspaces and aim to independently create their first Workspace in meshStack. meshStack also has an in-product guide that includes navigation steps for users. Admins of meshStack can customize the Landing Page and experience this onboarding flow by Navigating to the Landing page tab of the Settings page.

> Please be aware that if the cloud foundation team handles the creation of Workspaces or if Workspaces have already been created through alternative means, this guide is not applicable in those scenarios.

## Pre-Requisites

- Valid credentials to log in to meshStack

## Step-by-Step Guide

### Log in to meshStack

- Access the meshStack platform using your credentials.
- If you don't have any Workspaces yet, you'll be greeted with an introduction to meshStack, where you can click on "See All Available Services" to access the Service Catalog.

![Untitled](./assets/marketplace/onboarding1.png)

### Explore Available Services

- The Service Catalog provides an overview of all **Platform Services** available within your company.
- Select a Platform Service you want to start with from the Service Catalog.
- Click on its details and then click "Continue" to proceed.
    
    ![Untitled](./assets/marketplace/onboarding2.png)
    
    ![Untitled](./assets/marketplace/onboarding3.png)
    

### Short Introduction to meshStack

- After clicking "Continue," you'll receive a brief intro to meshStack, explaining what Workspaces and Projects are.
    
    ![Untitled](./assets/marketplace/onboarding4.png)
    
    ![Untitled](./assets/marketplace/onboarding5.png)
    
### Create Workspace

yellow Please note that if you have an external service like ServiceNow or any other external solutions to create a Workspace, you'll be redirected directly there, and the next steps are not relevant to your case.

- Begin the process of creating a Workspace, by filling in all fields in the meshStack panel to create a Workspace. Amount of tags varies from organization to organization.

![Untitled](./assets/marketplace/onboarding6.png)

### Payment Method (if applicable)

- If a valid payment method for your Workspace is not available, creating a Project is prevented. Please request one from your cloud foundation team following the instructions on the screen.
    
    ![Untitled](./assets/marketplace/onboarding7.png)
    
### Create a Project

- Once the Workspace is set up, you can create a Project.
- The selected Platform Service from the beginning will be preselected, but you can add more or change the selection during Project creation.
 ![Untitled](./assets/marketplace/onboarding8.png)

---


---
id: meshstack.openshift.landing-zones
title: Landing Zones
---

By defining a Landing Zone for OpenShift certain configurations can be enforced during [replication](./meshcloud.tenant.md).

## Resource Quota

With OpenShift [ResourceQuotas](https://docs.openshift.com/container-platform/3.11/dev_guide/compute_resources.html) the number of resources inside a namespace (meshProject) can be limited.

These quotas can be defined on an OpenShift Landing Zone via the [Quota Management](./administration.landing-zones.md#defining-quotas).

## Templates

Templates can be used to deploy some resources to projects that are provisioned via meshStack. Templates will be synchronized automatically with OpenShift when they are put into a Landing Zone and meshTenants are using this Landing Zone. This template shows up in the OpenShift web console and can be applied manually by the user. Currently only one template can be uploaded and managed this way.

It is possible to automatically instantiate this template inside a project via meshStack's project replication procedure. However, doing so requires currently that the [service principal](meshstack.openshift.index.md#replicator-service-account) gets all the additional rights required to instantiate the template. Like, for example, creating Pods or Network Policies. This might be not desirable and because of this it is disabled by default. To enable automatic Template instantiation set the flag `enableTemplateInstantiation` to true in the [Platform Connection Configuration](administration.platforms.md#platform-connection-config).

It is possible to automatically instantiate this template inside a project via meshStack's project replication procedure. However doing so requires currently that the [service principal](meshstack.openshift.index.md#replicator-service-account) gets all the additional rights required to instantiate the template. Like for example creating Pods or Network Policies. This might be not desirable and because of this it is disabled by default. To enable automatic Template instantiation set the flag `enableTemplateInstantiation` to true in the [Platform Connection Configuration](administration.platforms.md#platform-connection-config).


---


---
id: meshcloud.payment-methods
title: Payment Methods
---

## Introduction

Just like you pay for a new t-shirt online via your credit card, enterprises also have to be responsible for the costs that they make in cloud platforms. Payment methods are used for allocating cloud costs, all the way back to the responsible department of your organization, for a clear and transparent accounting process. As the cloud can be mighty with its enormous offering of practically unlimited services, it is important that all meshProjects and meshWorkspaces are correctly charged and that this information makes its way back to the required systems. Payment methods therefore are the link between the cloud usage and the resulting cost in the context of a meshProject.

Payment methods are created **per** meshWorkspace and can be enhanced with [metadata tags](meshcloud.metadata-tags.md) for use cases such as cost center allocation, department information, etc. Additionally, it is possible to provide a euro amount to a payment method for budgeting purposes.

![Payment Methods Lifecycle](assets/payment_methods/payment_method_overall_lifecycle.png)

> Current limitation to how meshStack handles currencies: Although budgets can be applied in Dollar and Euro, budget alerts and payment method status only considers Euro. It is planned to expand the support for currencies besides Euro further in the future.

## The Payment Method Lifecycle: Creation

The first step in reaping the benefits of payment methods is creating them. A few important things must be considered about payment methods before creating them:

1. A payment method is **always** scoped to a single meshWorkspace. This means it is not possible to create a global payment method that can be used for all meshWorkspaces. It is also not possible to re-use a single payment method across multiple meshWorkspaces.
2. A payment method's identifier is globally unique. This means you cannot create a payment method with the same identifier for multiple meshWorkspaces. Make sure to use an identifier that will not collide in other meshWorkspaces.

> Please note that as of today payment methods only support EUR amounts. 

### Creating a Payment Method via the meshPanel

One way of creating payment methods is via the meshPanel. To do so, make sure that you have an account with the 'Partner Admin' role. Navigate to the Admin area and follow these steps:

1. Go to 'Payment Method' page under the FinOps section.
2. Click on 'Create Payment Method' at the top right.
3. Select the workspace for which a new payment method should be created.
4. Enter a name and identifier for the new payment method.
5. (This is optional) Set an amount of EUR on the payment method to indicate the budget of this payment method.
6. (This is optional) Set an expiration date for the payment method. This is especially useful when a budget expires, e.g. at the end of the accounting year.
7. Additionally, you can enter tags for the payment method, which are custom for your meshStack (also see [meshTags](meshstack.metadata-tags.md)). This is useful when you want to enhance the payment method with organizational details like the cost center number or the business unit.
8. Click 'Save' and your new payment method will be available to the meshWorkspace it was created in!

### Creating a Payment Method via the meshObject API

As automation matters, there is also the possibility to create payment methods via the meshObject API. This is especially helpful when an external system already manages the data that is relevant for payment methods. To find the API documentation, open your meshstack and click on 'API' at the bottom of the meshPanel. A new page will open and on the left-hand side, you should see `meshPaymentMethod` listed under `meshObject Import`. Click on it and read the documentation to understand how you can create a payment method via the API.

## The Payment Method Lifecycle: Assigning to meshProjects

Now that the Partner Admin has created one or more payment methods for a meshWorkspace, we are ready to link a payment method to one or more meshProjects.

First, check if the payment method is correctly created in the meshWorkspace. You can do so by navigating to the [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace). In order to do that you need to have Workspace Manager rights within the respective workspace. In the workspace control plane, open **Financials** and then **Payment Methods**. All payment methods that are created and assigned to your current meshWorkspace are shown here.

The payment methods that are assigned can be used for both existing meshProjects and new meshProjects.

### Applying a Payment Method to an existing meshProject

In the [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace), open the corresponding project. Then click on the **Financials** tab and open the **Payment Methods** tab. In this screen, you'll see the selected payment method(s). As explained at the top of the page, you also have the ability to specify a Substitute Payment Method. A Substitute Payment Method is useful when working with expiring cost centers or budgets. meshStack runs a job every night to make sure that when the Active Payment Method has expired, the Substitute Payment Method will be set as the active payment method. If there is no Substitute Payment Method, the active payment method will be removed.

![Set Payment Method in project control plane](assets/payment_methods/payment_method_selection_project_edit.png)

Select the Active Payment Method of choice, and optionally a Substitute Payment Method if that is desired. Save the meshProject and the payment method(s) will be assigned to the meshProject.

> Please note that expired payment methods are removed from all projects automatically upon expiration and can no longer be assigned to any projects.

### Applying a Payment Method to a new meshProject

Create a new meshProject at the top of the meshPanel. Follow the project creation flow until you enter the 'Billing Information' page.

![Set Payment Method in Project Create screen](assets/payment_methods/payment_method_selection_project_create.png)

As you can see, on this page you have the ability to assign a payment method to the meshProject. Keep in mind that this is mandatory. If you want to specify a substitute payment method, you can do so after creating the meshProject and following the steps above in '**Applying a payment method to an existing meshProject'**. If your meshWorkspace has no payment methods, you will be confronted with a warning that looks like this:

![Missing Payment Method warning](assets/payment_methods/payment_method_missing_in_project_create.png)

After setting a payment method, you can continue the project creation flow and save the new meshProject. You now have a new meshProject with a payment method successfully assigned!

## The Payment Method Lifecycle: Enhance with Metadata

As it is difficult to handle large amounts of payment methods only via their names or identifiers, there is the possibility to provide tags (also see [Tag Schema](meshstack.metadata-tags.md)) to the payment methods. This metadata can be provided when creating/editing the payment method in the meshPanel. This is already described in step 8 [here](#creating-a-payment-method-via-the-meshpanel).

An alternative way of providing metadata to payment methods is via the meshObject API. The API docs will describe how to inject tags in payment methods.

## The Payment Method Lifecycle: Exporting Data for External Systems

There are two possible ways to exporting the metadata of the payment methods, depending on the use case.

### Applying Metadata on Tenants in Cloud Platforms

One way of exporting the payment method data (on top of other metadata from meshWorkspaces and meshProjects) is via the meshTenant. The meshTenant in the cloud platform can be 'tagged' (or 'labeled' for Google Cloud Platform) with the metadata from meshcloud. There are multiple ways of exporting the metadata into the cloud platforms. You can read more about exporting your metadata [here](meshstack.metadata-tags.md#meshtenant-metadata) and decide what approach fits best.

### Exporting Financial Data and Metadata

The other way of exporting metadata is via our [chargeback statements](meshcloud.project-metering.md#chargeback-statements). These chargeback statements are generated periodically and contain the financial data of one or more meshTenants (based on the Tenant Usage Reports). It is possible to export these chargeback statements via CSV and on top of that, provide one or more metadata values per CSV row. This is very helpful when parsing the CSV export in another tool for financial processing.

Not all metadata is exported by default, and each metadata field has to be explicitly configured before it will be exported as part of the CSV file. It is even possible to configure the export to include standard fields of the payment method, e.g. the name or expiration date. To configure this behavior, read more [here](meshstack.billing.md#chargeback).

The actual export itself can be done via the meshPanel. This is possible for both Partner Admins (for all meshWorkspaces) and Workspace Managers (for the selected meshWorkspace). When navigating to the Administration area (for partner admins), you will see **Chargeback Statements** on the left. When navigating to the [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace) (for workspace managers) , you will see **Chargeback Statements** under **Financials**. Click on it and you will see all chargeback statements. Additionally, there is the option at the top right labelled 'CSV Export' to export the list to a single CSV file.

### External Payment Method Registration

Beside manually creating a new payment method in the meshPanel on an ad-hoc basis, it is also possible to let users navigate to an external URL for requesting
a new payment method, e.g. an internal budget request form. To make this even better, you can use the API of meshStack to create an approval flow and automate the creation
of any new payment methods.

The external URL can be figured under the configuration option `environment.ui.externalPaymentMethodUrl`.

By configuring the URL, the following button will appear in the meshPanel for meshWorkspaces:

![Request Payment Method Button](assets/payment_methods/payment_method_request_button.png)


---


---
id: meshstack.github.pipeline-automation
title: Pipeline Automation
---

With meshStack, you can publish automation workflows in other platforms directly to the marketplace, allowing application teams to easily access and initiate automation in a user-friendly, structured format in a central place. By providing triggers for automation in the marketplace, you enable teams to leverage these workflows without needing in-depth Git expertise.

Platform engineers can offer "Pipeline Building Blocks" to trigger GitHub Action Workflows directly when added to a tenant. These building blocks can be published to the marketplace, creating a seamless experience for teams to use existing automations.

## Getting Started

> Prerequisites: Your organization should be using GitHub SaaS, GitHub Enterprise, or GitHub Enterprise Server.
> Furthermore in order to integrate the GitHub Platform and execute this guide you need organization owner rights within GitHub.
> Additionally, to add individual GitHub Action workflows, you need Read and Write access for Actions and Workflows under the repository permissions.

**Note:** Follow Steps 1 and 2 only the first time you set up a GitHub Action Workflow integration. After the initial setup, you can go directly to Step 3 for additional triggers.

## Step 1: Set Up the GitHub Platform in meshStack

To set up GitHub as a platform, go to the Admin area in meshStack, select **Platforms**, and click on **Create New Platform** at the top right. Complete the required fields and select **GitHub** as the platform type.

## Step 2: Configure Pipeline Automation

Once GitHub is set up as a platform, you can configure pipeline automations to streamline the process under Settings → Configuration.

meshStack will utilize the GitHub API to [authenticate as an APP installation](https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/authenticating-as-a-github-app-installation). 

In order to do so meshStack needs to know

- the owner of the GitHub organization,
- the id of the GitHub App and
- the app’s private key to generate authentication tokens (JWT).

Those values are available to you once you [registered a GitHub app](https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/registering-a-github-app) and [installed it to a repository](https://docs.github.com/en/apps/using-github-apps/installing-your-own-github-app).\
In case you are using an enterprise version you will need to change the base URL to GitHub’s API from [https://api.github.com](https://api.github.com/) to whatever is the URL you use.

On the platform control plane you can select **Settings → Configuration** and the enter your data within the section for **Pipeline Automation.** You will find a button to test your configuration. Please note that testing the configuration is only possible at the time you upload the private key. Coming back later to the form will require you to re-upload the key to meshStack in order to test the integration again. Once you saved your configuration it can be enabled by clicking the **Turn On** button on the bottom of this page.

## Step 3: Create a Workflow Trigger

To make a GitHub Action Workflow trigger available in the marketplace, create a building block definition that references the specific workflow. Follow these steps:

1. In the Admin area, navigate to **Building Block Definitions** and click **Create New Definition** in the top right.
2. Provide the required configuration details for the trigger.
3. On the Implementation page:
    - Select the platform associated with the trigger (e.g., choose **AWS** if you are triggering an S3 bucket creation within AWS).
    - Choose **Pipeline Automation** in the **Implementation Type** dropdown.
    - Ensure you configure any necessary input fields to support the automation.

The dispatch event meshStack sends to GitHub in order to trigger the workflow will look like this:

```json
{
   "ref": "<ref>",
   "inputs": {
      "buildingBlockRun": "<encodedRun>"
   }
}
```

The value for `<ref>` is the Git reference specified in the configuration, e.g. the branch name or a commit hash.\
The value for `<encodedRun>` is a Base64 encoded version of a building block run object.\
Please consider the following example for a run:

```json
{
  "kind": "meshBuildingBlockRun",
  "apiVersion": "v1",
  "metadata": {
    "uuid": "19fe93f0-36d0-4019-9453-7f6f4ce490b4"
  },
  "spec": {
    "runNumber": 7,
    "buildingBlock": {
      "uuid": "3f7ee35a-a1d0-43d1-8ca7-dedbf9fd44b6",
      "spec": {
        "displayName": "name-of-buildingBlock",
        "workspaceIdentifier": "workspace-identifier",
        "projectIdentifier": "project-identifier",
        "fullPlatformIdentifier": "full-tenant-identifier",
        "inputs": [
          {
            "key": "input-key",
            "value": "test",
            "type": "STRING",
            "isSensitive": false,
            "isEnvironment": false
          }
        ],
        "parentBuildingBlocks": []
      }
    },
    "buildingBlockDefinition": {
      "uuid": "4334947b-f48f-4cf2-bb75-0f24b2ada6e0",
      "spec": {
        "version": 6,
        "implementation": {
          "type": "GITHUB_WORKFLOW"
        }
      }
    },
    "behavior": "APPLY"
  },
  "status": "IN_PROGRESS",
  "_links": {
    "registerSource": {
      "href": "https://federation.dev.meshcloud.io/api/meshobjects/meshbuildingblockruns/19fe93f0-36d0-4019-9453-7f6f4ce490b4/status/source"
    },
    "updateSource": {
      "href": "https://federation.dev.meshcloud.io/api/meshobjects/meshbuildingblockruns/19fe93f0-36d0-4019-9453-7f6f4ce490b4/status/source/{sourceId}"
    },
    "meshstackBaseUrl": {
      "href": "https://federation.dev.meshcloud.io"
    }
  }
}
```

The GitHub workflow needs to specify exactly one input like this:

```yaml
on:
  workflow_dispatch:
    inputs:
      buildingBlockRun:
        description: "Building Block Run Object"
        required: true
```

This setup allows application teams to quickly and efficiently access automation workflows from the marketplace, enhancing their productivity and reducing the need for Git expertise.


---


---
id: meshstack.aws.metering
title: Metering
---
meshStack imports metering data from [AWS Cost Explorer](https://aws.amazon.com/aws-cost-management/aws-cost-explorer/).
It is recommended to have a daily report update interval in order to keep the costs of calling the API low. This can be
configured via the `awsStateCollectionInterval` property.

The `amortized cost` is used when generating the tenant usage reports.

## Configuration

[Connection information](meshstack.how-to.integrate-meshplatform-aws-manually.md#set-up-iam-user-for-metering) and metering behavior can be configured via the [Platform Connection Configuration](administration.platforms.md#platform-connection-config). Besides the option of considering or excluding taxes charged on the AWS bill, the main behavior that can be steered here is the [handling of Reserved Instances and Savings Plans](meshstack.how-to.integrate-meshplatform-aws-manually.md#leverage-reserved-instances--savings-plans).

## Configuring Seller Information

If you would like to see the AWS costs attributed to a seller in the [chargeback statments](./meshcloud.project-metering.md#chargeback-statements), a product needs to be created manually in the meshcloud [Product Catalog](meshstack.billing-configuration.md#defining-a-custom-product-catalog). This product should have a `resourceType` of `sellerInfo` and should be scoped to a `platformType` of `Aws` . An example is shown below.

```json
{
    "resourceType": "sellerInfo",
    "displayName": "AWS Seller Info",
    "scope": {
        "platformType": "Aws",
        "location": null,
        "platformInstance": null,
        "localProjectId": null
    },
    "usageTypes": [],
    "description": "",
    "sellerId": "AWS",
    "sellerProductGroup": null,
    "@metadata": {
        "@collection": "Products",
        "Raven-Java-Type": "io.meshcloud.kraken.core.metering.Product"
    }
}
```


---


---
id: meshstack.aws.landing-zone-tutorial
title: "Tutorial: Landing Zone"
---

> This tutorial is work in progress!

Purpose: show you how to create secure landing zones for AWS in a simple step by step guide.

Terms:

- **Managed Account** An AWS Account managed under this landing zone.
- **CFN** shorthand for AWS CloudFormation

## Create the Organization

Setup the Organization on the root account

- select the "Root" Organizational Unit that's automatically created ("Organize Accounts" section) an enable "Service control policies"
  Policy type
- attach the following policy to the root
  - FullAWSAccess (default policy supplied by AWS)
  - meshstack-aws-root: Root Policy for meshstack-managed AWS organizations

This policy "jails" member accounts in the organization

- deny access to organizations API
- deny access to CRUD IAM IdPs
- todo: figure out how/if we can restrict modifications to the IAM OrganizationAccountAccessRole and to the user's own role

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "DenyAllOrganizationsApis",
            "Effect": "Deny",
            "Action": [
                "organizations:*"
            ],
            "Resource": [
                "*"
            ]
        },
        {
            "Sid": "DenyRestrictedIamOperations",
            "Effect": "Deny",
            "Action": [
                "iam:AddClientIDToOpenIDConnectProvider",
                "iam:CreateOpenIDConnectProvider",
                "iam:CreateSAMLProvider",
                "iam:DeleteOpenIDConnectProvider",
                "iam:DeleteSAMLProvider",
                "iam:GetOpenIDConnectProvider",
                "iam:GetSAMLProvider",
                "iam:ListOpenIDConnectProviders",
                "iam:ListSAMLProviders",
                "iam:RemoveClientIDFromOpenIDConnectProvider",
                "iam:UpdateOpenIDConnectProviderThumbprint",
                "iam:UpdateSAMLProvider"
            ],
            "Resource": [
                "*"
            ]
        }
    ]
}
```

## Automation Account

Choose an automation account in which the Stack Sets will be placed. Setup these resources inside the Automation Account. Have a look at the subsequent CloudFormation Templates for a reference.

### LZCFNStackSetAdministrationRole

```yaml
AWSTemplateFormatVersion: 2010-09-09
Description: Configure the LZCFNStackSetAdministrationRole to enable use of AWS CloudFormation StackSets. This role can be assumed by the CloudFormation Service and can in turn assume the StackSetExecutionRole in managed accounts.

Resources:
  AdministrationRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: LZCFNStackSetAdministrationRole
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudformation.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: AssumeRole-AWSCloudFormationStackSetExecutionRole
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sts:AssumeRole
                Resource:
                  - "arn:aws:iam::*:role/AWSCloudFormationStackSetExecutionRole"
```

### LZStackSet

In the administration account create a StackSet with the template you later want to apply to the newly provisioned accounts. We need a created StackSet in order to have the ID. This might only work if you apply the template to a placeholder account which you can remove again afterwards as the AWS web interface does not allow to create a StackSet without an initial account to roll this out. After the creation the StackSetInstance can be removed again.

### LZStackSetUser

> consider renaming to `LZStackSetAdmin`

```yaml
AWSTemplateFormatVersion: 2010-09-09
Description: Configure a service user for meshStack to add managed accounts to the LZ StackSet

Resources:
  LZStackSetUser:
    Type: 'AWS::IAM::User'
    Properties:
        # configure credentials etc. here ...
  LZStackSetUserPolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: LZStackSetUserPolicy
      PolicyDocument:
        Statement:
          - Sid: AllowAccessToLZStackSet
            Effect: Allow
            Action:
              - 'cloudformation:Describe*'
              - 'cloudformation:List*'
              - 'cloudformation:Get*'
            Resource: '*' # tbd this may need to be more limited, but needs access on the LZ StackSet
        - Sid: AllowToPassLZCFNStackSetAdministrationRole
          Effect: Allow
          Action:
            - iam:GetRole
            - iam:PassRole
          Resource": "arn:aws:iam::*:role/LZCFNStackSetAdministrationRole"
      Users:
        - !Ref LZStackSetUser
```

## Access Stack to boostrap Managed Accounts

Prepare a [Template](https://aws.amazon.com/cloudformation/aws-cloudformation-templates/) which will setup a **AWSCloudFormationStackSetExecutionRole**. This role must allow the adminstration account/CloudFormation to perform actions on behalf of the users. It must also allow access to all services you plan to use in your Cloud Formation Templates. A example role policy could look like this:

```yml
AWSTemplateFormatVersion: '2010-09-09'
Description: Configure the AWSCloudFormationStackSetExecutionRole to enable use of your account as a target account in AWS CloudFormation StackSets.

Resources:
ExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
    RoleName: AWSCloudFormationStackSetExecutionRole
    AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
            Principal:
            AWS:
                # Adapt this Account ID to the ID of your designated Stack Set admin account
                - arn:aws:iam::ADMIN_ACCOUNT_ID:root
            Action:
            - sts:AssumeRole
    Path: /
    Policies:
        - PolicyName: StackSetExecutionPolicy # Adapt the name if you want
        PolicyDocument:
            Version: '2012-10-17'
            Statement:
            - Effect: Allow
            Action:
            # According to the AWS Docs this is the minimal rights needed for StackSets to work. Please extend it with the specific rights needed
            # for your Stack Templates you wish to roll out.
            - cloudformation:*
            - s3:*
            - sns:*
            Resource: '*'
```

### OrganizationAccountAccessRole

```yaml
AWSTemplateFormatVersion: 2010-09-09
Description: Configure the OrganizationAccountAccessRole

Resources:
  OrganizationAccountAccessRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: OrganizationAccountAccessRole
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS:
                - arn:aws:iam::${RootAccountId}:root
            Action:
              - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AdministratorAccess
  MeshfedServiceAccessRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: OrganizationAccountAccessRole # tbd check for collisions with existing roles
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS:
                - arn:aws:iam::${RootAccountId}:meshfed-service
            Action:
              - sts:AssumeRole
      Path: /
      PolicyDocument:
        Statement:
          - Sid: IamReadOnly
            Effect: Allow
            Action:
                - iam:GetRole
                - iam:ListSAMProviders
                - iam:ListRoles
                - iam:GetSAMLProvider
            Resource: '*' # tbd this may need to be more limited, but needs access on the LZ StackSet
          - Sid: IamUpdateSAMLProvider
            Effect: Allow
            Action:
                - iam:UpdateSAMProvider
            Resource: arn:aws:iam::*:saml-provider/meshstack-saml-idp
```

### AWSCloudFormationStackSetExecutionRole

```yaml
AWSTemplateFormatVersion: 2010-09-09
Description: Configure the AWSCloudFormationStackSetExecutionRole to enable use of your account as a target account in AWS CloudFormation StackSets. For simplicity, this role receives full AdministratorAccess on the target account.

Resources:
  ExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: AWSCloudFormationStackSetExecutionRole
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS:
                - arn:aws:iam::${AutomationAccountId}:role/LZCFNStackSetAdministrationRole
            Action:
              - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AdministratorAccess
```

1. As a last step setup an AWS Landing Zone in meshStack. You need the URL of the above defined Permission Setup Template, the actual Stack Set template you wish to apply, the Account ID of the admin account which will contain the stack sets and the StackSet Admin Region (the region in which the StackSet in the Admin account is placed) as well as the StackInstance Deploy Region.

Please contact [meshcloud](https://support.meshcloud.io/hc/en-us/requests/new) for more details and reference configurations.


---


---
id: meshstack.openstack.metering
title: Metering
---

meshStack supports metering and billing for the most common types of OpenStack resources.
Metering is based on periodically sampling resource state from the platform's API.

> The accuracy of sampling-based metering naturally depends on the sampling interval. While insufficient for
> supporting a per-second billing model, it works very well for billing resources on a per-hour billing model.

## Prerequisites

- OpenStack admin user with suitable read-only permissions for all projects
- OpenStack APIs are accessible by meshStack metering collector components

## Supported Resources

Resources with the following traits are addressable in the [Product Catalog](meshstack.billing-configuration.md#defining-a-custom-product-catalog). Platform Operators or Partners can use the traits of these resources to define fine-granular product and pricing rules.

### Neutron - Floating IP
<!--snippet:mesh.kraken.productcatalog.traits.openstack.neutron.floatingIp#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let FloatingIpResourceTraits =
    {-
        This type has no traits. However you can still create products charging for the resource's existence.
    -}
      {}
```
<!--Example-->
```dhall
let example
    : FloatingIpResourceTraits
    = {=}
```
<!--END_DOCUSAURUS_CODE_TABS-->

### Neutron - Router
<!--snippet:mesh.kraken.productcatalog.traits.openstack.neutron.router#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let RouterResourceTraits =
    {-
        This type has no traits. However you can still create products charging for the resource's existence.
    -}
      {}
```
<!--Example-->
```dhall
let example
    : RouterResourceTraits
    = {=}
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Neutron - Load Balancer
<!--snippet:mesh.kraken.productcatalog.traits.openstack.neutron.loadbalancer#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let LoadBalancerResourceTraits =
    {-
      listeners:
        Number of load balancer listeners

      operatingStatus:
        Operating status of the load balancer. One of ONLINE, OFFLINE, DEGRADED, ERROR, NO_MONITOR.

      pools:
        Number of load balancer backend pools

      provider:
        The loadbalancer provider
    -}
      { listeners : Optional Integer
      , operatingStatus : Optional Text
      , pools : Optional Integer
      , provider : Optional Text
      }
```
<!--Example-->
```dhall
let example
    : LoadBalancerResourceTraits
    = { listeners = Some +1
      , operatingStatus = Some "OFFLINE"
      , pools = Some +1
      , provider = Some "octavia"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Cinder - Volume Snapshot
<!--snippet:mesh.kraken.productcatalog.traits.openstack.cinder.snapshot#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let VolumeSnapshotResourceTraits =
    {-
      availabilityZone:
        Availability zone of the volume snapshot

      replicationStatus:
        Replication status of the volume

      status:
        Status of the volume snapshot, see https://docs.openstack.org/api-ref/block-storage/v3/#volume-snapshots-snapshots

      volumeSize:
        Size of the volume snapshot in GiB
    -}
      { availabilityZone : Optional Text
      , replicationStatus : Optional Text
      , status : Text
      , volumeSize : Integer
      }
```
<!--Example-->
```dhall
let example
    : VolumeSnapshotResourceTraits
    = { availabilityZone = Some "eu-west"
      , replicationStatus = Some ""
      , status = "available"
      , volumeSize = +10
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Cinder - Volume
<!--snippet:mesh.kraken.productcatalog.traits.openstack.cinder.volume#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let VolumeResourceTraits =
    {-
      availabilityZone:
        Availability zone of the volume

      replicationStatus:
        Replication status of the volume

      size:
        Size of the volume in GiB

      status:
        Status of the volume, see https://docs.openstack.org/api-ref/block-storage/v3/#volumes-volumes

      type:
        Type of the volume
    -}
      { availabilityZone : Optional Text
      , replicationStatus : Optional Text
      , size : Integer
      , status : Text
      , type : Optional Text
      }
```
<!--Example-->
```dhall
let example
    : VolumeResourceTraits
    = { availabilityZone = Some "eu-west"
      , replicationStatus = Some ""
      , size = +10
      , status = "in-use"
      , type = Some "ssd"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Glance - Image
<!--snippet:mesh.kraken.productcatalog.traits.openstack.glance.image#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let ImageResourceTraits =
    {-
      service:
        The Glance backend service storing the image.

      size:
        The size of the image in GiB.

      status:
        Image status, see https://docs.openstack.org/glance/pike/user/statuses.html
    -}
      { service : Optional Text, size : Optional Integer, status : Text }
```
<!--Example-->
```dhall
let example
    : ImageResourceTraits
    = { service = Some "cinder", size = Some +10, status = "active" }
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Nova - Server
<!--snippet:mesh.kraken.productcatalog.traits.openstack.nova.vm#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let VirtualMachineResourceTraits =
    {-
      disk:
        Virtual machine disk size in GiB

      diskEphemeral:
        Virtual machine ephemeral disk size in GiB

      diskRoot:
        Virtual machine root disk size in GiB

      flavor:
        Name of the flavor (not id)

      ramMb:
        RAM size of the virtual machine in MiB

      state:
        Virtual machine state

      vcpu:
        Number of virtual CPUs
    -}
      { disk : Optional Integer
      , diskEphemeral : Optional Integer
      , diskRoot : Optional Integer
      , flavor : Optional Text
      , ramMb : Optional Integer
      , state : Text
      , vcpu : Optional Integer
      }
```
<!--Example-->
```dhall
let example
    : VirtualMachineResourceTraits
    = { disk = Some +20
      , diskEphemeral = Some +20
      , diskRoot = Some +20
      , flavor = Some "v4.large"
      , ramMb = Some +1024
      , state = ""
      , vcpu = Some +4
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


---


---
id: meshstack.azure.metering
title: Metering
---

meshStack imports metering data from Azure via the [Azure Cost Management API](https://docs.microsoft.com/en-us/rest/api/cost-management/). It collects data for the previous and the current month.
Azure only provides data for the previous day, so Azure Usage Reports shown in meshStack will not provide data for the current day.

## Configuring Seller Information

If you would like to see the Azure costs attributed to a seller in the [chargeback statments](./meshcloud.project-metering.md#chargeback-statements), a product needs to be created manually in the meshcloud [Product Catalog](meshstack.billing-configuration.md#defining-a-custom-product-catalog). This product should have a `resourceType` of `sellerInfo` and should be scoped to a `platformType` of `Azure`. An example is shown below.

```json
{
    "resourceType": "sellerInfo",
    "displayName": "Azure Seller Info",
    "scope": {
        "platformType": "Azure",
        "location": null,
        "platformInstance": null,
        "localProjectId": null
    },
    "usageTypes": [],
    "description": "",
    "sellerId": "Azure",
    "sellerProductGroup": null,
    "@metadata": {
        "@collection": "Products",
        "Raven-Java-Type": "io.meshcloud.kraken.core.metering.Product"
    }
}
```


---


---
id: meshstack.meshmarketplace.profile
title: meshcloud OSB API Profile
---

The OSB API Specification itself is a generic protocol and allows extension for specific implementations. OSB Services platform uses these extensions to allow service brokers to receive metadata from meshStack, control how their services are presented and made available in the marketplace as well as how they are to be billed.

The OSB API Spec allows platforms to define various extensions as part of a [Profile](https://github.com/openservicebrokerapi/servicebroker/blob/v2.14/profile.md).

## Originating Identity Header

OSB Services platform sets the [X-Broker-API-Originating-Identity](https://github.com/openservicebrokerapi/servicebroker/blob/v2.14/profile.md#originating-identity-header) header to contain a Json Web Token (JWT) with the meshStack user id as well as the [euid](./meshstack.identity-federation.md#externally-provisioned-identities).

```text
X-Broker-API-Originating-Identity: meshmarketplace eyJ1c2VyX2lkIjogInRlc3R1c2VyIiwgInVzZXJfZXVpZCI6ICJ0ZXN0VXNlckV1aWQifQ==
```

Decoding this JWT results in the following value:

```json
{
  "user_id": "testuser",
  "user_euid": "testUserEuid"
}
```

## Context Object

> Old mane of OSB Services platform is meshMarketplace, so by now you will stil see an old name "meshMarketplace" to configure this platfrom

OSB Services platform defines its own context objects for service provisioning requests. For the convenience of the service broker, the OSB Services platform delivers the following information:

```json
{
  "platform": "meshmarketplace",
  "customer_id": "testCustomer",
  "project_id": "testProject",
  "auth_url": "https://{mesh-hostname}/auth/realms/meshfed/protocol/openid-connect/auth?client_id=1d4ad6d8-dfaa-4913-9c12-fd64b42a5c8d&response_type=code&redirect_uri={redirect_uri}&nonce={nonce}&state={state}",
  "token_url": "https://{mesh-hostname}/auth/realms/meshfed/protocol/openid-connect/token",
  "permission_url": "http://{mesh-hostname}/serviceInstances/c48d065b-a123-4a1e-8021-2965928d022d/permissions"
}
```

> `auth_url`, `token_url` and `permission_url` will be `null`, unless the service broker's catalog specifies a dashboard client.

It is recommended that Service Brokers store this information as it allows Platform Operators to more easily identify links between service instances and projects when handling support requests or monitoring service operation.

## Catalog Metadata

The OSB API Spec defines free-form metadata fields in the service catalog for service instances and plans. By providing
specific metadata as outlined in the next sections, service brokers can instruct the OSB Services platform to provide specific functionality for their services such as metering or allowing service instance sharing.

The conventions used by OSB Services platform are very similar to official [OSB Profile metadata conventions](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#service-metadata) for Cloud Foundry and Kubernetes.

### Cost Information

The OSB profile also contains properties to provide [cost information](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#cost-object)
via the OSB catalog. Besides showing this information to the user of the meshMarketplace, this information is also used
by [meshStack metering](meshstack.billing.md). That means cost information provided via the OSB catalog will be used to calculate costs for used services by meshStack metering.

Please review the [meshMarketplace Metering documentation](meshstack.meshmarketplace.metering.md) for more details.

### Sensitive Services

> ⚠️ This feature is deprecated and will be removed in a future release.
> Please use [Building Blocks](./administration.building-blocks.md) with sensitive inputs instead!
> For more information, please see the [deprecation item](https://meshcloud.canny.io/deprecations/p/deprecation-of-osb-sensitive-services).

Usually the OSB Services platform shows credentials of a Service Binding to the users, who have access to it. If the Service Broker requires a more secure handling of credentials, it can provide the `sensitive` metadata for the according service in the OSB catalog.

```json
{
  "services": [{
    "id": "acb56d7c-XXXX-XXXX-XXXX-feb140a59a66",
    "name": "fake-service",
    "metadata": {
      "sensitive": true
    }
  }]
}
```

The OSB Services platform does not store any credentials provided by bindings on sensitive services. Instead, the meshMarketplace will only offer the credentials for download during the initial creation of the binding. The precondition for this to work is, that the creation of the binding is synchronous. Async bindings are not supported for sensitive services.

### Tenant-Aware Services

> ⚠️ This feature is deprecated and will be removed in a future release.
> Please use [Building Blocks](./administration.building-blocks.md) with Platform Tenant Identifiers as inputs instead!
> For more information, have a look at the [deprecation item](https://meshcloud.canny.io/deprecations/p/deprecation-of-osb-tenant-bindings)

A Service Broker can define its services to be tenant-aware by providing a `tenantAware` flag in service metadata of the service definition. Tenant-aware Services can receive special Service Bindings that provide the meshTenant context to the Service Broker using a special [Bind Resource Object](https://github.com/openservicebrokerapi/servicebroker/blob/v2.15/spec.md#bind-resource-object). When users create a tenant service binding in the OSB Services platform, they have to select a meshTenant. Only the meshTenants of the meshProject, which contains the Service Instance, can be selected.

In the service catalog it would like this:

```json
{
  "services": [{
    "id": "acb56d7c-XXXX-XXXX-XXXX-feb140a59a66",
    "name": "my-service",
    "metadata": {
      "tenantAware": true
    }
  }]
}
```

Please review the [Tenant Services documentation](./meshstack.meshmarketplace.tenant-services.md) for more details.

### Sharable Service Instances

> ⚠️ This feature is deprecated and will be removed in a future release.
> Please use [Building Blocks](./administration.building-blocks.md) for Workspaces instead!
> For more information, have a look at the [deprecation item](https://meshcloud.canny.io/deprecations/p/deprecation-of-osb-service-instance-sharing)


[Service Instance Sharing](marketplace.service-instances.md#share-service-instance) must be activated by Service Broker via `shareable` flag on metadata of the service definition.

```json
{
  "services": [{
    "id": "acb56d7c-XXXX-XXXX-XXXX-feb140a59a66",
    "name": "fake-service",
    "metadata": {
      "shareable": true
    }
  }]
}
```

### Expiring Service Bindings

> ⚠️ This feature is deprecated and will be removed in a future release.
> Please use [Building Blocks](./administration.building-blocks.md) instead!

Additionally, the OSB Services platform supports expiring service bindings which can be used to force credential rolling. Service catalogs can specify service plans with expiring bindings by settings `metadata.expiryDays` to the number of days after which a service binding for a service instance based on this plan should be deleted.
The meshStack regularly checks expiring service bindings, notifies users about upcoming expiration dates through the OSB Services dashboard and enforces their deletion once they are expired.

## Service Instance / Binding Parameters

The OSB Services platform supports JSON schema for custom parameters used for service instance creation and service binding. The support of JSON schema is part of the [OSB spec](https://github.com/openservicebrokerapi/servicebroker/blob/v2.14/spec.md#schemas-object).
Delivering JSON schema information allows the OSB Services platform UI to assist users in crafting proper parameters by rendering a user interface based on the content of the JSON schema.
meshstack uses an open-source library to achieve this result. If you want to learn more about how to render the JSON schema into a UI, including all the edge-case possibilities, you can take a look at the library's [GitHub repository](https://github.com/guillotinaweb/ngx-schema-form).
Below is an example of a JSON schema which should give you an idea of what's possible and how.

> Please be aware that the OSB Services platform UI currently only supports version [draft-04](http://json-schema.org/draft-04/schema#) of the JSON schema specification.

### Service Instance JSON Schema Example

```json
{
  "type": "object",
  "properties": {
    "securityContact": {
      "type": "string",
      "title": "Security Contact",
      "description": "Who is the security responsible person for this service instance?",
      "default": "person@example-company.com"
    },
    "serviceType": {
      "type": "string",
      "title": "Service Type",
      "description": "Describes where the services faces its endpoints",
      "oneOf": [
        { "description": "Internal", "enum": ["int"] },
        { "description": "External", "enum": ["ext"] }
      ]
    },
    "externalRegistrationNumber": {
      "type": "string",
      "title": "External Registration Number",
      "description": "The external registration number which is required for externally facing services. The number should be exactly 5 digits. If not sure what number to pick, please go to help.example.com/external-registration-number.",
      "pattern": "^[0-9]{5}$",
      "visibleIf": {
        "serviceType": ["ext"]
      }
    }
  }
}
```

### Things to keep in mind

- The order in which the JSON schema properties are shown is determined by the order of the properties within the JSON schema. Looking at the example, the ordering of UI inputs would be `securityContact`, `serviceType` and then `externalRegistrationNumber`.
- It is possible to conditionally hide certain properties, depending on the values of other properties. Given the example JSON schema, `externalRegistrationNumber` will only be visible when the `serviceType` value is equal to `ext`.
- The control that is rendered is dependent on data of the schema property itself. If you want, you can override this behavior by filling the `widget` property. Read more on widgets [here](https://github.com/guillotinaweb/ngx-schema-form#widgets).
- If the value of a certain JSON schema property is not clear from the surface, don't forget that you can use the `description` for extra contextual information such as Wiki links or contact information.
- It is possible to enforce certain patterns. This can be done by providing a Regular Expression in the `pattern` property. `externalRegistrationNumber` demonstrates this by enforcing the use of exactly five digits (0-9) as a value.


---


---
id: meshstack.meshmarketplace.broker-tutorial
title: "Tutorial: Implement a Broker"
---

This tutorial will show you how to setup a service broker deploys services using CI/CD tools you already know.

## Open Service broker

The [Open Service Broker API](https://www.openservicebrokerapi.org/) project allows independent software vendors, SaaS providers and developers to easily provide backing services to workloads running on cloud native platforms. The specification, which has been adopted by many platforms and thousands of service providers, describes a simple set of API endpoints which can be used to provision, gain access to and managing service offerings.

- The Open Service Broker is designed in a modular way and multiple services can be hosted by one service broker.
- On top of the Open Service Broker API, Service Broker provides additional features about Billing, Backup/Restore.
- Services can be provisioned synchronously and/or asynchronously and the goal of this project is to provide a framework with which any service can easily be provisioned.

## What is service broker?

Service brokers manage the lifecycle of services, and platforms interact with service brokers to provision, get access to and manage the services they offer. The Open Service Broker API defines these interactions, and therefore allows software providers to offer their services to anyone, regardless of the technology or infrastructure those software providers wish to utilise.

Each service broker built to the Open Service Broker API specification has the same intuitive set of lifecycle commands. These commands do useful things such as:

- **Fetching the catalog of backing services that a service broker offers**
The catalog describes all of the services that can be provisioned through a service broker, and  each service is made up of plans. Plans typically represent the costs and benefits for a given variant of the service. Many services use plans to ‘T-Shirt size’ the service offering (such as “small”, “medium”, and “large”).
- **Provisioning new service instances**
A service instance is a provisioned instance of a service and plan as described in the service broker’s catalog.
- **Connecting and disconnecting applications and containers from those service instances(Bind/Unbind)**
Once a service instance is provisioned, you’ll want your application or container to start communicating with that instance. From a service broker’s perspective, this is called a service binding.
- **Deprovisioning service instances**
This action simply deletes all the resources created upon the initial provisioning of the service instance.

## Quickstarts

To get started with existing projects.

- We provide an example implementation of a Service broker called [Unipipe Service Broker](https://github.com/meshcloud/unipipe-service-broker). It connects to a git repository that holds the catalog. The git repository is also used to store information about services instances and their bindings. Unipipe service broker relies on a CI/CD pipeline for managing service instances. Experimental CI/CD pipelines that integrate with Unipipe Service Broker can be found in the example section of the [Unipipe Service Broker repository](https://github.com/meshcloud/unipipe-service-broker).

- [Open Service Broker API based on Spring Boot & Groovy](https://github.com/openservicebrokerapi/servicebroker): It enables platforms such as Cloud Foundry & Kubernetes to provision and manage services.

- [osb-service-broker-example](https://github.com/evoila/osb-example):
An empty Cloud Foundry Service Broker missing concrete implementation of a distinct service.
Supports deployment to OpenStack. Uses MongoDB Database for management. Configuration files and deployment scripts must be added. Concrete Service logic and binding logic has to be added.

- [osb-starter-pack](https://github.com/pmorie/osb-starter-pack):
A go project that lets you easily deploy and iterate on a new service broker.
Uses the [`osb-broker-lib`](https://github.com/pmorie/osb-broker-lib) and
[go-open-service-broker-client](https://github.com/pmorie/go-open-service-broker-client)
projects.

## Service Broker Libraries

To help developers make there own service broker here are few libraries.

***Java***

- [Spring Cloud Open Service Broker](https://spring.io/projects/spring-cloud-open-service-broker):
Spring Cloud Open Service Broker provides a framework based on Spring Boot that
enables you to quickly create a service broker for your own managed service on
platform that support the Open Service Broker API.

- [spring-cloud-app-broker](https://github.com/spring-cloud/spring-cloud-app-broker):
Spring Cloud App Broker is a framework for building Spring Boot applications that implement the Open Service Broker API to dynamically deploy Cloud Foundry applications.

***Go***

- [brokerapi](https://github.com/pivotal-cf/brokerapi):
A Go package for building Open Service Broker API Service Brokers.

- [osb-broker-lib](https://github.com/pmorie/osb-broker-lib):
A go library that provides the REST API implementation for the OSB API. Users
implement an interface that uses the types from the
[go-open-service-broker-client](https://github.com/pmorie/go-open-service-broker-client).

- [Cloud service broker](https://github.com/pivotal/cloud-service-broker/):
This service broker uses Terraform to provision and bind services.

***.NET***

- [Open Service Broker API for .NET](https://github.com/AXOOM/OpenServiceBroker):
.NET libraries for client and server implementations of the Open Service Broker API. The client library allows you to call Service Brokers that implement the API using idiomatic C# interfaces and type-safe DTOs. The server library implements the API for you using ASP.NET Core. You simply need to provide implementations for a few interfaces, shielded from the HTTP-related details.

***Python***

- [Python package](https://pypi.org/project/openbrokerapi/): A Python package for building Service Brokers supporting API version 2.13+.

## Implementation Recommendations

This section has some implementation recommendations based on experience:

- Follow the [Open Service Broker API](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md) specification closely.
- Use consistent Ids for services and plans, do not change them after announcing them from the catalog.
- Implement proper error handling for all operations, return the correct response codes.
- Properly implement synchronous/asynchronous operations.
- Deal with orphaned Service Instances.
- “The platform OSB Services is the source of truth for service instances and bindings. Service brokers are expected to have successfully provisioned all the service instances and bindings that the OSB Service platform knows about, and none that it doesn't.”
- Consider supporting multiple service bindings per service instance, prefer to create separate credentials for each binding.
- Consider checking your service implementation using the official [checker tool (experimental)](https://github.com/openservicebrokerapi/osb-checker).

## Testing open service broker

- [API swagger documentation](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/openservicebrokerapi/servicebroker/v2.16/openapi.yaml#/): The Open Service Broker API defines an HTTP(S) interface between Platforms and Service Brokers. This would help developers to make test cases for there endpoints.

- CLI that interacts with any Open Service Broker API [eden](https://starkandwayne.com/blog/welcome-to-eden-a-cli-for-every-open-service-broker-api/). The eden CLI is useful for users of a service broker, and also for developers' own dev/test.

## Service owner responsibility

- Define and manage the catalog. Service Broker authors are expected to be cautious when removing Service Offerings and Service Plans from their catalogs, as Platforms might have provisioned Service Instances of these Service Plans. For example, Platforms might restrict the actions that users can perform on existing Service Instances if the associated Service Offering or Service Plan is deleted. Consider your deprecation strategy.

- Service broker authors should also be aware of all the possible scenarios to maintain the service broker and should provide extra endpoints to handle erroneous states of the service broker. Some example scenarios can be found [here](https://github.com/openservicebrokerapi/servicebroker) under admin actions section.

## OSBAPI Compliant Products

- The community-driven catalog shows some of publicly available service brokers that have been built using the Open Service Broker API standard. [OSB API Compliant Service Brokers](https://www.openservicebrokerapi.org/compliant-service-brokers)

## Open Service Broker Client App

- [go-open-service-broker-client](https://github.com/pmorie/go-open-service-broker-client):
This library is a golang client for communicating with service brokers,
useful for Platform developers.

- [HPE](https://github.com/reddypramod85/hpe-openservicebroker-clientapp): This project is a client platform for accessing services via the Open Service Broker API.

- [Service Broker Dashboard](https://github.com/evoila/osb-dashboard): This project is intended to be the fundamental implementation of Dashboard, which could be applied to any Service Broker.


---


---
id: meshstack.openshift.index
title: Integration
---

meshStack supports management of RedHat OpenShift platforms. OpenShift has a [Kubernetes](meshstack.kubernetes.index.md) core and provides additional services. It is available in both Open Source flavors (OKD) as well as enterprise offerings by RedHat.

meshStack supports project creation, configuration, access control, quota management and billing for OpenShift.

## Integration Overview

To enable integration with OpenShift, Platform Operators configure one or multiple `meshPlatform`s of `PlatformType` OpenShift in the [Platform Administration](./administration.platforms.md) in meshPanel.

## Prerequisites

### OpenShift Versions

meshStack currently officially supports and validates OpenShift version 4.x as either Open-Source (OKD) or OpenShift Enterprise variants. Also version 3.9+ was successfully validated in the past with meshStack and should still be working, but it is no longer officially validated by meshcloud.

In general meshStack supports all OpenShift versions that can provide the resources listed for the required [service accounts](meshstack.openshift.index.md#meshstack-service-accounts). These resources are consumed with the versions mentioned in the cluster roles of the service account or if not defined there with the following versions:

* [`/api/v1`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/)
* [`/apis/template.openshift.io/v1`](https://docs.openshift.com/container-platform/4.7/rest_api/template_apis/template-template-openshift-io-v1.html)

### IdP Configuration

meshStack will identify and assign users in OpenShift via their euid (external user id) as described in [Identity Federation](meshstack.identity-federation.md#externally-provisioned-identities).
In practice, we recommend using the same external IdP as configured for meshStack and configuring OpenShift to use the same attribute as `username`.


### meshStack Service Accounts

The meshStack OpenShift Modules use dedicated OpenShift ServiceAccounts to work with OpenShift APIs on behalf of meshStack.
To create these credentials, create the following objects via `oc create -f <file>` as a Cluster Administrator.

> After you initially created the service account once, you can use `oc replace -f <file>` to update existing definitions.

The meshStack ServiceAccounts can be located in a dedicated namespace. In the following yaml files we use the `meshcloud` namespace for the ServiceAccounts.
You can also define a different namespace if you prefer.
Before applying the yaml file, the namespace has to be created first via `oc create namespace meshcloud`.

#### Replicator Service Account

The tenant management component of meshStack requires the following ServiceAccount.

```yaml
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: meshfed-service
  namespace: meshcloud
  annotations:
    io.meshcloud/meshstack.replicator-openshift.version: "1.0"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: meshfed-service
  annotations:
    io.meshcloud/meshstack.replicator-openshift.version: "1.0"
rules:
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
  - list
  - watch
  - update
- apiGroups:
  - ""
  - user.openshift.io
  resources:
  - groups
  - identities
  - useridentitymappings
  - users
  verbs:
  - create
  - delete
  - get
  - list
  - update
  - watch
- apiGroups:
  - ""
  - project.openshift.io
  resources:
  - projectrequests
  - projects
  verbs:
  - create
  - delete
  - get
  - list
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - resourcequotas
  - resourcequotas/status
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  - template.openshift.io
  resources:
  - templates
  - templateinstances
  - templateconfigs
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  - quota.openshift.io
  resources:
  - appliedclusterresourcequotas
  - clusterresourcequotas
  - clusterresourcequotas/status
  verbs:
  - create
  - delete
  - get
  - list
  - update
  - watch
- apiGroups:
  - ""
  - rbac.authorization.k8s.io
  - authorization.openshift.io
  resources:
  - roles
  - rolebindings
  - clusterroles
  - clusterrolebindings
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  - rbac.authorization.k8s.io
  - authorization.openshift.io
  resources:
  - rolebindings
  verbs:
  - create
  - delete
  - update
- apiGroups:
  - ""
  - rbac.authorization.k8s.io
  - authorization.openshift.io
  resources:
  - clusterroles
  verbs:
  - bind
  resourceNames:
  # ATTENTION: Replace these roles with the actual ClusterRoles you want to map for meshProject roles
  - admin
  - edit
  - view
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: meshfed-service
  annotations:
    io.meshcloud/meshstack.replicator-openshift.version: "1.0"
subjects:
- kind: ServiceAccount
  name: meshfed-service
  namespace: meshcloud
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: meshfed-service
```

#### Metering Service Account

The metering component of meshStack requires the following ServiceAccount.

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: meshfed-metering
  namespace: meshcloud
  annotations:
    io.meshcloud/meshstack.metering-openshift.version: "1.0"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: meshfed-metering
  annotations:
    io.meshcloud/meshstack.metering-openshift.version: "1.0"
rules:
- apiGroups:
  - ""
  resources:
  - pods
  - persistentvolumeclaims
  verbs:
  - get
  - list
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: meshfed-metering
  annotations:
    io.meshcloud/meshstack.metering-openshift.version: "1.0"
subjects:
- kind: ServiceAccount
  name: meshfed-metering
  namespace: meshcloud
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: meshfed-metering
```

#### Retrieve the secret

In order to retrieve the secrets of the service accounts, please execute the following commands.

```bash
$ oc describe sa meshfed-service -n meshcloud
Name:                meshfed-service
Namespace:           meshcloud
Labels:              <none>
Annotations:         io.meshcloud/meshstack.replicator-openshift.version: 1.0
Image pull secrets:  meshfed-service-dockercfg-kgvnj
Mountable secrets:   meshfed-service-token-5vvls
                     meshfed-service-dockercfg-kgvnj
Tokens:              meshfed-service-token-5vvls
                     meshfed-service-token-fmnd6
                     meshfed-service-token-kbst7
                     meshfed-service-token-n45k6
Events:              <none>
```

Here you get a list of available tokens. Pick one of the tokens and use it in the following command.

```bash
$ oc describe secret meshfed-service-token-5vvls -n meshcloud
Name:         meshfed-service-token-5vvls
Namespace:    meshcloud
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: meshfed-service
              kubernetes.io/service-account.uid: bb537f6b-7a64-408b-9e47-933ac9d1aab4

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:          5940 bytes
namespace:       9 bytes
service-ca.crt:  7153 bytes
token:           eyJhbGciOiJ...
```

Use the token provided here in the meshStack OpenShift connector configuration. Do the same for the meshfed-metering service account.

### Custom meshProject Roles

Kubernetes has built-in privilege escalation prevention, which means that it is not allowed for Service Accounts to bind roles granting more rights than the Service Account itself has. Operators can override this by explicitly granting a Service Account permission to create role bindings involving a named set of `ClusterRoles`.

If you want to use custom roles to be mapped to your meshProject roles (and not just the pre-defined `admin`, `edit` and `view` roles) you need to make sure to also list these roles in the `ClusterRole` for the [Replicator Service Account](#replicator-service-account).

For example if you plan to use custom roles named `my-custom-view` and `my-custom-edit` please change the relevant section in the `ClusterRole` definition to:

```yml
# ...
- apiGroups:
  - ""
  - rbac.authorization.k8s.io
  - authorization.openshift.io
  resources:
  - clusterroles
  verbs:
  - bind
  resourceNames:
  - my-custom-view
  - my-custom-edit
# ...
```

### Tagging Configuration

Openshift supports meshStack's powerful multi-cloud [tagging system](./meshstack.metadata-tags.md#replicate-tags-to-cloud-platforms).
To enable the Openshift integration to automatically replicate tags from meshStack into the cloud platform, a label prefix must be defined in the OpenShift configuration.
It can be found in the meshPanel in the Administration Area. Go to "meshPlatforms" on the left, click on an OpenShift platform and go to "Settings" -> "Config".
The Label Prefix can be found under the "Replication Configuration" header.

> 💡 Make sure to pick a valid DNS prefix that ends with a slash, e.g. "yourcompany.com/".


---


---
id: administration.product-feedback-collection
title: Product Feedback Collection
---

> We are happy to share any of the feedback and product usage data we collect with you for your meshStack.
> Reach out to your Customer Success representative to get the data.

## In-Product Satisfaction Survey

meshStack might show your users a short survey consisting of three questions:

1. How satisfied are you with {meshStack}*
2. When I perform an action in {meshStack}, it works as expected.
3. I was able to complete the tasks I needed to using {meshStack}.

*Please note that if you have your own rebranded name for meshStack, that will be shown instead.

Below you can see an example of what the survey looks like.

![Example of Satisfaction Survey](assets/feedback-survey-example.png)

### When does the survey show up?

The satisfaction survey will show up under the following conditions:

- The user is **not** a user of the Admin Area.
- The user has logged in more than three times in the last 30 days.
- The user has not been shown the survey in the last 30 days. (If a user closes the survey it will only ever show up again after 30 days)
- The user did not do anything for the last 25 seconds (to prevent interrupting the user in important flows)

Note that the satisfaction survey is not configurable to be turned off. It is always turned on for each meshStack.

## Product Usage Data with Plausible

In order to continuously improve our product we collect product usage data and feedback.
Product usage data collection can be explicitly enabled by your Customer Success representative after your confirmation.

meshPanel uses the privacy-preserving and open source web-analytics library plausible.io for collecting anonymous usage data as described in the [plausible data policy](https://plausible.io/data-policy).
The system we use is operated by meshcloud and the data collected will remain within the secure meshcloud environment and will not be shared or processed externally.

### What data is collected?

Rest assured, the data we collect will not include any Personally Identifiable Information (PII).
Data that we collect includes the following:

- Satisfaction Ratings: To gauge user satisfaction, we will implement a star rating system. After completing an activity within the product, such as creating a meshProject, users will be prompted to provide a rating based on their experience.
- Usage Metrics: We will collect data on the frequency and manner in which functionalities are utilized within meshStack. This will help us identify patterns and understand how our product is being used, allowing us to make informed decisions for further improvement.

### Enabling Plausible data collection

<!--snippet:mesh.panel.environment#Plausible-->

The following configuration options are available at `mesh.panel.environment#Plausible`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let Plausible =
    {-
        activatePlausibleTracking:
            Enable product usage analysis and telemetry using the plausible JavaScript library.
    -}
      { activatePlausibleTracking : Bool }
```
<!--Example-->
```dhall
let example = { activatePlausibleTracking = True } : Plausible
```
<!--END_DOCUSAURUS_CODE_TABS-->

When enabled, meshPanel will send usage data to this meshStack's meshPanel domain, which means there will be
no third-party domains accessed from user's browsers.


---


---
id: meshstack.kubernetes.landing-zones
title: Landing Zones
---

The Kubernetes Landing Zone can be used to configure how Namspaces are created inside a shared Kubernetes Cluster.


## meshRole to Platform Role Mapping

The meshProject roles must be mapped to Kubernetes specific Cluster Roles. This cluster role is then assigned to the users for their namespace via a Role Binding.
You are able to control this mapping with a Landing Zone setting. Usually its a good idea to setup own Cluster Roles in Kubernetes before and then map them to their
meshStack counterpart. But you can also use predefined Kubernetes Cluster Roles like `editor` or `viewer`.

## Resource Quota

Kubernetes ResourceQuotas are used to limit the number of resources inside a namespace (which represents a meshProject). In this Landing Zone setting you can
put in your Quotas.


---


---
id: meshstack.how-to.create-your-own-platform
title: How to create your own platform
---

## Introduction

meshStack comes with quite some platform integrations out of the box, like the hyperscalers (AWS, Azure & GCP), and also some private clouds like OpenShift.
But in some cases, those integrations might not be enough and you want to have another integration to a cloud platform that is not supported out of the box.

Luckily, this is possible in meshStack! You can completely create your own platform through three different layers and give your workspace users the same
great experience of tenant creation, permission management & more.

Automated platform integrations have the following requirements:

- There is some kind of platform/tenancy organization model in the cloud platform, just like e.g. Azure has an AAD (platform) and Subscriptions (tenant).
- The above can be created & automated with Terraform.
- (optional) Users and groups can be assigned to the tenant via Terraform (this allows you to do permission management as well)

> **💡Tip**: we already built some cloud platform integrations with Terraform that we open sourced. You can find them in [meshStack Hub](https://hub.meshcloud.io)!

On a high level, you need the following and your platform integration is done:

1. Create a platform with its own name and icon.
2. Create a Building Block that does the automation in the background using Terraform
3. Create a Landing Zone that does the roll out of the Building Block.

In this guide, you will read step-by-step how you can achieve the above.

> If you want to have a real-world Terraform example at hand throughout this guide, have a look
> [here](https://github.com/meshcloud/meshstack-hub/tree/main/modules/github/repository/). 
> This module manages GitHub repositories as a tenant in meshStack.

## Step 1: Create a platform

1. Go to your meshStack Admin Area and click on "Platforms -> Platforms" on the left-hand side.
2. Click on "Create Platform".
3. For the field "Platform Type", open the dropdown and click "Create new Platform Type".
4. In this modal, enter a fitting name and identifier for your new platform type.
5. Also make sure you upload an image of your cloud platform that matches the given requirements.
6. Click on "Create" and continue the platform creation wizard.

✅ You now created a new platform with its own type. But it does not have any automation or landing zone, so it
is not usable yet. Let's continue...

## Step 2: Create a Building Block

1. Go to the meshStack Admin Area and click on "Marketplace -> Building Block Definitions" on the left-hand side.
2. Click on "Create new Definition" and fill in some general information like name and description.
3. On the next page, set the following:
   - Supported Platform: select the platform type you created in Step 1.3
   - How often assigned: Once
   - Implementation Type: Terraform
   - Terraform Version: enter what version you used to write the Terraform
   - Git Repository URL: point this to the Git repository where your Terraform is
   - Git Repository Path: if your Terraform files are under a directory in the repository, enter that path here
   - Git Commit Hash: if you want, enter a Git commit hash so that meshStack will always use the Terraform files at this commit
   - SSH Key: if the repository is private, enter an SSH Key here so meshStack can get access
   - Known Hosts: if the Git instance is a self-hosted version, make sure to enter instance's hostname here so meshStack can securely authenticate with it.
   - Deletion Mode: pick "Delete Resources" if you want meshStack to perform a `tf destroy` in the background when a user deletes a tenant for your platform.
4. Go to the next page and skip the Dependency selection.
5. For the Inputs section, make sure you add all necessary inputs that the Terraform needs to perform properly like variables but also authentication environment variables.
   This section highly depends on your Terraform so make sure you inspect it well. If you took the example from the GitHub repository mentioned above, you would enter 
   the inputs for each variable in the `variables.tf` file.
6. Go the next page, which is outputs, and create a new output which represent a uniquely identifiable property of a tenant in your platform. For the example
   of the GitHub repository, it would be the name of the repository, which you can see in the `outputs.tf` under `repo_name`.
   Set the "Assignment Type" of this output to `Platform Tenant ID`.
   - Optionally, you can also add another output that represent a direct link to the tenant in the cloud platform. This has the benefit that meshStack
     will render this link and users can click it to open the tenant directly in their browser. In the GitHub example this is represented in the `outputs.tf` under `repo_html_url`.
     To do so, create a new output that matches the Terraform output and set the "Assignment Type" to `Sign in URL`.
7. Create the new Building Block definition.

🎉 The automation is now in place! It is time for the last step: we need to roll out the automation as part of a new landing zone.

## Step 3: Create a Landing Zone

1. Go to the meshStack Admin Area and click on "Platform -> Platforms" on the left-hand side.
2. Open up the new Platform you created in Step 1.
3. Open the list of Landing Zones and click "Create new Landing Zone".
4. Enter a fitting name, description and tags (if applicable).
5. Under "Building Blocks" pick your newly created Building Block Definition and set it to "Mandatory".
6. Click "Save".

🙌 That's it! You created your own platform integration!

Workspace users will now be able to create new tenants using your new platform just like they do for any other platform in meshStack.


---


---
id: meshstack.onboarding
title: Onboarding
---

meshStack enables self-service onboarding for your internal customers. Operators can use the following options to customize the experience.

## Workspace Registration

Multiple options are available to control how [meshWorkspaces](./meshcloud.workspace.md) can sign up to meshStack in
self-service. meshStack can be configured to suit your organization's unique demands for sign up.

<!--snippet:mesh.panel.environment.mesh.registration-->

The following configuration options are available at `mesh.panel.environment.mesh.registration`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let Registration =
    {-
        requirePayment:
            Determines if the workspace registration wizard will collect a default "Cost Center" payment method.
            Disabling this will cause new meshWorkspaces to be registered without a payment method.
            This is useful if the meshStack implementation requires users to register payment methods via an external
            process (e.g. via API createLimitedPaymentMethod).

            See ui.costCenter for customizing the default cost center payment method.
    -}
      { requirePayment : Bool }
```
<!--Example-->
```dhall
let example = { requirePayment = True } : Registration
```
<!--END_DOCUSAURUS_CODE_TABS-->

### Additional Approval Flows

Additional configuration option control backend behavior in `meshfed.web.register` as follows:

```dhall

{ {- Allow sign up only if valid payment information was provided during registration  -}
, requirePayment : Optional Bool
}
```

Additional remarks and configuration links:

- `requirePayment` must be consistently configured between `panel` and `meshfed` configuration settings. The configuration model validates this.

### Default Quotas

meshStack assigns a default quota to newly registered [meshWorkspaces](./meshcloud.workspace.md) (see section above). Platform Operators can configure this default quota via `meshfed.web.customer.defaultQuota`:

```dhall
{ {- the number of allowed meshProjects per meshWorkspace -}
  meshProjects : Natural
}
```

The default only applies to newly registered [meshWorkspaces](./meshcloud.workspace.md). [meshPartners](./administration.index.md) can change the individual quotas for managed meshWorkspaces at any time using the [administration area](administration.workspaces.md#workspace-quota-management).


## Workspace User Invitations

When a user is invited to a workspace there are several configurations to customize this invitation flow which is explained below.


<!--snippet:mesh.web.user.rolerequest-->

The following configuration options are available at `mesh.web.user.rolerequest`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let UserRoleRequest =
    {-
      Configure settings related to role-requests for users. This includes
      functionality like adding new users to a meshWorkspace.

        min-approval-count:
          The minimum number of approvals needed before a requested role binding is granted and made effective.
          Using 2 or higher allows implementation of a 4-eyes principle and similar approval workflows.

        set-email-as-euid:
          When the role request is for a new meshUser, set the email address (either entered by the inviting
          person or retrieved from identity lookup) as the new meshUser's euid.

          The effect of this setting may be overridden, as IdentityLookup configuration takes precedence over
          this.

        restrict-customer-admin-role-assignment:
          When enabled, prevents self-service assignment of the Workspace Manager role via meshPanel.
          In this case, only meshObject API (or meshStack's Identity Connector) can be used for creating these role
          bindings. This is useful when an external system is the source of truth regarding
          Workspace Manager role assignments.

          Also, partner users using the "add myself" functionality in the admin area will be restricted to granting
          themselves 'Workspace Member' roles instead of 'Workspace Manager'.
    -}
      { min-approval-count : Natural
      , set-email-as-euid : Bool
      , restrict-customer-admin-role-assignment : Bool
      }
```
<!--Example-->
```dhall
let example
    : UserRoleRequest
    = { min-approval-count = 1
      , set-email-as-euid = True
      , restrict-customer-admin-role-assignment = False
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


---


---
id: administration.landing-zones
title: Landing Zones
---

## Configuring Landing Zones

Platform Operators can configure the [Landing Zones](./meshcloud.landing-zones.md) available for each meshPlatform. The capabilities supported by meshcloud differ per platform type as we support "native" tooling provided by the different cloud platforms and vendors.

This ensures enterprises can seamlessly integrate existing operational capabilities and leverage the most powerful
and best-integrated tooling available for each platform. In most instances, this tooling follows an infrastructure-as-code paradigm that fits naturally with meshcloud's multi-cloud orchestration approach.

Please consult the [Administrator documentation](./meshstack.index.md) of the respective cloud platforms for more details.

## Disabling Landing Zones

Disabled Landing Zones can't be assigned to projects anymore. If the Landing Zone has already been assigned to a project,
this assignment will remain, but workspace managers can no longer create new projects using this Landing Zone.

## Configure Landing Zone tags

Platform Operators can configure a custom Landing Zone [meshTag](./meshstack.metadata-tags.md). The schema is available during the Landing Zone creation and update. For each created Landing Zone different tags can be attached. You can tag or modify tags on a landing zone during creation and edit.

## Include Building Blocks as part of the Landing Zone

For all types of platforms it is possible to include building blocks as part of the landing zone. These building blocks can be configured to be either:

- Required: this means the building block has to be booked by the workspace user. This is useful when you want to enforce
  the usage of a particular building block in combination with the landing zone.
- Optional: this means the building block can be optionally added by the workspace user, but they are not required to
  do so and they could decide not to add it.

## Defining Quotas

> Please note that landing zone quotas are currently only available for OpenShift & Kubernetes platforms.

Limiting access to private cloud platforms is an important tool to keep control over the load on your platform and providing a fair share of resources to your workspaces. Therefore, private cloud platforms provide quotas to achieve this limitation. Defining these quotas is supported by meshStack per meshLandingZone. This provides maximum flexibility to Platform Operators to define quotas for their workspaces. meshPlatforms that support quota management will provide an according section when editing landing zones.

![Landing Zone Quota](assets/tenants/landing-zone-quota.png)

> Available quotas can be managed via the [Platform Quota Definition Screen](administration.platforms.md#manage-quota-definitions) that is available for each platform.
> Currently Quota Management is only supported for OpenShift platforms. More private cloud platforms will follow.

Quotas defined here will be applied as default quotas to newly created meshTenants. That way you can provide direct access to your workspaces with a limited scope. If users require a higher quota, they can create a [Tenant Quota Request](./meshcloud.tenant-quota.md), which has to be [approved](./administration.tenants.md#tenant-quota-requests) by a Platform Operator.


---


---
id: administration.apiusers
title: API Users
---

API Users can consume several APIs provided by meshStack. You can provide your API Users with access to certain resources for a new integration.

> Only users with the role [Partner Admin](administration.index.md) have access to the administrative functionality described in this section.

## API Key Limits

Default Quota: Can be configured in the settings in the admin area and is applied to all workspaces
Workspace Quota: Can be configured per workspace in the admin area

## Create API Users

![Create API User](assets/create-api-user.png)

1. Navigate to the **Administration** Area.
2. Click on **API Users** under **Access Control**.
3. Click on `+ Create API User` in the top right corner.
4. Fill in the form. Pick a username for API User and decide which resources you want to grant access by selecting the permissions. You can also provide a description. Keep in mind that a username cannot be changed afterwards.
5. Click on `Save`.

## Update API Users

1. Navigate to the **Administration** Area.
2. Click on **API Users** under **Access Control**.
3. Click on the pencil icon in the 'Actions' column of the API Users you want to update.
4. Update your description or the permissions, you want to grant that API User.
5. Click on `Save`.

## Delete API Users

1. Navigate to the **Administration** Area.
2. Click on **API Users** under **Access Control**.
3. Click on the trash icon in the 'Actions' column of the API Users you want to delete. A prompt will appear.
4. Confirm the deletion by entering the username in the input field of the prompt. After the deletion of your API User is finalized your list of active API Users will be updated.


---


---
id: meshstack.monitoring
title: Monitoring & Telemetry
---

Our [managed service](meshstack.managed-service.md) team
relies on monitoring & telemetry to operate meshStack installations for our customers. The integration of these systems are a mandatory pre-requisite for using our managed services.

This page documents what data we collect and for what purposes we process it. All customer data we collect and store is handled with confidentiality in accordance with our information security management system as described in our [Security FAQ](./faq.md).

## Customer data

Customer data is any data entered into meshStack via meshPanel or the API and also includes any data that meshStack retrieves from the customer's cloud platforms like cloud tenant metadata or usage reports.

## Metrics

Metrics are labelled, numerical time-series data.

- operating-system level metrics like CPU and disk usage
- application-service metrics like database, queue and load-balancer performance
- meshStack application metrics like API performance and statistics about meshObjects like meshWorkspaces, meshProjects etc.

Application-level metrics can contain labels that include customer data such as meshWorkspace and meshPlatform identifiers.

## Logs

meshStack collects various logs as described in [Logging & Auditing](./meshstack.logging.md). Logs can contain customer data and also PII like user identifiers.

Log data is therefore not part of telemetry data we collect.

## Telemetry

meshcloud transmits and processes metrics data to a central monitoring system operated by meshcloud (meshOperations center) responsible for performance monitoring and alerting.

Customers can find more details including a full list of metrics transmitted in meshStack's security documentation.

When enabled, collected [product feedback and usage data](administration.product-feedback-collection.md) is relayed from meshPanel's web server to a central plausible server instance operated by meshcloud.

## Health endpoint

meshStack configures a health endpoint which returns the current status and also the status of database connections. These information are available under path `/actuator/health`.

Example:

```json
{
    "status": "UP",
    "components": {
        "db": {
            "status": "UP",
            "details": {
                "database": "MariaDB",
                "result": 1,
                "validationQuery": "SELECT 1"
            }
        }
    }
}
```

## Version

meshStack configures a version endpoint to request the current version and commit-hash. This information is available under path `<meshPanel>/version`.

Example:

```json
{
    "package": "7.7.7",
    "git": "123456789a",
    "branch": "HEAD"
}

```


---


---
id: marketplace.service-instances
title: OSB Services
---

## Overview

A **service broker** is a component that creates an instance of a specific service and allows management of such service instances via the OSB API. An example would be a service broker for MariaDB services which allows you to request a MariaDB instance, potentially from a range of different sizes.

A **service instance** is a specific deployed service that you can include in your application, e.g. a database created by the service broker.

A **service binding** is a set of credentials you need to access your service instance, e.g. the connection string to access your database instance.

Service bindings can come with an expiration in which case they will be deleted after a set amount of days.

![OSB Marketplace integration](assets/marketplace/OSB.png)

From the Marketplace users can add OSB services to their projects (i.e. databases, message brokers, filesystems, etc). Platform operators can connect any service that implements the [Open Service Broker API](https://www.openservicebrokerapi.org/) to the OSB Services Platform and make it available to their users on the Markeplace.



## Service Plans

In order to provision a service instance for your project you first have to choose the Service Plan that best fits your needs. A service plan will be shown in the details screen of the Marketplace Catalog and it is a certain variant of the service, i.e. it has a certain amount of RAM available or storage, or network bandwidth, etc. So pick the matching plan whose resource coverages best matches your requirements.

Service Brocker may have one or more plans each. A service plan captures a variation of a service offering. Taking a MySQL service as an example, an “S” plan could offer 50GB of database storage whereas an “L” plan could offer 500GB.


## Maintain Service Instances

In order to see the status of your instances, add a binding, or remove a provisioned instance go to the **Instances** section under **OSB Services** in the navigation on the left. You find a list of all your service instances and can also access their dashboards via the dashboard icon on the right.

### Add a Binding

To finally get your connection information and credentials you have to add a binding to the service instance. You have to enter a name for the binding. When the binding has been created you can see the access information and connect to the service from within your application.

### Update Service Instance

Via the `pen` icon you can edit the service instance. Changing the name is always available. Just enter a new name if you want to change it. If the service supports an upgrade of plans, a dropdown with all plans of the service is displayed. You can select another plan if you want to change the plan for the given service instance. You can also change the parameters of the service (see [Service Parameters](#service-parameters) section below). Only enter the parameters you want to change. Empty parameters will be ignored.

### Tenant Bindings

> ⚠️ This feature is deprecated and will be removed in a future release.
> Please use [Building Blocks](./administration.building-blocks.md) with Platform Tenant Identifiers as inputs instead!
> For more information, have a look at the [deprecation item](https://meshcloud.canny.io/deprecations/p/deprecation-of-osb-tenant-bindings)

Some services require to bind a meshTenant. In that case you have to select one of your meshTenants when creating a binding.

If the service is located in the "Global" meshLocation, you can select all meshTenants of your meshProject. If the service is located in a Location-specific OSB Services, you can only select tenants of this meshLocation.

It is not possible to select the same meshTenant for multiple bindings of the same service instance.

### Share Service Instance

> ⚠️ This feature is deprecated and will be removed in a future release.
> Please use [Building Blocks](./administration.building-blocks.md) for Workspaces instead!
> For more information, have a look at the [deprecation item](https://meshcloud.canny.io/deprecations/p/deprecation-of-osb-service-instance-sharing)

If the Service Broker [supports](meshstack.meshmarketplace.profile.md#sharable-service-instances) it, service Instances can be shared between meshProjects of the same meshWorkspace. It is only sharable to projects, if the meshLocation the Service Instance relates to exists in the meshProject the instance shall be shared with. This is currently only supported for the global OSB Services.

Shared Instances are read-only. Only “own” bindings can be created/updated/deleted. This means that only bindings of the current project are shown and can be created/updated/deleted.

Sharing of a service instance can also be revoked. This can be done in the sharing as well as the shared with meshProject.


---


---
id: meshstack.index
title: Overview
---

<h3 style="margin-top: 0">Welcome to the meshStack Documentation!</h3>

meshStack is the name of our technology that powers the meshcloud solution. This document is targeted at cloud architects and SREs and introduces the components of meshStack and their interaction.

It is a modular software platform solution that connects organizational processes like project and access management with cloud technology. It provides a unified administration interface to the organization while replicating configuration into attached cloud platforms.

It is NOT a meta-layer across clouds. Users access native cloud APIs for their deployments, but meshStack helps them to ensure a proper and common configuration across cloud technologies with additional functionality such as metering, billing, surveillance and others.

![meshStack Context and Components](assets/meshstack-chart.svg)

## Central Concepts

meshStack uses the concepts of Workspaces and Projects to represent the structure of existing application teams in the meshStack platform. Application Team can manage Tenants inside Projects. 
![meshModel](assets/OrgStructure.png)

In order to reflect the organization's compliance and security standards in the cloud a Landing Zone is applied to every Tenant. Building Blocks can be leveraged either as part of a modular Landing Zone or additionally on top of a Tenant. Building Blocks are deployed based on the configuration provided in the Building Block definition. 
meshStack supports the management of multiple platforms of the same or different type. Below you can see an overview of the relations between the individual elements in meshStack as objects.
![landingZones](assets/landingZone.png)

## Integrations

Integrating a cloud platform with meshStack generally consists of these steps:

- prepare the cloud platform for integration (Service Accounts, [Identity Federation](./meshstack.identity-federation.md))
- configure & [register the platform](./administration.platforms.md) in meshStack
- provide Landing Zone implementations
- configure [Metering & Billing](./meshstack.billing.md)

Please review the detailed documentation for each cloud platform type in the sidebar for more details.

### meshModel mapping to Cloud Platform Concepts

Different Cloud technologies often introduce their own terms for similiar technological principles. In order to match them against each other and also show how this namings and technologies map to meshcloud's terminology of business entities.
These mappings can be customized. For more details, please consult documentation of the platforms.

The connections are shown in the following matrix table:

|               | [meshWorkspace](./meshcloud.workspace.md) | [meshProject](./meshcloud.project.md) | [meshUser](./meshcloud.profile.md) | [meshLandingZone](./meshcloud.landing-zones.md) |
| :-----------: | :---------------------------------------: | :-----------------------------------: | :--------------------------------: | :------------------------------------------: |
|   OpenStack   |             Domain (optional)             |                Project                |        Keystone Shadow User        |                    Quota                     |
| Cloud Foundry |               Organization                |                 Space                 |              UAA User              |                    Quota                     |
|  Kubernetes   |                     -                     |               Namespace               |            Rolebinding             |                YAML Templates                |
|   OpenShift   |                     -                     |                Project                |                User                |                YAML Templates                |
|      AWS      |                     -                     |                Account                |              IAM Role              |      Organization Units / CF StackSets       |
|     Azure     |                     -                     |             Subscription              |              AAD User              |        Management Groups / Blueprints        |
|      GCP      |                     -                     |                Project                |              GCD User              |           Folders / GDM Templates            |

## Operations

meshcloud will typically operate your meshStack installation as a [managed service](./meshstack.managed-service.md) for you. As a managed service, all configuration and validation is done by meshcloud. Nonetheless, we make references to configuration options in the documentation so that Partners get a better understanding of meshStack's capabilities. The configuration references also simplify examples and communicate the exact parameters that may need to be supplied by Partners.

### Configuration

Most of meshStack's configuration can be done in self-service via the meshPanel in the Administration area.

meshStack also supports advanced configuration options. Please see [managed service](./meshstack.managed-service.md) for more details.



---


---
id: meshstack.github.repository-provisioning
title: Repository Provisioning
---

Offering GitHub repositories in a self-service model to application teams can significantly reduce the time needed to start a new project. By integrating GitHub repositories as a service through the meshStack marketplace, you streamline the onboarding process for your teams.

## Getting Started

> Prerequisites: Your organization should be using GitHub SaaS, GitHub Enterprise, or GitHub Enterprise Server.

## Step 1: Set Up the GitHub Platform in meshStack

To enable GitHub as a platform, navigate to the admin area in meshStack, select **Platforms**, and click on **Create New Platform** at the top right. Complete the required fields, and choose **GitHub** as the platform type.

## Step 2: Configure Repository Provisioning

After creating the GitHub platform, access the platform configuration by navigating to **Settings → Configuration**. To make the repository service available in the marketplace, complete the following steps:

## 1. Create a Building Block Definition

Define a building block that provides meshStack with the necessary information to create new GitHub repositories when users initiate the process. We already have prepared a template that you can use [here](https://github.com/meshcloud/meshstack-hub/tree/main/modules/github/repository/buildingblock).

## 2. Create a Landing Zone

Configure the building block definition as a mandatory component in a new landing zone specifically for the GitHub platform.

## Step 3: Test the Marketplace Integration

Once the landing zone is created, you can test the new GitHub repository service by accessing it through a workspace in the marketplace.

Congratulations! You're one step closer to delivering a fully automated platform experience for your application teams.ss automation workflows from the marketplace, enhancing their productivity and reducing the need for Git expertise.


---


---
id: administration.emergency-users
title: "Guide: Emergency Users"
---

meshStack manages access to cloud platforms, projects and resources. In case urgent intervention is required by someone without regular access permissions there must be a defined process to securely access meshProjects and associated meshTenants. This page outlines step-by-step procedures that Platform Operators can use as the basis for their own emergency procedures. Depending on your organization's requirements, these procedures can be augmented with additional organisational or technical procedures.

Example use cases for emergency users and emergency intervention include

- An important application has stopped functioning and operating users needs access to debug and fix the problem
- Project access for a specific user must be immediately revoked (e.g. due to an account compromise)

In all cases access permissions can always be modified through the [meshPartner](administration.index.md) account which is managed by an operations team. If available, a user with workspace manager access is also sufficient for some cases.

## Emergency Access with Workspace Manager

If a user with [workspace manager](meshcloud.workspace.md) access is available, meshProject users and roles can be managed the normal way, even if the workspace manager is not assigned to the meshProject.

First, the user requiring emergency access must be invited to the meshWorkspace

- Ensure that the correct meshWorkspace is selected
- Open the **Workspace Access** tab in the [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace) and navigate to **Current Access** subtab.
- At the bottom of the screen, type in the name or e-mail of the new user and invite them with the desired role.

You can also grant workspace manager rights to the newly invited user, i.e. if the emergency user needs to modify other user permissions. In this case, the new user can perform the following steps themselves.

### Adding emergency as Workspace Manager

The user can then be assigned to meshProjects belonging to the meshWorkspace:

- In the project overview in the [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace), open the designated project by clicking on its name.
- Navigate to the **Project Access** tab and open the **Current Access** subtab.
- Add the user with the desired project role.

Since emergency access should only be temporary, it's strongly advised to assign the user a role with a [set expiration date](./meshcloud.project.md#expiry-of-a-user-assignment) which will ensure that the user is automatically removed from the meshProject after the specified date.

### Approving emergency user requests

User project role assignments can be configured to require consent from multiple workspace managers ([4 eye principle](./meshstack.authorization.md#user-project-role-approval)). To avoid situations where not enough workspace managers are available to confirm an urgent user role request, the meshPartner can confirm project role requests directly:

- Ensure that the partner is selected from the meshWorkspace drop down
- Open "Administration" from the settings menu in the top right
- Navigate to "Workspaces" and select "User Pending Role Requests" from the actions column for the meshWorkspace to which the project is assigned
- Approve the user role request

### Removing emergency user via meshWorkspace

When emergency access is no longer required the following steps will revert performed changes:

- Remove user from meshProject by opening the project again and navigating to **Project Access** > **Current Access** (performed automatically if expiration date was set)
- Remove user from meshWorkspace via the [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace): go to **Workspace Access** > **Current Access**.

## Access with meshPartner

Even when no workspace manager is available, users with partner admin/employee access can manage permissions for their managed meshWorkspaces.

### Adding emergency user as meshPartner

Note: this only works when Workspace Manager role assignment is enabled via the panel. This depends on the `restrictCustomerAdminRoleAssignment` configuration
value ([read more here](meshstack.onboarding.md#workspace-user-invitations))

In order to manage users for a specific meshProject, the partner user must add their own account to the respective meshWorkspace as a workspace manager:

- Ensure that the meshPartner is selected from the meshWorkspace dropdown
- Open "Administration" from the settings menu in the top right
- Navigate to "Workspaces" and select "Workspace User" from the actions column for the target workspace
- Activate “Add Myself” button in the top right

Afterwards they may proceed to manage users for this meshWorkspace as a workspace manager (see previous section).

### Removing emergency user as meshPartner

Since the meshPartner user is now a workspace manager the procedure is the same as outlined in the previous section.
However, to revert the temporary workspace manager role assignment, another workspace manager must remove the partner user from the workspace via **Workspace Access** > **Current Access**.

## Auditing Emergency Access

Since meshWorkspace/meshProject access permissions should not be granted lightly all changes to them are logged and can be audited by partner admin/employee users.

### Workspace History

- Ensure that the meshPartner is selected from the meshWorkspace drop down
- Open "Administration" from the settings menu in the top right
- Navigate to "Workspaces" and select "Workspace History"

The list contains all meshWorkspace events (i.e. sent invitations, added/removed users, role changes), when they occurred and who initiated the action. Event specific information (i.e. who the recipient of an invite was) is available via the “Details” button.

### Project History

- Ensure that the meshPartner is selected from the meshWorkspace drop down
- Open "Administration" from the settings menu in the top right
- Navigate to "Workspaces" and select "Workspace Projects"
- Find the project and select "Project History"

The general information per project event is the same as before. Event types include user assignments and project role changes.
Event specific information is again available via the “Details” button.


---


---
id: meshstack.meshmarketplace.tenant-services
title: Tenant Services
---

> **The Tenant Services feature is deprecated! Please do not use this anymore.**
> **We recommend the usage of [Tenant Building Blocks](administration.building-blocks.md) for additional services for your tenants.**

Tenant Services provide a convenient way for cloud foundation teams to provide "foundational" services such as virtual
networks with intranet connectivity, CI/CD platform integration and similar scenarios. Tenant services are Open Service Broker
(OSB) API compatible services that are flagged as "tenant-aware" services in the OSB Services platform. Service consumers
can then bind their [meshTenants](./meshcloud.tenant.md) against these services using a specialized service binding type. This allows service brokers to receive tenant information like an Azure Subscription Id or AWS Account number where the
consumer wants the service to be provisioned.

## Service Broker Categories

There are 2 different categories of Service Brokers that can be implemented that way. They don't differ from an API perspective, but they treat bindings differently in their implementation.

- `single-tenant-aware`: For each tenant binding a specific configuration is done inside the tenant. It could e.g. provide an "OnPrem Connect" to a public cloud tenant. This configuration must be done for every tenant that is provided via a binding.
- `multi-tenant-aware`: Bindings are a configuration to make the service aware of tenants it can work with. An example for this is a "CI/CD" Service Broker. The CI/CD pipeline should be able to work on multiple tenants of a multi-cloud application. E.g. parts of the application are deployed to Azure, others to AWS. Especially for this type of Service Brokers not only tenants of the same meshProject must be selectable, but also tenants of other meshProjects in the same meshWorkspace. E.g. the CI/CD pipeline should have access to dev, int and prod tenants, which might be located in different meshProjects. Providing those cross-project bindings can be achieved via [Service Instance Sharing](./marketplace.service-instances.md#share-service-instance).

## Creating Service Binding

When the service binding is created, OSB Services platform will provide a [Bind Resource object](https://github.com/openservicebrokerapi/servicebroker/blob/v2.15/spec.md#bind-resource-object) with properties `tenant_id` and `platform` in the `bind_resource` object of the bind request:

```json
{
  "service_id": "my-service-id",
  "plan_id": "my-plan-id",
  "bind_resource": {
    "tenant_id": "my_tenant_id_1",
    "platform": "platform-identifier-1"
  }
}
```

- `tenant_id` is the tenant id in the platform, e.g. AWS Account ID or Azure Subscription Id.
- `platform` is the full identifier of the platform as it is configured in meshStack. It is custom per environment. The Service Broker team can request the list of available platforms and their identifier from meshcloud.

As a response the Service Broker will provide a credential binding. Depending on the service it might not be real credentials, but just a link to e.g. the CI/CD Web Interface. Or in case of the "OnPrem Connect" perhaps some metadata information for the user is provided. An empty object would also be a valid response. This credential information is only displayed to the user, so it should only contain information the user can understand.

## Configuration in the OSB Services platform

Services can be platform-specific. A specific AWS OnPrem Connect SB is an example for this. It should only be possible to bind AWS tenants to this service. This can be achieved by [publishing](meshstack.meshmarketplace.development.md#publish-your-service-broker) this Service Broker only to OSB Services platform of AWS meshLocations. This will allow the user to only select tenants related to this meshLocation.

Multi-tenant-aware service brokers that support different platform types, should only be [published](meshstack.meshmarketplace.development.md#publish-your-service-broker) to the global location. This allows the user to select any tenant in the meshProject, independent of the meshLocation.

## Converting non-tenant-aware services to tenant-aware services

> If you are actually interested in doing a proper tenant binding workflow, read our documentation above.
> This section only describes a workaround for services that already know for which cloud tenant(s) they need to connect.

For some service brokers it might be the case that you have built some kind of automation that can understand which
meshTenant belongs to which service, but they do not use meshStack's concept of tenant-aware services.

For these kind of cases we have a workaround that allows these services to become tenant-aware anyway:

1. Flag the service in the service catalog as `tenantAware: true`. You can see an example of that [here](./meshstack.meshmarketplace.profile.md#tenant-aware-services). If you
   use our [unipipe-service-broker](https://github.com/meshcloud/unipipe-service-broker), you can do this in the [catalog.yml](https://github.com/meshcloud/unipipe-service-broker/wiki/Reference#catalogyml).
2. When a service is now tenant-aware, the OSB Services platform expects an endpoint for creating so-called tenant bindings.
   You must implement this endpoint, because otherwise the service binding will show up as 'Failed' in meshStack.
   The endpoint does not actually have to do something, but it needs to exist and return an HTTP 200 with at least an
   empty JSON object `{}`. Read the [OSB Spec](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md#request-creating-a-service-binding)
   on what exact URL the endpoint needs to be & some more information if you are interested.



---


---
id: meshstack.azure.index
title: Integration
---

meshStack can automatically provision Azure Subscriptions or Resource Groups as Tenants for [meshProjects](./meshcloud.project.md) and configure them according to your organiziations policies
using [Landing Zones](./meshcloud.landing-zones.md).

## Integration Overview

To enable integration with Azure, operators configure one or multiple `meshPlatform`s of `PlatformType` Azure in the [Platform Administration](./administration.platforms.md) in meshPanel.

Azure relies on Azure Active Directoy (AAD) for authentication and authorization. meshcloud can seamlessly integrate with common
setups like [Azure Hybrid Identity](https://docs.microsoft.com/en-us/azure/active-directory/hybrid/). meshcloud helps you implement Azure in line with [Governance best-practices](https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/govern/governance-disciplines) by integrating [Blueprints](https://docs.microsoft.com/en-us/azure/governance/blueprints/overview) and Management Groups using [Landing Zones](#landing-zones)

In order to plan and execute a successful integration of Azure using meshcloud, organizations need to consider the following parts described in the sections below.

## Azure Active Directory Integration

All subscriptions in Azure must be associated with exactly one AAD Tenant storing role and permission assignments. Azure uses this AAD Tenant to evaluate permissions on all resources contained in that subscription. meshcloud manages roles and assignments
by automatically replicating [meshProject Role Assignments](./meshcloud.project.md) to this AAD Tenant.

However, a key decision in any Azure integration is how your organization wants to provision user identities in this AAD Tenant. For best practices on setting up your AAD, check out our [Cloud Foundation](https://cloudfoundation.meshcloud.io/maturity-model/iam/federated-identity-and-authentication.html#azure-active-directory) website for typical implementations.

> **Recommendation**: Because meshcloud requires read-write permissions to your Azure Active Directory to manage user roles on Azure Subscriptions, we recommend creating a separate **"Workload AAD Tenant"** to be exclusively used by meshcloud. Our orchestration engine then creates Guest Users in the meshcloud AAD Tenant that reference user identities from the "home tenant" (AAD B2B). This way, users have a single cloud identity managed by your organization-wide policies while isolating "workload" related Azure activies into its own AAD Tenant which has no way of affecting other applications using the home tenant like Office 365 etc.

### Considerations

#### Managed Users

All users who need access to the Azure Portal should be synced in the AAD managed by meshcloud.

> meshcloud will issue a [replication](./meshcloud.tenant.md) warning for projects that have role assignments that cannot be replicated because a user identity could not be found on the home tenant.

#### External User Ids (euid)

Using [externally-provisioned user identities](./meshstack.identity-federation.md#externally-provisioned-identities) requires your IdP to provide a user identifier suitable to locate user identities
in the "home tenant". This external user id needs to be mapped to the `euid` user attribute in the [meshIdB](./meshstack.identity-federation.md).

It is important that the provided euid's are **case-sensitive** and must match the user entries saved in the AAD against which the replication should happen! This is a limitation imposed by the search queries of Microsoft Graph API.

> meshcloud can support complex Azure AD setups involving user identity lookup rules and multiple home tenants. Please contact our experts for more details.

#### Licensing

Users managed in the meshcloud AAD Tenant do not require AAD Premium Licenses.

## How to integrate Azure as a meshPlatform into meshStack

This is described in the Guide section under [How to integrate a meshPlatform into meshStack](meshstack.how-to.integrate-meshplatform.md).

## Azure Resource Groups

The regular Azure integration uses Subscription based meshTenants. However, there might be reasons you do wish to use Resource Groups as the meshTenant representation in your setup. Often legacy setups use this
organizational structure. It might also be helpful if your company does not yet have a Microsoft Enterprise Agreement. A requirement for automatic Subscription creation.
In the Azure Resource Group integration, every meshTenant will lead to a Resource Group generation inside a fixed parent Subscription. User access is granted via user groups bound to these Resource Groups.

The integration is very similar to the regular Azure setup. More information can be found in the Guide section under [How to integrate a meshPlatform into meshStack](meshstack.how-to.integrate-meshplatform.md).


---


---
id: meshcloud.platforms
title: meshPlatforms
---

At the heart of a meshStack are the cloud platforms that provide cloud services and resources to users.

## meshPlatforms

The following terms relate to cloud platforms:

- platform-type describes the type of a cloud platform, e.g. OpenStack, Cloud Foundry or AWS.
- meshPlatform to describe a particular deployment of such a cloud platform.

For example, meshStack can manage two, fully isolated OpenStack deployments located in different
regions in the same meshcloud. While they are both of the same platform-type OpenStack, they each
are individual meshPlatforms.

## meshLocations

In a meshStack, cloud meshPlatforms can be grouped by **meshLocation**.
Locations are free-form but they are typically used to help users identify the geographic datacenter
location as well as identify the party that is responsible for managing the cloud meshPlatforms
in this meshLocation. For example, this could be an internal IT division that manages private clouds or
an external service provider.

## Using Platforms

Users can configure which meshPlatforms their [Projects](meshcloud.project.md) are enabled to use.
The meshPlatforms available to your projects can be governed by [Landing Zones](meshcloud.landing-zones.md)
configured by your [Platform Operator](meshstack.index.md).


---


---
id: faq
title: Security FAQ
---

The following FAQ regarding Data Protection and Information Security for the various meshStack offerings answers
the most frequently asked questions from organizations' cybersecurity departments.

## Information Security

### How does meshcloud GmbH ensure us a secure experience with meshStack?

meshcloud GmbH is an [ISO 27001 certified](https://www.meshcloud.io/2021/10/28/meshcloud-is-iso-27001-certified/) company. The scope of the certification covers the design, development, implementation, operation, and support of multi-cloud management and governance solutions for public and private cloud platforms.

meshcloud GmbH is furthermore a [TISAX certified](https://www.meshcloud.io/en/blog/meshcloud-is-tisax-certified/) company.

The design, development, implementation, and maintenance process of the meshStack follows the secure development lifecycle.

meshStack is hosted by default hosted in GCP, a leading cloud provider. The geolocation is primarily within the EU but can be changed upon the customer’s requirement. This includes also the storage for backups. meshStack leverages different services of the cloud to provide security in terms of data encryption, protection against DoS attacks, access control, etc.

Additionally, meshcloud GmbH has its own incident response team. The team is responsible for handling reported incidents along with informing the customers about major changes in their Information Security Management.

### How is my data secured within meshStack?

The cloud components used by meshStack are configured according to best practices.

Hard disk encryption or container services with encrypted storage are used for different operations. Cloud storage such as AWS S3 is used to store & backup encrypted customer data and databases. The cloud components are also configured to encrypt the data in transit.

- [**AWS data encryption whitepaper**](https://docs.aws.amazon.com/whitepapers/latest/introduction-aws-security/data-encryption.html)
- [**GCP encryption at rest whitepaper**](https://cloud.google.com/docs/security/encryption/default-encryption)
- [**GCP encryption in transit whitepaper**](https://cloud.google.com/docs/security/encryption-in-transit)
- [**Azure encryption overview**](https://docs.microsoft.com/en-us/azure/security/fundamentals/encryption-overview)

### How does meshStack securely handle my cloud platform credentials?

In order to connect to the cloud platforms and execute replication steps or metering credentials to the cloud platform have to be provided to meshStack. Asymmetric encryption is used for these secrets. The service that actually stores newly entered secrets encrypts them with a public key. Only the replicator and metering services can read their according secrets with their private key to actually connect to the cloud platforms.

### How does meshcloud GmbH secure the Infrastructure for my meshStack?

The various cloud components used by meshStack, such as Virtual Cloud Network, Network Load Balancers, and Ingress Controller (Kubernetes) are configured according to best practices.

Kubernetes nodes are secured by a shared responsibility model. meshcloud GmbH uses best-practice configurations & network policies to secure the nodes for your meshStack. Access to these Kubernetes nodes is possible through the project/role assignment of the respective cloud provider.

- [AWS EKS security overview](https://docs.aws.amazon.com/eks/latest/userguide/security.html)
- [GCP GKE security overview](https://cloud.google.com/kubernetes-engine/docs/concepts/security-overview)
- [Azure AKS security overview](https://docs.microsoft.com/en-us/azure/aks/concepts-security)

Technical safeguards are implemented such as detecting and responding to Distributed Denial-of-Service (DDoS) attacks, data encryption, etc by leveraging cloud provider services.

A dedicated Virtual Cloud Network is provided for the meshStack. This network is completely encapsulated from other meshStack and their dedicated customer networks. The network configuration also includes the usage of Security Groups to strictly configure communication in the network.

### Does meshStack support Single Sign-On (SSO) and Multi-Factor-Authentication (MFA)?

Yes, meshStack supports SSO and MFA.

Activating SSO requires the integration between your own Enterprise Identity Provider (IDP) (e.g. Azure AD) with your respective meshStack.

MFA must be activated in the Enterprise IDP which is integrated with your meshStack.

### Are we allowed to security test meshStack on our own?

Yes, you can perform security tests like Penetration Tests on meshStack but this always requires prior information and getting signed approval from meshcloud GmbH.

### Can meshcloud GmbH employees (aka meshis) access our organizational data?

No, meshis (employee at meshcloud) do not primarily have any access to your organizational data. Though, in certain scenarios such as for support cases if you would like to give the access or permission to your cloud environment then you can assign it to any of our relevant meshi's.

## Data Protection

### Does meshStack process any Personal Identifiable Information (PII)?

meshStack stores your *First Name*, *Last Name*, *Email Address*, and *Last Login Date*. All these are stored in our database for user management (which is also managed via “a locally managed instance of ***[Keycloak](https://www.keycloak.org/)”***).

The External User Identifier (EUID), usually the email address, is replicated to the respective integrated cloud platforms, e.g. AWS, GCP, Azure, etc.

### Is meshStack GDPR-compliant?

Yes, meshStack is compliant with the official terms of the General Data Protection Regulation (GDPR). The official definitions are explained in the GDPR requirements as follows:

- Art. 24 - [Responsibility of the controller](https://gdpr-info.eu/art-24-gdpr/)
- Art. 25 - [Data protection by design and by default](https://gdpr-info.eu/art-25-gdpr/)
- Art. 26 - [Joint controllers](https://gdpr-info.eu/art-26-gdpr/)
- Art. 27 - [Representatives of controllers or processors not established in the Union](https://gdpr-info.eu/art-27-gdpr/)
- Art. 28 - [Processor](https://gdpr-info.eu/art-28-gdpr/)

### Does meshStack provide a compliant way to delete my PII and organizational data?

Yes, meshStack deletes your data at your request, if the data is not collected by any legal archiving obligation. If the archiving obligation applies, we archive your data.

### Where will my data be located?

a. **Data used and generated by meshStack**

meshStack uses different cloud providers such as AWS, GCP, Azure, etc. in order to store and backup data. These data can be located in the data centers of the respective cloud providers mainly in the EU region. The geolocation can be configured differently if requested.

Data center locations of leading cloud providers:

- [GCP Locations](https://cloud.google.com/about/locations)

Alternative:

- [AWS Locations](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/)
- [Azure Locations](https://docs.microsoft.com/en-us/azure/availability-zones/az-overview)

b. **Additional 3rd party services used by meshcloud GmbH**

**Google Workspace:** This is used for office applications and digital storage e.g. Office Software. Google Workspace is configured to store data within the EU region for meshcloud GmbH.

```text
Google Workspace security overview: https://workspace.google.com/learn-more/security/security-whitepaper/page-1.html
Address: 1600 Amphitheatre Pkwy,
         Mountain View, California 94043, United States
```

**ClickUp:** ClickUp is used as a project management & ticketing tool for meshcloud GmbH. ClickUp stores data according to the AICPA SOC2, GDPR & HIPAA compliances in different data centers worldwide (Germany & Ireland in Europe) hosted by AWS.

```text
ClickUp security overview: https://clickup.com/security
Address: Rechenzentren in den USA
         363 Fifth Ave. Suite 300
         San Diego, California 92101, United States
```

**BoldDesk:** BoldDesk is used as a support management tool for meshcloud GmbH. BoldDesk stores data according to the SOC2 Type 2 and GDPR compliances in different data centers in the United States and the United Kingdom hosted by Google Cloud Platform and Azure.

```text
BoldDesk security overview: https://www.bolddesk.com/legal/security
Address: Syncfusion, Inc.
         2501 Aerial Center Parkway, Suite 111,
         Morrisville, North Carolina 27560, United States
```

**Slack:** meshcloud GmbH uses Slack messaging software for interacting within the workplace. By default, Slack encrypts data at rest and data in transit for all of its customers. The security program at Slack protects its customer's data at every layer and has the following compliance certifications and attestations:

**[ISO/IEC 27001](https://a.slack-edge.com/f2814e1/marketing/downloads/security/Slack-27001-1105886-5.pdf), [ISO/IEC 27017](https://a.slack-edge.com/f2814e1/marketing/downloads/security/Slack-27017-1105886-4.pdf), [ISO/IEC 27018](https://a.slack-edge.com/f2814e1/marketing/downloads/security/Slack-27018-1105886-4.pdf), [ISO/IEC 27701](https://a.slack-edge.com/5ff60/marketing/downloads/security/Slack-27001-1105886-4.pdf), SOC 2, [SOC 3](https://a.slack-edge.com/31222cc/marketing/downloads/security/Slack_SOC_3_2021_Report.pdf), [APEC for Processors Certification](https://a.slack-edge.com/a0dbd8f/marketing/downloads/security/Slack_APEC_Processor_246.pdf), [APEC for Controllers Certification](https://a.slack-edge.com/9fefd45/marketing/downloads/security/Slack_APEC_Controller_247.pdf), CSA**

```text
Slack security overview: https://slack.com/trust/security
Address: 500 Howard Street,
         San Francisco,
         California 94105, United States
```

**GitHub**: meshcloud GmbH uses the GitHub repository for product and open source development purposes. GitHub creates a secure platform and products through developer training, the creation of components that form a secure foundation to build on, automated code analysis, in-depth threat modeling, and security code review and testing, we prevent vulnerabilities as early as possible in the development lifecycle.

```text
GitHub privacy policies: https://docs.github.com/en/site-policy/privacy-policies
Address: 88 Colin P Kelly Jr Street,
         San Francisco,
         California 94107, United States
```

(optional) [**Canny**](http://Canny.io): meshcloud GmbH uses Canny.io for collecting the customer’s feedback. Canny is SOC 2 certified. (Customers are optional participating in Canny.io)

```text
Canny security overview: https://canny.io/security
Address: San Francisco,
         California 94114, United States
```


---


---
id: administration.dns
title: "DNS and SSL Certificates"
---

During the setup of your meshStack you can choose which endpoints should be used.

## Domains

Common choices include for the meshStack domain include:

- my.organization.cloud
- portal.organization.cloud
- cloudportal.organization.com

Once you have settled on a `$domain`, we recommend to use:

- `$domain`
- `api.$domain` (API of the meshStack)
- `kraken.$domain` (Cost collection component)
- `sso.$domain` (Identity broker component)
- `sonar.$domain` (Monitoring component; used by meshcloud to monitor your meshStack)

The DNS records needed for those domains are provided to you by meshcloud during the setup of your meshStack.

## SSL certificates

> Providing SSL certificates is only required for [meshStack Enterprise](meshstack.managed-service.md#meshstack-enterprise). For [meshStack SaaS](meshstack.managed-service.md#meshstack-saas) manages SSL certificates automatically.

meshStack supports wildcard certificates and certificates with Subject Alternative Name (SAN).
SAN certificates need to contain FQDN for all hosts.
Certificates must include the full chain, including root certs issued by your organization.


---


---
id: meshcloud.tenant-quota
title: meshTenant Quota
---

[meshTenants](./meshcloud.tenant.md) for private cloud platforms may get applied certain quotas to limit the available resources for these tenants.
A default quota can be applied via a [meshLandingZone](./meshcloud.landing-zones.md). If you need a higher quota, you can create a Tenant Quota Request.
You can define the quotas you need in such a request.

> Tenant Quota Requests are currently only supported for OpenShift tenants. More private cloud platforms will follow.

## Quota Request during meshTenant creation

You can directly submit a Tenant Quota Request when creating a meshProject or adding a meshPlatform to a meshProject. If the meshPlatform supports quotas, you will see the default quotas that will be applied via the [meshLandingZone](./meshcloud.landing-zones.md). If you already know that you need a higher quota, you can request higher quota values. If requested quotas are below a [threshold](#auto-approval-of-tenant-quota-requests) defined by the platform operators, they will be auto-approved when creating the tenant.

![Create Tenant Quota Request](assets/tenants/tenant-quota-request.png)

## Managing Tenant Quota for existing meshTenants

Quota requests can be made when you open a tenant (that supports quotas) under **Settings** > **Quotas**.
If you cannot find this settings, it means that quotas are not supported for the platform of your tenant.

![Manage Tenant Quota](assets/tenants/manage-tenant-quota.png)

You can also update and cancel existing requests in the dialog. Additionally you see which quotas are currently applied to your [meshTenant](./meshcloud.tenant.md).

## Approval of Tenant Quota Requests

Platform Operators will approve your Tenant Quota request. They may also modify it, if there is some inconsistency in the quota request or if there is a limit, that only
allows them to provide less quota than you requested. If they change it, they have to provide a reason why they changed it. You will find this comment in the tenant
quota dialog when managing your tenant quota as described above.

### Auto-Approval of Tenant Quota Requests

Platform Operators can define an auto-approval threshold for [Platform Quota Definitions](administration.platforms.md#manage-quota-definitions). All quota requests that don't exceed the defined threshold for all affected quotas will be approved automatically. Additionally any Quota Request that only decreases quotas will also be approved automatically.


---


---
id: meshstack.how-to.add-platformservice
title: How to add Platform Services to a Project
---
By following these steps, you can easily add Platform Services to your Workspace, create Tenants, and manage your cloud environments efficiently.

Prerequisites:

- To add Platform Services, you must possess the role of Workspace Owner or Workspace Manager.
- Ensure you have at least one Workspace before proceeding to add Platform Services.

Step by Step guide:

1. Choose a Workspace:
    
    Navigate to the upper left corner of your screen and select the Workspace for which you want to add a platform service.
    
    ![Untitled](./assets/marketplace/guide1.png)
    
2. Access Marketplace:
    
    Within the chosen Workspace, go to the "Marketplace" tab.
    
    ![Untitled](./assets/marketplace/guide2.png)
    
3. Select Platform Services:
    
    From the list of available services, choose the desired Platform Service. This could be a platform like AWS or any DevOps tool or service like AzureVnet (see examples below). The main distinction between a Service and a Platform lies in the fact that a Service you choose always necessitates a specific Platform to function. In other words, a Service requires the existence of a Tenant or the creation of one to be added to your Project. 
    
     
    
- example of a Platform

![Untitled](./assets/marketplace/guide3.png)
    

- example of a Service

![Untitled](./assets/marketplace/guide4.png)

4.1. Adding a Platform:

Adding a Platform to a Project creates a Tenant, which is an isolated cloud environment within that Project (e.g., AWS account, Azure subscription).

If you selected a Platform, decide whether to

- [create a new Project for it](#guide-for-adding-platform-to-new-project)
- [add it to an existing Project](#guide-for-adding-platform-to-new-project)

4.2. Adding Service

The distinction between creating a Service and a Platform lies in the fact that a chosen Service always requires a specific Platform to function, thus requiring the existence of a Tenant or the creation of one to add the Service successfully. Details regarding the required Tenant type for a particular Service are displayed on the service details screen. 

![Untitled](./assets/marketplace/guide5.png)

You have the flexibility to choose whether to add Service to:

- [a new Project (Create a Project and Tenant, together with adding a Service)](#guide-for-adding-service-to-a-new-project)
- [an existing Project](#guide-for-adding-service-to-an-existing-project)

4.3 Adding a Service (Open Service Brocker)

> To avoid any confusion, we recommend to our customer with upgraded Marketplace considering a name change for meshMarketplace Platforms from "Marketplace" to "OSB Services" to ensure clarity and clear separation of concept names within your meshStack.

The Open Service Brocker (OSB) Service type only differs from the previously mentioned Services in that it exclusively operates with the “OSB Services” (deprecated naming “Marketplace”) Platform type. This means you must have or create an “OSB Services” Tenant in your Project to be able to add your Service Instance.

![Untitled](./assets/marketplace/guide6.png)

All available Service Instances will be shown on the Service Catalog and you can simply add them from the Service Catalog to Project with “OSB Services” Tenant. For OSB Services you have the same flexibility to choose whether to add Service to:

- [a new Project (Create a Project and Tenant, together with adding a Service)](#guide-for-adding-service-to-a-new-project)
- [an existing Project](#guide-for-adding-service-to-an-existing-project)

## Guide for adding Platform to new Project

**Step 1:** If you decide to create a new Project with a Platform, after choosing it from the Service Catalog click on “Create a Project”  and simply follow the on-screen steps for Project creation. 

![Untitled](./assets/marketplace/guide7.png)

![Untitled](./assets/marketplace/guide8.png)
**Step 2:** The previously chosen Platform will be preselected for you and you will need to configure it by choosing the appropriate Landing Zone.

![Untitled](./assets/marketplace/guide9.png)

**Step 3:** Upon reviewing your Project information and clicking on "Create a Project" the Tenant will be automatically created alongside the Project.

![Untitled](./assets/marketplace/guide10.png)

![Untitled](./assets/marketplace/guide11.png)

## Guide for adding Platform to existing Project

**Step 1:** Choose a Platform from the Service Catalog and select an existing Project from the list. Please be aware that only one Tenant per platform type can be created in the Project. For example, if you already have an Azure Tenant in a Project, you can´t add another Azure Tenant to the same Project.

![Untitled](./assets/marketplace/guide12.png)

**Step 2:** After choosing the Project, proceed with “Create Tenant”.

![Untitled](./assets/marketplace/guide13.png)

**Step 3:** Then configure it by choosing the appropriate Landing Zone and clicking “Create a new Tenant”. At this step, you also have the option to add Services (Building Block) to your Tenant.

![Untitled](./assets/marketplace/guide14.png)

**Step 4:** Congratulations! You've successfully added a Tenant and you can click on it to check Services available to add and other info.

![Untitled](./assets/marketplace/guide15.png)

## Guide for adding Service to a new Project

**Step 1:** If you decide to create a new Project with a Service, after choosing it from the Service Catalog, click on “Create a Project”, agree to create a Project with your Service, and simply follow the on-screen steps for Project creation. 

![Untitled](./assets/marketplace/guide16.png)

![Untitled](./assets/marketplace/guide17.png)

![Untitled](./assets/marketplace/guide18.png)

![Untitled](./assets/marketplace/guide19.png)

**Step 2:** The previously chosen Service will be preselected for you including the Platform for this Service. If a Service can work with more than one Platform type, you will need to pick one from the list.

![Untitled](./assets/marketplace/guide20.png)

**Step 3:** After selecting a Platform for your Service, the next step involves choosing a **Landing Zone** and configuring your Service by providing the required input. For OSB Services, no Landing Zone needs to be chosen. 

![Untitled](./assets/marketplace/guide21.png)

**Step 4:** Upon reviewing your Project information and clicking on "Create a Project" the Tenant including the Service will be automatically created alongside the Project!

![Untitled](./assets/marketplace/guide22.png)

## Guide for adding Service to an existing Project

**Step 1:** Navigate to the Service Catalog and select the Service that you want to add to your existing Project.

![Untitled](./assets/marketplace/guide23.png)

**Step 2:** From the Project overview, click on the "Add Service" button for the Project in which you would like to add Service.

![Untitled](./assets/marketplace/guide24.png)

**Step 3:** After selecting the Project choose a compatible Tenant and afterwards configure your Service. If you do not have a compatible Tenant for your chosen Project to add your Service, please check step 5.  

![Untitled](./assets/marketplace/guide25.png)
![Untitled](./assets/marketplace/guide26.png)

**Step 4:** Congratulations! You've successfully added a Service! You can now click on the Tenant to check on your Services under the Building Block section (see added). In the case of OSB Service, it will be shown in the OSB Service section.

![Untitled](./assets/marketplace/guide27.png)
![Untitled](./assets/marketplace/guide28.png)
**Step 5:** In case you don´t have a compatible Tenant for your Service like in the example below, please click on "Create a New Tenant”, choose the desired Platform for your Service, choose a Landing Zone, and provide the necessary input to configure your Service according to your needs. Afterward, click on the "Create" button to finalize the addition of your Service to the new Tenant. Congratulations, you've successfully added a Service!

![Untitled](./assets/marketplace/guide29.png)

![Untitled](./assets/marketplace/guide30.png)

---


---
id: meshstack.identity-federation
title: Identity and Access Management
---

meshStack supports a central Identity Provider architecture across multiple cloud and container platforms. Therefore, meshStack contains a full-featured Identity Broker (meshIdB) which consumes identities from company directories and adds authorization information for the specific cloud platforms.

Identity Federation enables enterprises to integrate corporate SSO systems at a single point (the **mesh Identity Broker**). meshStack then uses it's desired-state replication to ensure correct configuration of identity and authorization information into all connected **meshPlatforms**. The diagram below depicts the principal components involved.

> To get a more fundamental understanding of doing IAM in the cloud, look into the IAM Building Blocks in the [Cloud Foundation Maturity Model](https://cloudfoundation.meshcloud.io/maturity-model/iam/).

```mermaid
graph LR;
    subgraph Enterprise IAM
      IdP["Identity Provider"];
    end
    subgraph meshStack
      direction LR;
      IdB["Identity Broker"]-->meshfed;
      meshfed[meshfed-api]-->replicator;
      replicator[replicator];
    end
    IdP--OIDC/SAML-->IdB
    subgraph Azure
      aad["Azure Active Directory"];
    end
    subgraph AWS
      awssso["AWS SSO"];
    end
    subgraph GCP
      gcd["Google Cloud Directory"];
    end
    subgraph OpenShift
      openshift["OpenShift API"];
    end
    subgraph Cloud Foundry
      uaa["UAA"];
    end
    subgraph OpenStack
      keystone["Keystone"];
    end
    replicator-->keystone;
    replicator-->uaa;
    replicator-->aad;
    replicator-->awssso;
    replicator-->gcd;
    replicator-->openshift;
```

## Designing Multi-Cloud Identity and Access Management

Designing an effective multi-cloud identity and access management strategy is no small feat. This guide describes the
most important considerations that enterprise architects and IAM specialists need to be aware of when designing
a multi-cloud IAM strategy for their organisation. Wherever applicable, it will link to sections that describe relevant configuration options in detail.

## Federated Multi-Cloud Identities

meshStack enables multi-cloud identity federation so that end-users of the system like developers can access all their cloud environments using a single user identity. This allows enterprises to easily retain full control over identities and credentials.

The identity provisioning mechanism and the resulting federation setup depends on the type of cloud platform and its specific configuration. For in-depth details Please consult the respective platform's operator documentation for more configuration details.

### meshStack-provisioned Identities

In this mode meshStack provisions user identities used in meshProjects on the respective cloud platform. Please note that this mode is deprecated and we do not advise new platform integration to be configured this way.

```mermaid
graph LR;
    subgraph Enterprise IAM
      IdP["Identity Provider"];
    end
    subgraph meshStack
      direction LR;
      IdB["Identity Broker"]-->meshfed;
      meshfed[meshfed-api]-->replicator;
      replicator[replicator];
    end
    subgraph meshPlatform
      iam["Platform IAM"];
    end
    replicator--user provisioning-->iam
    replicator--permission replication-->iam
    IdP--user<br>auto-provisioning-->IdB
    IdP-.federated<br>authentication.->IdB
    IdB-.federated<br>authentication.->iam
```

### Externally-provisioned Identities

Some public cloud platforms like [Microsoft Azure](./meshstack.azure.index.md) or [Google Cloud Platform](./meshstack.gcp.index.md) feature their own directory services for cloud-based or hybrid user identities. Enterprises provision cloud identities by synchronizing an on-premise directory to the cloud. These setups are especially common for enterprises using Office 365 or Google Google Workspace.

meshStack supports using user identities from these cloud directories for the resepective cloud [meshPlatform](./meshcloud.platforms.md). meshStack calls these **externally provisioned user identities** because provisioning and identity federation between on-premise and cloud-directory happens outside of meshStack.

```mermaid
graph LR;
    subgraph Enterprise IAM
      IdP["Identity Provider"];
    end
    subgraph meshStack
      direction LR;
      IdB["Identity Broker"]-->meshfed;
      meshfed[meshfed-api]-->replicator;
      replicator[replicator];
    end
    subgraph meshPlatform
      iam["Platform IAM"];
    end
    replicator--permission replication-->iam
    IdP--user<br>auto-provisioning-->IdB
    IdP-.federated<br>authentication.->IdB
    IdP--user provisioning-->iam
    IdP-.federated<br>authentication.->iam
```

### Choosing an identity provisioning strategy

The next subsections discuss important considerations for choosing the right identity provisioning strategy for your cloud platforms.

#### Platform Support

The cloud platforms supported by meshStack offer different technical IAM integration capabilities.
While it's a key consideration for meshStack to deliver a unified multi-cloud IAM control plane,
architects need to consider the unique capabilities of cloud platform IAM systems (e.g. AAD vs. Google Cloud Identity) and of their organizations' IAM architecture. Based on the platform's native capabilities,
meshStack supports the following identity provisioning strategies:

|               |   [meshStack-provisioned](#meshstack-provisioned-identities)   |        [externally-provisioned](#externally-provisioned-identities)        |
| :-----------: | :------------------------------------------------------------: | :------------------------------------------------------------------------: |
|   OpenStack   |                               -                                |   [supported](./meshstack.openstack.index.md#access-control-integration)   |
| Cloud Foundry |                                                                | [supported](meshstack.cloudfoundry.index.md#uaa-configuration)             |
|  Kubernetes   |                               -                                |  [supported](./meshstack.kubernetes.index.md#access-control-integration)   |
|   OpenShift   |                               -                                |       [supported](./meshstack.openshift.index.md#idp-configuration)        |
|      AWS      |   [deprecated](./meshstack.aws.index.md#meshidb-deprecated)    |               [supported](./meshstack.aws.index.md#aws-sso)                |
|     Azure     |   [AAD B2B](./meshstack.azure.index.md#workload-aad-tenant)    | [supported](./meshstack.azure.index.md#azure-active-directory-integration) |
|      GCP      |                               -                                |     [supported](./meshstack.gcp.index.md#cloud-identity-configuration)     |

#### Availability of Users and Atttributes

In order to use externally-provisioned identities, Platform Operators need to set up the necessary user provisioning
routines outside of meshStack. Depending on the existing IAM landscape in your organization, this can require
setting up synchronization to on-premise directories and other IAM systems.

In order to correctly replicate user permissions, meshStack needs to map meshUser objects with permissions on a meshProject
to "platform user" objects in a platform's IAM system (e.g. an AAD user object). To perform this mapping, meshStack requires an `external user id` (shorthand `euid`) attribute that needs to be present on all user objects and in all cloud platforms. This attribute can typically be an existing `email` or `username`, however it needs to be unique, stable and available on all systems.

> meshStack will log replication warnings when it fails to replicate permissions for externally provisioned user identities, e.g. because a user could not be located on the platform.

#### High availability

meshStack features a carefully designed high-availability architecture. A potential loss of meshStack availability as the multi-cloud "control plane" is tolerable for the "data plane" used by developers to authenticate and work with cloud platforms. This means that developers' work can continue uninterrupted while meshStack availability is restored. Only operations that modify desired state like managing cloud permissions via [meshProjects](./meshcloud.project.md) are temporarily unavailable in this case.

User can still authenticate and work with cloud platforms using [meshStack-provisioned identities](#meshstack-provisioned-identities), as long as the meshIdB is available. meshcloud therefore supports deploying the meshIdB in a data-center redundant HA setup.

Availability of the meshIdB does not affect cloud platforms using [externally-provisioned identities](#externally-provisioned-identities). These platforms can tolerate a full loss of meshStack availability.

## Configuring externally-provisioned identity federation

As described above in [Availability of Users and Atttributes](#availability-of-users-and-atttributes), choosing a suitable euid attribute is crucial when designing an IAM architecture leveraging externally-provisioned identity federation.
The diagram below explains the components involved in an `euid` configuration and how attribute values propagate through the connected systems.

```mermaid
graph LR;
    subgraph Enterprise IAM
      IdP["Identity Provider"];
      IdLSource[(Identity Lookup Source<br>AAD or GCD)]
      IdCSource[(Identity Connector Source<br>LDAP)]
      IdP["Identity Provider"]-.-IdLSource
      IdP["Identity Provider"]-.-IdCSource
    end
    subgraph meshStack
      direction LR;
      IdB["Identity Broker"]-->meshfed;
      IdL["Identity Lookup"]-->meshfed;
      IdC["Identity Connector"]-->meshfed;
      meshfed[meshfed-api]--desired state<br>euid-pattern-->replicator;
      replicator[replicator];
    end
    IdP--OIDC/SAML<br>user data with euid-->IdB
    IdLSource--user data with euid-->IdL
    IdCSource--user data with euid-->IdC
    subgraph Azure
      aad["Azure Active Directory"];
    end
    subgraph AWS
      awssso["AWS SSO"];
    end
    subgraph GCP
      gcd["Google Cloud Directory"];
    end
    subgraph OpenShift
      openshift["OpenShift Users API"];
    end
    subgraph meshPlatforms
      Azure;
      AWS;
      GCP;
      GCP;
      OpenShift;
    end
    replicator--user lookup<br>by euid-->aad;
    replicator--user lookup<br>by euid-->awssso;
    replicator--user lookup<br>by euid-->gcd;
    replicator--user lookup<br>by euid-->openshift;
```

Note that the diagram shows IAM systems by their "role". It is possible that a solution IAM architecture
uses the same IAM system in multiple roles simultaneously. For example, it's common to use the same AAD tenant as an Identity Provider, Identity Lookup Source and as a target IAM system for an Azure meshPlatform.
Nonetheless, operators need to configure each of these roles individually. The following sections provide links to the appropriate configuration references and summarises
euid attributes supported for the particular component or system.

### Identity Provider

meshStack auto-provisions meshUsers from valid, federated login tokens provided by an [Enterprise Identity Provider](./meshstack.identity-provider.md).
In essence, any user attribute that the Identity Provider is capable to provide in a SAML assertion or OIDC token claim can be used as an `euid`.
However, some identity providers only support a restricted set of user attributes.

| Identity Provider | euid attributes supported                   |
| ----------------- | ------------------------------------------- |
| AD FS             | every attribute available via claims mapper |
| AAD               | `userPrincipalName`, `mailNickName`         |
| GCP               | `primaryEmail`                              |

For further details, please consult the [Identity Provider configuration reference](./meshstack.identity-provider.md).

meshStack updates the `euid` of a user with the latest value passed from the IdP on every log in of the user into meshPanel.
In case Platform Operators do not configure an identity lookup (see next section), this allows meshStack to retrieve an `euid` that is not an email from the IdP. However, Platform Operators need to be aware that
users that have never logged in to meshStack will not have an `euid` set and can thus not be replicated
to cloud platforms configured to use externally-provisioned identities.

### Identity Lookup

meshStack allows Workspace Managers to [quickly onboard team members](./meshcloud.workspace.md#invite-users-to-a-meshworkspace-team) with an assisted onboarding workflow.
This onboarding workflow features an autocomplete and search for user identities in an enterprise user directory. This search process is called identity lookup.

meshStack supports configuration of an optional identity lookup source. When possible, IAM architects should give preference to using the configured identity provider also as as an identity lookup source.

Since email is a fundamental attribute of every meshUser, every identity lookup source is capable
of providing this attribute.
If an operator does not configure an identity lookup source, meshStack will use the email address entered by the inviting user.
This email address can also be used to set a user's `euid`, see the [user onboarding configuration reference](meshstack.onboarding.md#workspace-user-invitations) for details.

| Identity Lookup Source | euid attributes supported                                               |
| ---------------------- | ----------------------------------------------------------------------- |
| none                   | email (manual input)                                                    |
| AAD                    | email, any user attribute, incl. SchemaExtensions and Custom Attributes |
| GCP                    | email, any Schema Extension attribute                                   |

For further details, please consult the [Identity Lookup configuration reference](./meshstack.identity-lookup.md).

### Identity Connector

The [Identity Connector](meshstack.workspace-group-sync.md) can automatically provision meshUsers via the meshObject API.
As a part of this process, the identity connector can also set the `euid` attribute.

| Identity Connector Source | euid attributes supported                                 |
| ------------------------- | --------------------------------------------------------- |
| LDAP                      | every attribute available via LDAP query on a User entity |

If the identity connector is used, see the [Identity Connector](./meshstack.workspace-group-sync.md) configuration reference.

### Platform Configuration

When meshStack generates the desired state for a [meshTenant](./meshcloud.tenant.md), it uses the
assigned [meshProject roles](meshstack.authorization.md#meshproject-roles) together with the meshPlatform and meshLandingZone configuration to compute the desired IAM configuration in the cloud platform.

As a part of this process, meshStack has to map each meshUser to a native platform user object using the meshUser's `euid` attribute and matching it with a configurable attribute of the native platform user object. Platform Operators can configure this process in two steps.

#### Transforming euids with patterns

Some common cloud IAM architectures require using different user account for test and production workloads (e.g. `user@test.example.com`, `user@example.com`) or using a different user account for private and public clouds (`example-corp\user`, `user@example.com`). In order to allow support these setups, Platform Operators can configure this transformation of the meshUser `euid` individually for each meshPlatform.

<!--snippet:meshfed.platform#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let Platform =
      let Platform =
          {-
            platform-identifier:
              Full identifier in the form <platform>.<location> for the platform this config relates to.

            euid-pattern:
              Format string for translating generic user euids for specific platforms.
              This is only required if euids differ accross platforms. Use '%s' to leave euids unchanged
              or '%S' to convert it to uppercase.
          -}
            { platform-identifier : Text, euid-pattern : Text }

      let examplePublicCloud =
              { platform-identifier = "azure.azure-prod"
              , euid-pattern = "%s@example.com"
              }
            : Platform

      let examplePrivateCloud =
              { platform-identifier = "openstack.internal"
              , euid-pattern = "example.com/%S"
              }
            : Platform

      in  Platform
```
<!--END_DOCUSAURUS_CODE_TABS-->

#### Looking up transformed euids

In order for the replicator to map the transformed `euid` to a cloud platform's native user object, operators must configure which platform user attribute to use for this lookup.

> IAM architects need to ensure that any external user provisioning processes outside of meshStack fill platform user object
> attributes with the correct euid values.

The cloud platforms supported by meshStack have different capabilities to query user attributes via API.
meshStack can thus only support lookup in one or two platform user attributes.

| Platform           | platform user object attributes supported |
| ------------------ | ----------------------------------------- |
| Azure              | `userPrincipalName`, `mail`               |
| AWS                | `userName`                                |
| GCP                | `primaryEmail`                            |
| OpenShift          | `User.metadata.name`                      |
| Kubernetes         | `User.metadata.name`                      |
| OpenStack          | `User.name`                               |
| Cloud Foundry      | `User.username`                           |
| meshMarketplace\*  | `userPrincipalName`, `mail`               |

\*_with AAD permission Replication_

At the moment only AAD offers a choice of user lookup attributes. Platform Operators can configure these globally for all meshPlatforms.

<!--snippet:mesh.replicator-->

The following configuration options are available at `mesh.replicator`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let Replicator =
    {-
      aadUserLookupStrategy:
        Determines the attribute used for looking up users in AADs.
        This setting is shared across all Azure and meshMarketplace platforms configured to use an AAD
        for user permission replication.
    -}
      { aadUserLookupStrategy : Platform.Azure.AzureLookupStrategy }
```
<!--END_DOCUSAURUS_CODE_TABS-->

<!--snippet:replicator.platform.azure.AzureLookupStrategy#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AzureLookupStrategy =
    {-
      Determines how meshStack which AAD user object attribute meshStack will use to map a meshUser by its euid.

      UserByMailLookupStrategy:
       compares the meshUser's euid to the 'mail' attribute on the AAD User.

      UserByUsernameLookupStrategy:
         compares the meshUser's euid to the 'userPrincipalName' attribute on the AAD User.

      Both strategies use case insensitive comparison.
    -}
      < UserByMailLookupStrategy | UserByUsernameLookupStrategy >
```
<!--END_DOCUSAURUS_CODE_TABS-->

## Group Cleanup

For the platform listed below user access is given by assigning groups with the apropriate users inside to the platform tenant. The naming of these groups can be customized by setting the `User Group Name Pattern` in the appropriate meshPlatform Configuration. See the image below.

![User Group Name pattern in the meshPlatform config](assets/platform-config-groupname-pattern.png)

Additionally added group permissions are discouraged, but possible for some platforms. For other platforms additional added permissions are removed during a replication run. This currently is a slight inconsistent behavior that will be unified in the future. Below is a table to see in which platform externally added permissions are kept on their usergroups during project replication.

| Platform               | Additional Permission Possible |
| ---------------------- | :----------------------------: |
| AWS (meshIdB)          |               ✅                |
| Azure                  |               ❌                |
| GCP                    |               ✅                |
| OpenStack              |               ✅                |
| OpenShift              |               ✅                |
| AKS (AAD Permissions¹) |               ❌                |
| CloudFoundry²          |               ✅                |

¹: This applies only the the user group permissions that are applied in the AAD to give the users general access to the AKS cluster. The cluster role assignments in the cluster are not affected.

²: In Cloud Foundry the permissions are handled by the IDP and no direct group permissions replication is happening on the platform.

When the name of a group has changed by a user initiated config change e.g. when modifying the group name pattern inside the platform config or by changing the meshRole to Platform Role Mapping inside a Landing Zone as long as the parameter `#{platformGroupAlias}` is used in the User Group Name Pattern, the group is deleted and re-created with a different name.
The deletion is done because certain cloud platforms don't support group renaming
If additional tenant access permissions were attached to this group by an external system, these permissions are lost and not carried over.

Automatic group cleanup is available for GCP, AWS, Azure, Azure Kubernetes Service, and OpenShift.


---


---
id: meshstack.how-to.integrate-meshplatform
title: How to integrate a meshPlatform into meshStack
---

A meshPlatform describes a deployment of a cloud platform (e.g. GCP, AWS, Azure, Openstack, etc.). In order to leverage meshcloud's functionalities for a particular cloud platform, a meshPlatform needs to be integrated into meshStack. Below is a step-by-step guide to integrate your desired meshPlatform.

> For more details on the integrations please visit the integration page of the specific cloud platform in the [Operator Docs](meshstack.index.md).

## Step 1: Set up the meshPlatform in the panel

Open the admin area of the panel and navigate to meshPlatform view. Choose "Create a meshPlatform"

![Create meshPlatform](assets/create-meshPlatform.png)

The required credentials for the platform configuration are created in the following step.

## Step 2: Set up platform permissions using Infrastructure as Code (recommended)

> You do not have to be familiar with terraform to execute the integration. All commands are outlined in the module instructions.

Open the official meshcloud terraform module for the target platform and follow the instructions.

- [AWS meshPlatform Module](https://github.com/meshcloud/terraform-aws-meshplatform)
- [Azure meshPlatform Module](https://github.com/meshcloud/terraform-azure-meshplatform)
- [GCP meshPlatform Module](https://github.com/meshcloud/terraform-gcp-meshplatform)
- [Kubernetes meshPlatform Module](https://github.com/meshcloud/terraform-kubernetes-meshplatform)
- [Cloud Foundry meshPlatform Module](https://github.com/meshcloud/terraform-cloudfoundry-meshplatform)

### Alternative to Step 2: Set up platform permissions manually

Follow the instructions for the target public cloud platform.

- [How to manually integrate AWS as meshPlatform](meshstack.how-to.integrate-meshplatform-aws-manually.md)
- [How to manually integrate Azure as meshPlatform](meshstack.how-to.integrate-meshplatform-azure-manually.md)
- [How to manually integrate GCP as meshPlatform](meshstack.how-to.integrate-meshplatform-gcp-manually.md)

For private cloud platforms, you can find integration information here:

- [Integration of CloudFoundry](meshstack.cloudfoundry.index.md)
- [Integration of Kubernetes](meshstack.kubernetes.index.md)
- [Integration of OpenShift](meshstack.openshift.index.md)
- [Integration of OSB Services](meshstack.meshmarketplace.index.md)

## Step 3: Complete the meshPlatform configuration in the panel

Enter the credentials from Step 2 in the platform configuration.

## Step 4: Try out your new platform

Try out the new meshPlatform by configuring a new Landing Zone in the admin area and using the Landing Zone to create a meshProject.


---


---
id: marketplace.index
title: Overview
---
## Platform Services

Platform Service within meshStack refers to any platform (e.g., Cloud or any other platform like GitHub) or service (e.g., Azure VNet) that can be  developed, executed, and managed by Platform Operators with ease. Platform Operators offer services and platforms that enable applications to build, deploy, and scale without concerns about the underlying infrastructure. The type of a Platform Service in meshStack depends on whether it can be developed as a [Building Blocks](administration.building-blocks.md), [Platform](administration.platforms.md), or [OSB Service](marketplace.service-instances.md).


## Marketplace

meshStack provides you with an online shopping experience in the Enterprise. Via the Service Catalog providers inside the organization can offer consumers their services in a standardized and automated way.  Application teams (consumers) can brows a united portfolio that is located in the Marketplace tab of the Workspace.

The Service Catalog presents application teams with details, prices, and documentation for all available Platform Services, allowing them to effortlessly add them to their Projects. Through the Service Catalog, Workspace Owners and Managers can provision Platform Services for both new and existing Projects and Tenants. Here you can find a [guide](meshstack.how-to.add-platformservice.md) for adding different Platform Services from the Service Catalog.

![Overview of Marketplace](assets/marketplace/marketplace-overview.png)

You can access the Service Catalog not only through the Workspace panel but also directly from your meshTenant. Smart filtering is applied in the meshTenant control view, ensuring that only relevant Platform Services are displayed based on the specific meshTenant. For example, Azure meshTenant services, such as Azure Vnet, will be shown. 

To navigate to the Tenant Marketplace, choose a Tenant from the Project overview panel, click on the Tenant, and then select the Marketplace tab.

![Overview of Tenant](assets/marketplace/tenant-overview.png)

![Marketplace Tenant](assets/marketplace/tenant-marketplace.png)

>In the next phase of upgrades for the Service Catalog, we'll be introducing tags for Platform Services that will enable you to effortlessly filter and find the specific Platform Service you're looking for.


---


---
id: administration.platforms
title: meshPlatforms
---

A meshPlatform is the integration of your Cloud Platform with several configurations into meshStack.
It enables the core functionality of meshStack such as tenant creation, replication and metering of your Cloud Platforms.

Besides integrating your cloud platform, the following functionality is also highly useful:

* Manage and create landing zones in the [landing zone administration screen](administration.landing-zones.md).
* View all your existing cloud tenants in the [tenant list](administration.tenants.md).

> All platform related maintenance like Landing Zones, Tenants, etc will be moved to the [Platform Control Plane](#platform-control-plane)
> in future.

## Platform Creation

You can integrate new meshPlatforms in self-service via a wizard in meshStack.

![Platform Creation](assets/platform_maintenance/platform-creation.png)

The following platform types are available for selection.

![Platform Types](assets/platform_maintenance/platform-types.png)

You have to assign a [meshLocation](#meshlocation) to your meshPlatform. Details about what a meshLocation is and how to use it can be found [here](#meshlocation).

Additionally you can directly [restrict](#restrict-platform-access) your meshPlatform to certain meshWorkspaces to e.g. first test a new meshPlatform integration
with a private meshWorkspace that only you have access to. Doing this during creation can prevent confusion of other users who may see the meshPlatform shortly if you would [restrict](#restrict-platform-access) it after creation.

You can always change the mutable information given during meshPlatform creation later in the [Settings](#settings) tab of the Platform Control Plane.

## Platform Control Plane

The Platform Control Plane is the central entry point for performing any tasks on your meshPlatform or insights you want to gather on it.

![Platform Control Plane](assets/platform_maintenance/control-plane.png)

### Financials

In this tab you can get an overview about which kind of resources are being used in your Cloud Platform.

### Settings

This tab is mainly responsible for managing how your meshPlatform is shown and used inside meshStack. You can provide general information
about your Cloud Platform like a display name or the Web Console Url meshStack will link to when the user wants to actually access
the cloud platform. For public cloud platforms you can leave the Web Console Url as is because meshStack already provides the link to their Web Console.

#### meshLocation

The meshLocation is useful for grouping together multiple platforms. This is especially helpful for private cloud platforms that have an actual physical location. You may want to group all Cloud Platforms running in the same datacenter into one meshLocation.
For public cloud platforms, we recommend to name them according to the provider as public cloud platforms are not really tied to a physical location. E.g. name the meshLocation for Azure simply "Azure". This also fits well if you have multiple Azure Tenants for your different stages and want to group them into this "Azure" meshLocation.

Additionally you can provide some provider information of your meshLocation. You can describe how you operate your Cloud Platforms that belong to a meshLocation,
you can provide a link to a Wiki to provide further, more detailed information about your meshPlatforms within a meshLocation.

#### Platform Connection Config

When integrating a cloud platform into meshStack you have to enter some specific configuration so meshStack knows how to handle the platform. This relates to replication as well as metering configuration. A central aspect of it is defining how to connect to your cloud platform. For public cloud platforms you have to provide some kind of root account for all tenants managed by meshStack are living in. This is for example an AWS Root Account, a GCP Billing Account or an Azure Tenant. For private cloud platforms you usually have to provide an endpoint for the API. meshStack will communicate with it to manage tenants. In all cases you have to provide some kind of credentials so meshStack can perform the actions needed for replication and metering. You can find details about how to set up the cloud platform with credentials and more in the platform-specific [How to integrate a meshPlatform into meshStack](meshstack.how-to.integrate-meshplatform.md) guide.

The following list provides the most common configurations available for different cloud platform types:

* Credentials and connection attributes for replication and metering
* Role Mappings for mapping Project Roles in meshStack to specific roles in the cloud platform
* Naming of platform tenants (e.g. AWS Account or Azure Subscription) via [String Templates](meshstack.replication-configuration.md#string-templating)
* Naming via [String Templates](meshstack.replication-configuration.md#string-templating) of platform IAM groups created by meshStack to provide users access to their tenants
* [Tag Configuration](meshstack.metadata-tags.md#tags-in-cloud-tenants) for platform tenants and resources (e.g. add workspace and project identifier as a tag to the platform tenant)
* platform-specific additional configuration

As an example you can find a part of the GCP configuration in the following image:

![GCP Connection Configuration](assets/platform_maintenance/gcp-config.png)

#### Restrict Platform Access

Access to a specific meshPlatform can be restricted via the "Restrictions" tab. This feature is helpful
when a new meshPlatform shall be integrated, but initially only be visible to a few meshWorkspaces for integration testing.
Another use-case is having a dedicated Cloud Platform that shall only be available to certain meshWorkspaces in general.

To restrict the meshPlatform, search for the workspaces the platform shall be restricted to and add these workspaces via the *+* button.

#### Manage Quota Definitions

In order to provide quotas to meshTenants, the available quotas have to be defined first. A `Quota Key` that must match the quota key in the platform, can be defined. Additionally a speaking name for the Quota that is shown in meshPanel as well as a description and a unit can be defined. Min and Max values can also be set to restrict the quotas to a certain maximum or minimum. An [Auto Approval Threshold](meshcloud.tenant-quota.md#auto-approval-of-tenant-quota-requests) can also be defined. It can be set to 0, if no auto-approval of quota requests shall be applied.

**Removing Quotas**
If you want to remove quotas from a platform just click the "-" button on the right side of the table. If removed in the Platform Quota Definition, quotas will be removed from the Landing Zones and tenants belonging to the platform as well. The removal of quotas from the meshTenants will happen during next replication.

> Currently only OpenShift is supported for Quota Management

![Manage Platform Quota Definitions](assets/tenants/platform-quota-definitions.png)

### Deprecate Platform

**Deprecation** will prevent the meshPlatform from being selected for new meshTenants. Existing meshTenants of this meshPlatform will still be replicated and can still be accessed via the meshPanel. Your users can recognize a meshTenant of a deprecated meshPlatform by a yellow bubble on the platform icon in the "Projects Overview" on the workspace control plane. If your users are on the tenant control plane, a yellow status label will appear in the header of the control plane. You can also **undo the deprecation**. This allows your users to select the meshPlatform for new meshTenants again.

1. Navigate to **Platforms** > **meshPlatforms**.
2. Select the meshPlatform.
3. Navigate to **Danger Zone**. Depending on the state of your meshPlatform, you can either see a `Deprecate meshPlatform` or `Reactivate meshPlatform` button.
4. Click on the button.

### Delete Platform

**Deletion** will make the meshPlatform not selectable for new meshTenants and existing meshTenants not accessible via meshPanel anymore. No more replication will be executed. Once you delete a meshPlatform, meshStack will automatically delete all meshTenants of the meshPlatform without deleting the platform tenants in the cloud platform. The deletion process of a meshPlatform will also remove the replicator and metering configurations. Therefore, your meshPlatform will be completely inaccessible via meshStack and can not be recovered. As meshStack does not delete or do any updates on platform tenants themselves when a meshPlatform is deleted, direct access in the cloud platform to the platform tenants is still possible.

1. Navigate to **Platforms** > **meshPlatforms**.
2. Select the meshPlatform.
3. Navigate to **Danger Zone**.
4. Click on `Delete meshPlatform` button and confirm the deletion with its identifier. A deletion **can not be reverted**.

## Platform Notifications

Administrators can inform users about platform specific events (updates, new features, service disruptions, etc.) by creating platform
notifications:

* **Platforms**: Select the platforms relevant to your notification so they can be shown on the affected platform's dashboards. Users
  can also [subscribe](meshcloud.profile.md#profile) to notifications by platform and [subscribed users](./meshcloud.profile.md#platform-notification-subscriptions) will receive new notifications via email.
* **Message**: The message that will be shown to all users. You can enter valid HTML in this field (except for the `<p>` tag). This is useful for e.g. supplying links to support pages.
* **Severity**: The type of message (info, warning, critical).
  * Info: for new features, upcoming services updates and general information that is not expected to disrupt platform operation
  * Warning: best used to inform about partial platform outages or problems that may occur for some users
  * Critical: appropriate in case of complete platform failures or impending platform downtimes
* **Show From**: The earliest time the message will be shown. You can use this to create messages that will only be shown on at a later date. You can leave this empty if you want the message to be shown right away.
* **Show Until**: After this time the message will no longer be displayed. You can leave it empty if the notification shall never disappear automatically.

At the bottom of the screen, a preview is shown. This can give you an idea of how the message is presented to your end-users.


---


---
id: meshstack.workspace-group-sync
title: User & Group LDAP Synchronisation
---

meshStack supports importing users and groups into meshStack from a source that supports the LDAP protocol, for example, Microsoft Active Directory. The [`Simple Paged Results Control`](https://www.ietf.org/rfc/rfc2696.txt) is used to do a paginated LDAP query to fetch the users and groups. Because of this, it is required that the LDAP server supports the `Simple Paged Results Control`. Other than importing users and groups, meshStack also has the capability to assign a [workspace role](./meshcloud.workspace.md#assign-meshworkspace-roles) or [partner role](./administration.index.md) to the imported group. The entities read via LDAP are imported to meshStack via the [meshStack API](/api/). At the moment, we only support the import of three kinds of meshObjects: meshUser, meshGroup and meshWorkspaceGroupBinding. The other meshObjects, such as meshProjectUserBindings can be created via the panel.

## Configuration Reference

This section describes how to configure the LDAP group synchronization in meshStack.

The synchronization process is done in three parts.

* Collect
* Transform
* Transport

### Collect

In the "Collect" step, we connect to the LDAP server and fetch the LDAP entities. In order to do that,
the configuration needs to contain the information required to establish a connection with the LDAP server.
The configuration model is as follows.

<!--snippet:mesh.identityconnector.ldap.SourceConfiguration#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let SourceConfiguration =
    {-
      url:
          The LDAP connection URL, including the ldap protocol

      base:
          The base query from which all further searches should be performed

      username:
          The username of a technical user who can connect to the LDAP source to perform searches

      password:
          The password of the user above
    -}
      { url : Text, base : Text, username : Text, password : Secret }
```
<!--Example-->
```dhall
let example
    : SourceConfiguration
    = { url = "ldap://example.com:389"
      , base = "dc=meshcloud,dc=io"
      , username = "user"
      , password = Secret.Raw "LDAP_PASSWORD"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


You also have to specify the filters that should be used when fetching users and groups from the LDAP server.
Additionally, using the pageSize configuration parameter, specify the number of LDAP entities we should request in a single call to the server.

<!--snippet:mesh.identityconnector.ldap.collectorConfiguration#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let LdapFilter =
    {-
      collectionType:
          The type of the entity which is collected. Can either be PERSON or GROUP.

      attributes:
          A comma separated list of attributes that should be returned per LDAP entry.
          These attributes can later be used to populate the value of a meshObject field.

      base:
          The base from which the query should be performed.

      filter:
          A filter that follows the LDAP search filter format.
    -}
      { collectionType : CollectionType
      , attributes : Text
      , base : Text
      , filter : Text
      }

let CollectorConfiguration =
    {-
      pageSize:
          The size of a single page that will be returned as a result of an LDAP search

      sources:
          A list of LdapFilter which will contain the information needed to search the LDAP source for groups or persons.
    -}
      { pageSize : Natural, sources : List LdapFilter }
```
<!--Example-->
```dhall
let example
    : CollectorConfiguration
    = { pageSize = 100
      , sources =
            [ { collectionType = CollectionType.GROUP
              , attributes = "cn, uniqueMember, description"
              , base = "ou=groups"
              , filter = "(cn=*)"
              }
            , { collectionType = CollectionType.PERSON
              , attributes = "entryDN, uid, sn, givenName, mail"
              , base = "ou=people"
              , filter = "(uid=*)"
              }
            ]
          : List LdapFilter
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Transform

In the Transform step, the collected data is transformed into meshObjects.

An `AttributeTransformation` will specify an LDAP attribute and how to transform it before assigning to a meshObject field.

<!--snippet:mesh.identityconnector.ldap.attributeTransformation#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AttributeTransformation =
    {-
      An AttributeTransformation is used to define an attribute of an LDAP entry and how to transform it so that it
      can be assigned to a field in a meshObject. There are two types of AttributeTransformations, Static and Regex.
    -}
      < Static : StaticAttributeTransformation
      | IfNull : IfNullAttributeTransformation
      | Regex : RegexAttributeTransformation
      >
```
<!--END_DOCUSAURUS_CODE_TABS-->

#### StaticAttributeTransformation

<!--snippet:mesh.identityconnector.ldap.staticAttributeTransformation#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let StaticAttributeTransformation =
    {-
      A StaticAttributeTransformation simply takes an attribute and applies an optional postProcessor on it.

      attribute:
          The LDAP attribute that should be processed. For example "cn"

      postProcessor:
          Any post processing function that should be run on the mapped value. Can be one of UPPERCASE or LOWERCASE
    -}
      { attribute : Text, postProcessor : Optional PostProcessor }
```
<!--Example-->
```dhall
let example =
      { attribute = "cn", postProcessor = Some PostProcessor.LOWERCASE }
```
<!--END_DOCUSAURUS_CODE_TABS-->

#### IfNullAttributeTransformation

<!--snippet:mesh.identityconnector.ldap.ifNullAttributeTransformation#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let IfNullAttributeTransformation =
    {-
      A IfNullAttributeTransformation takes a nullable attribute.
      If the value of this attribute is null for an entity it uses a replacement value.
      After an attribute value is found, the transformation applies an optional postProcessor on the value.

      attribute:
          The LDAP attribute that should be looked up first. For example "mail"

      ifNullAttribute:
          The LDAP attribute that should be looked up if the value of the first attribute is null. For example "cn"

      postProcessor:
          Any post processing function that should be run on the mapped value. Can be one of UPPERCASE or LOWERCASE
    -}
      { attribute : Text
      , ifNullAttribute : Text
      , postProcessor : Optional PostProcessor
      }
```
<!--Example-->
```dhall
let example =
      { attribute = "mail"
      , ifNullAttribute = "cn"
      , postProcessor = Some PostProcessor.LOWERCASE
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


#### RegexAttributeTransformation

<!--snippet:mesh.identityconnector.ldap.regexAttributeTransformation#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let RegexAttributeTransformation =
    {-
     A RegexAttributeTransformation takes an attribute and matches the attribute against a list of regular expressions
     until a match is found. If a match is found and the rule defines a value, the value will be used. If a value is not
     set, the first matching group in the regular expression is used and the optional template is applied. If no
     regular expressions match, the otherwise value will be assigned to the meshObject field.

      rules:
          A list of regex rules that the LDAP attributes will be tested against for a match.
          The matching is performed sequentially until a match is found.
          A single rule has the following structure
          value:
              This is an optional parameter. If it is defined and if the LDAP attribute matches the
              regular expression, this value will be assigned as the value of the meshObject field.
          regex:
              The regular expression against which the LDAP attribute should be matched. If the value parameter
              is not defined, the regular expression MUST contain a group and the first group will be assigned
              as the value of the meshObject field.

      template:
          An optional template where the extracted value should be inserted into.
          The format should follow the Java String.format contract.

      otherwise:
          An optional default value to be assigned if none of the rules match.
    -}
        StaticAttributeTransformation
      ⩓ { rules : List { regex : Text, value : Optional Text }
        , otherwise : Optional Text
        , template : Optional Text
        }
```
<!--Example-->
```dhall
let example =
    {-
      The following example takes the 'cn' attribute and if the attribute matches the first rule,
      will assign whatever follows the "MESHCLOUD-ROLE-" as the value of the meshObject field. If the attribute matches
      the second rule, will assign the value "Platform Operator" and if none of the rules match, assigns the
      value "Workspace Member".
    -}
      { attribute = "cn"
      , postProcessor = None PostProcessor
      , rules =
        [ { regex = "MESHCLOUD-ROLE-(.+)", value = None Text }
        , { regex = "MESHCLOUD-OPERATOR"
          , value = Some "Platform Operator"
          }
        ]
      , template = None Text
      , otherwise = Some "Workspace Member"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

#### LDAP entities to meshObjects transformation

Using AttributeTransformations, you can specify how to transform LDAP entities into meshObjects as follows.

<!--snippet:mesh.identityconnector.ldap.transformConfiguration#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let UserAttributesTransformations =
    {-
      distinguishedNameAttribute:
          The 'distinguished name' attribute key for a user entity in LDAP. This attribute value should match the users
          referred to in the 'members' attribute of the groupAttributesTransformations.

      name, email, firstName, lastName, euid
          For each of these meshUser fields, specify which LDAP attribute should be transformed and assigned to the field.

      tags:
          How to tag the meshUser object.
          Specify the tag keys and for each key, which LDAP attribute should be transformed and assigned as the tag value.
    -}
      { distinguishedNameAttribute : Text
      , name : AttributeTransformation
      , email : AttributeTransformation
      , firstName : AttributeTransformation
      , lastName : AttributeTransformation
      , euid : AttributeTransformation
      , tags : List TagMapping
      }

let GroupAttributesTransformations =
    {-
      distinguishedNameAttribute:
         The 'distinguished name' attribute key for a user entity in LDAP. This attribute value should match the users
         referred to in the 'members' attribute of the groupAttributesTransformations.

      name, ownedByWorkspace, displayName, egid
         For each of these meshUser fields, specify which LDAP attribute should be transformed and assigned to the field.

      tags:
         How to tag the meshUser object.
         Specify the tag keys and for each key, which LDAP attribute should be transformed and assigned as the tag value.
    -}
      { membersAttribute : Text
      , name : AttributeTransformation
      , ownedByWorkspace : AttributeTransformation
      , displayName : AttributeTransformation
      , egid : AttributeTransformation
      , tags : List TagMapping
      }

let GroupBindingAttributesTransformations =
    {-
      roleName:
        Specify which LDAP attribute should be transformed and assigned to the 'roleName' field of the meshWorkspace user group
    -}
      { roleName : AttributeTransformation }

let TransformConfiguration =
    {-
       Specifies how LDAP entities should be transformed into meshObjects.
       There are three types of meshObjects that are imported. meshUsers, meshWorkspaceUserGroups
       and meshWorkspaceGroupBindings.

       includeAllUsers:
         If set to true all meshUsers found in the LDAP are sent to meshstack.
         If set to false only users that have at least one group assignment are sent to meshstack.

       userAttributesTransformations:
         Specifies how an LDAP user entity should be transformed into a meshUser.

       groupAttributesTransformations:
         Specifies how an LDAP group entity should be transformed into a meshWorkspace user group.

        groupBindingAttributesTransformations:
          Specifies how a meshWorkspaceGroupBinding meshObject should be constructed from an LDAP group entity.

    -}
      { includeAllUsers : Bool
      , userAttributesTransformations : UserAttributesTransformations
      , groupAttributesTransformations : GroupAttributesTransformations
      , groupBindingAttributesTransformations :
          GroupBindingAttributesTransformations
      }
```
<!--Example-->
```dhall
let example
    : TransformConfiguration
    = { includeAllUsers = False
      , userAttributesTransformations =
        { distinguishedNameAttribute = "dn"
        , name =
            AttributeTransformation.Static
              { attribute = "cn", postProcessor = None PostProcessor }
        , email =
            AttributeTransformation.Static
              { attribute = "mail", postProcessor = None PostProcessor }
        , firstName =
            AttributeTransformation.Static
              { attribute = "givenName"
              , postProcessor = None PostProcessor
              }
        , lastName =
            AttributeTransformation.Static
              { attribute = "sn", postProcessor = None PostProcessor }
        , euid =
            AttributeTransformation.Static
              { attribute = "cn", postProcessor = None PostProcessor }
        , tags = [] : List TagMapping
        }
      , groupAttributesTransformations =
        { membersAttribute = "member"
        , name =
            AttributeTransformation.Static
              { attribute = "cn"
              , postProcessor = Some PostProcessor.LOWERCASE
              }
        , ownedByWorkspace =
            AttributeTransformation.Regex
              { attribute = "cn"
              , postProcessor = None PostProcessor
              , rules =
                [ { regex = "ADMIN-GROUP-.+"
                  , value = Some "default-partner"
                  }
                , { regex = "GROUP-TEAM-(.+)", value = None Text }
                ]
              , template = None Text
              , otherwise = None Text
              }
        , displayName =
            AttributeTransformation.Static
              { attribute = "cn", postProcessor = None PostProcessor }
        , egid =
            AttributeTransformation.Static
              { attribute = "dn", postProcessor = None PostProcessor }
        , tags =
          [ { tagKey = "environment"
            , transformation =
                AttributeTransformation.Regex
                  { attribute = "cn"
                  , postProcessor = Some PostProcessor.LOWERCASE
                  , rules =
                    [ { regex = ".*-([A-Z]+)", value = None Text } ]
                  , template = Some "mesh-%s"
                  , otherwise = Some "mesh-dev"
                  }
            }
          ]
        }
      , groupBindingAttributesTransformations.roleName
        =
          AttributeTransformation.Regex
            { attribute = "cn"
            , postProcessor = None PostProcessor
            , rules =
              [ { regex = "MESHCLOUD-ADMIN-.*"
                , value = Some "Partner Admin"
                }
              , { regex = "MESHCLOUD-OPERRATOR-.*"
                , value = Some "Platform Operator"
                }
              ]
            , template = None Text
            , otherwise = Some "Workspace Member"
            }
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Transport

The `Transport` configuration contains the parameters needed to call the meshObject API.

<!--snippet:mesh.identityconnector.ldap.transportConfiguration#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let TransportConfiguration =
    {-
      apiUser:
          A meshStack ApiUser used to authenticate against the meshStack API.

      chunkSize:
          The number of meshObjects to synchronize in a single API request.
          For typical meshStack implementations this should be between 10 and 100 objects.

      dryRunOnly:
          If set to true, no real request against the API is made but the API payload will
          be logged instead for debugging purposes as INFO loglevel.

      httpTimeoutSec:
          Timeout in seconds for the HTTP requests send to the meshObject API.
    -}
      { apiUser : ApiUser
      , chunkSize : Natural
      , dryRunOnly : Bool
      , httpTimeoutSec : Natural
      }
```
<!--Example-->
```dhall
let example
    : TransportConfiguration
    = { chunkSize = 100
      , httpTimeoutSec = 300
      , dryRunOnly = False
      , apiUser =
        { username = "identityconnectorapi"
        , password =
            Secret.Raw "EXTERNAL_IDENTITYCONNECTOR_MESH_API_PASSWORD"
        , authorities =
          [ Authority.EXTERNAL_MESH_OBJECT_IMPORT
          , Authority.WORKSPACEOWNER_ASSIGN
          ]
        }
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Combined Configuration

The above configuration models are combined as follows to create the complete configuration.
<!--snippet:mesh.identityconnector.ldapConfiguration#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let LdapConfiguration =
      { source : SourceConfiguration
      , collector : CollectorConfiguration
      , transform : TransformConfiguration
      , transport : TransportConfiguration
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


---


---
id: meshcloud.cost-management
title: Cost Management
---

meshStack provides central [multi-cloud billing](meshstack.billing.md). It can automatically collect usage information from all your cloud platforms and provides central access to cost and usage data.

This information will be consolidated by project, providing an overview of resource usage, including detailed insights into when and how long your resources were running, along with the associated costs.

## Payment Information

A payment method is used to ensure transparent budget management and allocate costs back to the responsible team within your organization. One common example of a payment method is a cost center, which helps categorize and track expenses specific to a team or project. Please find more detailed information about payment methods and how they could be used [here](meshcloud.payment-methods.md).

As the cost and usage data is consolidated per project, payment methods are created in a workspace and assigned per project in meshStack.


## Reviewing Metering Data

### Tenant Usage Reports

![Tenant Usage Reports](assets/tenant-usage-report-example.png)

A tenant usage report provides usage information of one tenant (project representation in a specific platform). This report shows for example all resources like VMs, Storage, Public IPs, etc.

Tenant Usage Reports can be accessed in the tenant control plane under **Financials** > **Usage Reports**.
meshStack generates a tenant usage report for every usage period (monthly).

> meshStack defines **usage period** as starting from the first day of a month to the last day of the month in UTC.

You also have access to a preview report of the current period (e.g. the current month), to always have full control of
your resources and their usage.

From a Tenant Usage Report you can also access a Detailed Report to see every single resource consumption.
That means you can e.g. see whether a resource was running for 3 hours, stopped for 5 hours and then started again for another 6 hours.

Partner accounts can access tenant usage reports for all their assigned meshWorkspaces in the Administration Area via **Platforms** > **Usage Reports**.

Note that unit costs for Azure and GCP services are not supported.
Therefore, the unit costs are not available in the Tenant Usage Reports for those platforms.

### Chargeback Statements

As an analogy from banking, you can think of a chargeback statement like a credit card statement you receive at the end of the month about your usage charged to your payment method.

This chargeback statement is attached to each project and each chargeback is composed of tenant usage reports, which are reports for each tenant. For example, if your project uses both AWS and GCP, you will have one chargeback that combines two tenant usage reports. To check your chargebacks go to **Financials** > **Chargeback Statements** in your workspace. Or as admin go to **Chargeback Statements** page under the FinOps section.


> Chargebacks are finalized at the beginning of each month for the previous usage period with an offset of a few days to allow cloud providers to complete their reports. However, each chargeback only includes data from the month it was used. For example, an October chargeback, that was finalized on November 6th, will only include cloud usage from October.

Chargeback statements consist of **line items** showing the individual booking entries made into a chargeback account.
When booking a tenant usage report, meshStack splits up the report's `netAmount` by seller and product group into
individual entries. This split allows cloud foundation teams to process chargeback for different kinds of usage
like cloud provider cost vs. internal overhead fees.

#### Chargeback Statement Previews 

meshStack also regularly generates a preview of the chargeback statement for the current month, providing real-time cost data. This preview includes all tenant usage reports that meshStack expects to be finalized before the end of the chargeback period. The chargeback statement preview is available on the Chargeback Statements page, where it will be marked with an `Open` status label in the Status column.

> Please note that meshStack currently only generates a preview for the currently active chargeback period.
> A tenant usage report that will finalize in the next chargeback period will not be included in the current period's
> preview.


#### Tags and Payment Methods

The active payment method at the end of the reporting period will appear on the chargeback statement, so your organization's accountant will know whom to send the bill to. Tags associated with this payment method will also be included in the chargeback statement for easier financial management. So chargeback statement for June 2024 will show the tags and payment method that were set as on the last day of the month in this case June 30th. 


> When setting a payment method for the entire year, accountants should ensure that a payment method valid for the year 2022, for example, has an expiration date of January 1, 2023, rather than December 31, 2022. This ensures the payment method remains valid throughout the entire year.

#### Exporting Chargeback Statements

It is possible to do an export from these views by clicking on the "CSV Export" button.
This export will contain the line items (see above) of all the chargeback statements currently in the view.
The line item data is suitable for feeding into chargeback processing, e.g. importing it to an ERP System to transfer
budgets between cost centers.

For customers who export chargeback statements on a monthly basis, the following recommendation applies:
chargeback statements of the previous month should be processed no earlier than one day after the configured finalization date,
at 7 a.m. (German local time). By default, chargeback statements are finalized at the 6th of a month, therefore,
they can be processed starting at the 7th of a month at 7 a.m.
If you are unsure about the configuration of the finalization day of chargebacks in your meshStack, please contact our support team.

Chargeback Statements also contain billing information per line item. Your platform team can 
[configure](meshstack.billing-configuration.md)
which information meshStack should include as billing information in chargeback statements.

> Platform teams typically configure billing information to payment method name, identifier, 
> expiration date and amount as well as any workspace tags, project tags and payment method tags.

You can review this billing information in meshPanel when opening chargeback statement. CSV Exports of chargeback statements also include the configured billing information.

#### Late Bills From Providers

Late bills from providers or any other corrections that arrive after the chargeback statement has been finalized will still be attributed to the month in which the usage occurred. This means that finalized chargebacks will be updated accordingly.

For example, if the September 2024 chargeback statement is finalized on October 6, 2024, but Azure generates an additional expense for September usage on October 10, the September chargeback statement will be updated to reflect this change. The statement will display an "Updated" label in the status column on the Chargeback Statements page. Additionally, the "Generation Date" column will indicate the most recent update to the statement.

![Late Bills](assets/late-bills1.png)

When you open the dedicated chargeback statement, you can also identify what exactly changed by navigating down below the chargeback statement, where you will see the cancelled chargeback statements. You can expand a cancelled chargeback statement and compare it with the current one to see which changes were applied.

![Late Bills](assets/late-bills2.png)

Transparency around updates in finalized chargeback statements in CSV exports and API will follow soon. Currently only the latest data is reflected in CSV export and via the API.

#### Retroactive Payment Methods

The following only applies, if payment methods are [configured](meshstack.billing-configuration.md#available-metadata-keys) to be required for chargeback statements (you can request this via [meshcloud support](mailto:support@meshcloud.io)). If a project doesn’t have a payment method because the previous one expired and no new method has been set, chargeback statements will not be generated. Tenant usage reports, however, will still be created and finalized without a payment method.
When a new payment method is added, the system retroactively generates chargeback statements for all missing months, applying the newly added payment method. Tenant usage reports for the affected months are updated to include the new payment method, resulting in updated labels for these reports. Additionally, via the meshTenantUsageReport API, you can check the updated reports by using the finalizedAfter parameter with the date when the payment method expired.

**Example:**

- Let’s say it’s February 2025, and your payment method for 2024 expired. If you haven’t added a new one yet, no chargeback statements will be generated for January and February 2025, but tenant usage reports will still be available without an associated payment method.
- Now, imagine you add a new payment method at the end of March 2025. In this case, the system will regenerate tenant usage reports and generate chargeback statements for January, February, and March 2025, applying the new payment method to those months.
- The regenerated tenant usage reports and chargeback statements with the added payment method will display an updated label under the "Status" column on the chargeback and tenant usage reports pages. You can also identify these updates via the meshTenantUsageReport API by specifying the finalizedAfter parameter with the date when the payment method expired.


---


---
id: meshstack.kubernetes.metering
title: Metering
---

meshStack supports metering and billing for the most common types of Kubernetes resources.
Metering is based on periodically sampling the state of Kubernetes resources from the platform's API.

> The accuracy of sampling-based metering naturally depends on the sampling interval. While insufficient for
> supporting a per-second billing model, it works very well for billing resources on a per-hour billing model.

## Prerequisites

- The "meshfed-metering" service account must be configured as described [here](./meshstack.kubernetes.index.md#metering)
- CPU and memory limits have to be defined for all containers, as metering is currently based on these limits
- Kubernetes APIs are accessible by meshStack metering collector components

## Supported Resources

Resources with the following traits are addressable in the [Product Catalog](meshstack.billing-configuration.md#defining-a-custom-product-catalog). Platform Operators can use the traits of these resources to define fine-granular product and pricing rules.

### Pod

<!--snippet:mesh.kraken.productcatalog.traits.kubernetes.pod#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let PodResourceTraits =
    {-
      milliCpu:
        Configured total CPU limit of all containers in this Pod, in milli CPU (1/1000 of a CPU).
        The primitive usage quantity unit in product catalog entries is 'mCPU', e.g. '2500 mCPU'.

      ramMb:
        Configured total RAM limit of all containers in this Pod, in MiB.
        The primitive usage quantity unit in product catalog entries is 'MiBy', e.g. '1024 MiBy'.

      status:
        Status phase of this pod. See https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/
    -}
      { milliCpu : Integer, ramMb : Integer, status : Text }
```
<!--Example-->
```dhall
let example
    : PodResourceTraits
    = { milliCpu = +2500, ramMb = +1024, status = "Running" }
```
<!--END_DOCUSAURUS_CODE_TABS-->

### PersistentVolumeClaim
<!--snippet:mesh.kraken.productcatalog.traits.kubernetes.persistentvolumeclaim#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let PersistentVolumeClaimResourceTraits =
    {-
      status:
        Status phase of this PersistentVolumeClaim. See https://docs.openshift.com/container-platform/4.1/storage/understanding-persistent-storage.html#pv-phase_understanding-persistent-storage

      storageClassName:
        Name of the Storage Class used for this volume.

      storageMb:
        Total Capacity of the Volume, in MiB.
    -}
      { status : Text, storageClassName : Text, storageMb : Integer }
```
<!--Example-->
```dhall
let example
    : PersistentVolumeClaimResourceTraits
    = { status = "Bound", storageClassName = "slow", storageMb = +5120 }
```
<!--END_DOCUSAURUS_CODE_TABS-->

---


---
id: apis.index
title: API Docs
---

meshStack offers a suite of APIs designed for seamless integration with third-party applications. These APIs enable the incorporation of meshStack's capabilities into existing company processes provided by other applications.

## [API Docs](/api/index.html)

To explore how to read and manage meshObjects using meshStack's REST API, please refer to our [API documentation](/api/index.html). You can work with various types of objects, such as:

- Workspaces
- Projects
- Tenants
- Building Blocks

## [Metering API Docs](/billing-api/index.html)

For accessing chargeback statements and managing other financial data through a REST API, check out our [Metering API Documentation](/billing-api/index.html). 
Here, you'll find detailed information on various types of data, including:

- TenantUsageReports
- Chargebacks
- ResourceUsageReports
- Cloud Resources


---


---
id: meshstack.OSBServicesPlatform.development
title: OSB Services Platform Development
---

> Only users with the role [Workspace Manager](meshcloud.workspace.md#assign-meshworkspace-roles) or [Workspace Owner](meshcloud.workspace.md#assign-meshworkspace-roles) have access to the administrative functionality described in this section.

You can provide your own OSB services (e.g. databases, message brokers, filesystems, etc) via the **Service Brokers** tab and **Service Brocker** subtab on your Wrokspace Control Plane. This requires you have a running Service Broker, an application that manages these services by the means of [Open Service Broker API](https://www.openservicebrokerapi.org/). Services provided by you can then be consumed by other users in the meshPanel. A short overview and some specifics that should be considered when writing a Service Broker for the OSB Services Platform are described [here](marketplace.service-instances.md). Also via **Instances** subtab, you get to the maintenance area for your service brokers. You can register and publish your Service Broker. [Analytics](#debugging-your-service-broker) screens that provide you with Usage and Logging Data are also available.


meshStack supports OSB Version 2.14 and is on the way to support OSB 2.15.


## Register your Service Broker

Registering your Service Broker does not publish your Service Broker directly for all users. Initially only your meshWorkspace will have access to this Service Broker. We call this type of Service Broker a **private Service Broker**. It allows you to test and develop your Service Broker. A new OSB Services Platform for your Workspace will be available for your [projects](meshcloud.project.md#adding-meshtenants) after registering a Service Broker. When you select it for a project, your own OSB Services Platform will be available on the project.


1. Open **Service Brocker** on your Workspace control plane
2. Navigate to the **Service Brokers** subtab.
3. Click `+ Register` in the upper right corner.
[overview OSB](assets/marketplace/osb-overview.png)


The following information must be provided for the registration:

- **Name**: Give a name to the service broker you want to register. It is mainly used as a display name for your administrative Screens.
- **Identifier**: Globally unique, immutable identifier for your Service Broker, used in API requests and logs by meshStack. Choose wisely as *this identifier cannot be changed later* on. We advise to use meaningful and expressive identifiers.
- **Endpoint**: Root URL to your Service Broker's API endpoint. It must start with "http(s)://". Below this API endpoint the **/v2/catalog** endpoint must be available, as described in the [Open Service Broker API](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md#catalog-management).
- **Basic Auth Username**: Communication between the OSB Services Platform and your Service Broker is secured via HTTP Basic Auth. Therefore username and password have to be defined here, so the OSB Services Platform can authenticate successfully to your Service Broker. Enter the username for HTTP Basic Auth here. The username can be changed at any time.
- **Basic Auth Password**: Enter the password for your HTTP Basic Auth. A set password will never be shown to you again. This password will be stored encrypted in the database. You can set a new password at any time. No restrictions regarding the characters used in your password are applied. Please be sure to always use a secure password!
- **Development Mode**: As all communication should be secured via SSL by using an https endpoint, it might be too complicated to provide a valid certificate during development. Therefore SSL validation of your Service Broker's certificate can be disabled via this **Development Mode**. This is only possible for the Development Service Broker only your meshWorkspace has access to. [Published Service Brokers](#publish-your-service-broker) always need a valid certificate!

### Edit Service Broker Registrations

Data entered when [registering](#register-your-service-broker) your service broker can also be edited afterwards. Only the identifier cannot be changed anymore.

### Refresh Service Broker Catalog

Service Brokers provide the catalog of all available service according to the [Open Service Broker API](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md#catalog-management). The OSB Services Platform periodically calls the catalog endpoint and updates the available services internally. To force this refresh of your Service Broker's catalog, you can click the **Refresh Catalog** button in the list of your Service Brokers.

## Publish your Service Broker

As soon as your Service Broker is production-ready, you can add  it to the OSB Services Platform and it will be shown on Marketplace Catalog, so all users of meshStack can use it. You should provide a new deployment of your Service Broker in order to publish it. Your private service broker configuration will remain untouched when publishing the service broker. The private Service Broker will still be available for your meshWorkspace.

To publish your Service Broker, click the **Publish Service Broker** button for the according Service Broker.

You can choose which OSB Services Platform you want to publish your Service Broker to. For many services, like databases, storage, etc, it makes sense to provide the Service Broker in the same Location the applications consuming the service are running. This enables best latency, security and performance for using your services. But there are also other Service Brokers like a service that provides user credentials for using an internet proxy, which are independent of the Location. In these cases the Service Broker can simply be published to the **Global** Location.

Location-based Service Brokers should be running independently of each other in all Locations they are published to. Therefore different endpoints and credentials have to be configured for every Location. Endpoints of published Service Brokers must always use an **https** endpoint, because that's the way how security can be established for the communication between the OSB Services Platform and your Service Broker.

When you publish your Service Broker it won't be available in the OSB Services Platform. A Partner Admin has to [approve](administration.service-brokers.md#approve-service-broker) your Service Broker first.

### How to publish your Service Broker

Please execute the following steps:

1. Open the Servive Broker controls on the meshWorkspace level.
2. Navigate to "Service Brokers".
3. Choose "Published Service Brokers" for the Service Broker you want to publish.

   ![image](https://user-images.githubusercontent.com/67903933/167908168-a8c7ff34-d3cd-40c4-b731-10c5c798239d.png)

4. Now add the configuration and the Service Broker by pressing "+".

   ![image](https://user-images.githubusercontent.com/67903933/167908972-1df80355-7982-4f39-8abc-97875cd4ff07.png)

### Refresh Catalog of Published Service Broker

Like for your private Service Broker, you can also actively [refresh the catalog](#refresh-service-broker-catalog) of your published Service Broker. You can click on **Refresh Catalog** button in the Publishing List of your Service Broker.

The Analytics functionality for Service Owners is available to Workspace Managers, who already [registered a Service Broker](meshstack.meshmarketplace.development.md#register-your-service-broker).

## Debugging your Service Broker

### Reviewing failed Service Instances

From the [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace), you can access an overview of all failed service instances of your service brokers under the "Instances" sub-page which can be found under the "Service Broker" tab. This allows a quick error analysis of failed service broker calls. The list shows you an overview about all failed Service Instances with the specific local id, name, service plan and the last operation.

### Service Communication Logs

Especially when an error occurs during a service broker call, detailed information about the request that was made from the OSB Services Platform to the service broker helps in analyzing the reason why a call failed. But the communication logs are not only available in error cases, they are available for all requests that were made from the OSB Services Platform to the Service Broker. Instead of implementing a detailed request and response logging in every service broker, the OSB Services Platform provides this information for all service brokers.

All relevant information like the request date and the type of operation that was executed, all request and response headers as well as the body of the request and in case of an error also the response from the service broker, are available. The duration of the call and information about the used Service Plan and [Service Instance](marketplace.service-instances.md) are also available. This information, combined with the application logs of the service broker should provide all information for a successful error analysis.

The communication logs are available for [private](meshstack.meshmarketplace.development.md#register-your-service-broker) and [published](meshstack.meshmarketplace.development.md#publish-your-service-broker) service brokers via the **Communication Logs** button in the according service broker list. In case of private service brokers the communication logs can provide you with helpful insights during the development phase or the OSB Services Platform integration phase of your service broker.

A searchable overview of all communication logs is the starting point for analyzing communication logs. When more details about a specific log is needed, the **info** icon in the list of logs provides you with all details that are available to a specific call that was made.

### Searching the Communication Logs

Searching the communication logs to e.g. find a specific issue that was reported or to have a look at a specific call that was made is an essential feature of the communication logs. The search is executed automatically while entering your search criteria. You can search by the following criteria:

- **Request Date**: When e.g. a user reported that an issue occurred at 10 o'clock at a specific day, you can quickly find the related communication log by searching for the request date. The date you search for will be interpreted as the latest request date to find. So you will retrieve all communication logs before this date. As the ordering of the list is descending, the communication log that is closest to the requested date will appear at the top of the list. The date must be entered in format yyyy-MM-dd HH:mm:ss (e.g. 2019-01-01 10:00:00). Enter the date in your local timezone here.
- **Operation Type**: You can filter by the different operation types, that are defined by the [OSB specification](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md). A dropdown with the different operation types like FETCH_CATALOG or PROVISION_INSTANCE is available for selection.
- **Response Code**: The response code (HTTP Status Code) is an often used filter criteria as you can search e.g. for all error responses by entering ">399", which will return all requests that failed with a client (4xx) or server (5xx) HTTP response code. But you can also search for a specific response codes like "403".
- **Service Plan**: When you know that there was an issue with a specific service plan, you can search for all service plan related requests by entering the id of the service plan, that you defined in your [service broker catalog](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md#catalog-management).
- **Service Instance**: When you know that an error occurred for a specific [Service Instance](marketplace.service-instances.md), you can search for all related logs by entering the id of the service instance.


## Deletion of Service Brokers

The deletion of a Service Broker is only allowed if it has not been [published](#publish-your-service-broker) and [approved](administration.service-brokers.md#approve-service-broker). As soon as an approved Service Broker exists users can create Service Instances from your services. The deletion of a Service Broker could affect productive data of other users and is therefore not possible.

Unpublished, unapproved Service Brokers can be deleted from the list of Service Brokers via the **trash** button. A safety dialogue pops up, where you have to enter the name of the Service Broker for confirmation. The deletion will only delete the Service Broker in the meshStack. **No deprovisioning** will be triggered in the Service Broker! You have to clean up existing Service Instances in your Service Broker by yourself!

After you have published your Service Broker you can also revoke this publishing by clicking the **trash** icon in the Publishing list of your Service Broker as long as it has not been approved.


## Deactivation of Service Brokers

If a Service Broker has been [published](#publish-your-service-broker) and [approved](administration.service-brokers.md#approve-service-broker) it can no longer be deleted because there may already be provisioned service instances. Instead, a published Service Broker can be **deactivated**. Deactivating a Service Broker does not delete any service instances or bindings but ensures that no new service instances can be created. OSB Services platform will no longer show any services offered by this broker and if the Service Broker uses a dashboard client it will no longer be available.

> Deactivating a Service Broker is permanent and irreversible!


---


---
id: meshcloud.profile
title: User Account
---
The following section covers all the relevant details regarding your meshStack user account.

## Account Creation

In most meshcloud installations an external identity provider (IdP) is available and configured for authentication in meshcloud.
That way users and their credentials already exist and can be used to login to meshPanel. If an IdP is not available, the registration of new users is enabled in the meshIdB. Before being able to create a new meshWorkspace, users have to create their user in meshIdB first.

When a user already exists, he can create a new account (meshWorkspace) after login. Click "Create meshWorkspace" and fill out the form.

Submit the form to create an account.

You will receive an email to confirm your account and after that you can start using your account.

## Login

Logging in to your federated meshFed SSO account can be done by:

1. Navigate to your meshPanel.
2. In the upper right corner or inside the home screen. Click on the **Login** link.
3. You will be redirected to the meshFed SSO login.
4. Enter your credentials (in most cases your known company credentials, or the ones you created during registration).
5. After a successful login, you will be automatically redirected to the meshPanel project overview.

## Change Password

If a company IdP is used for authentication, you have to contact your IT to centrally change your credentials. If no IdP is available
and the user account was registered via the meshIdB, you can access the "Forgot Password" from the login screen.

## Profile

Navigate to the **Profile** page via the navigation on the top right of the meshPanel.

### Information

Here you can find all your personal information stored in the meshStack. You can also expand an area on the bottom of the page, to see a list of related systems, that also persist your personal information (e.g. cloud platforms). In general meshStack tries to store as little of your personal information as possible in the different systems.

### Platform Notification Subscriptions

Here you can also manage your subscriptions if you wish to receive emails for any [platform notifications](administration.platforms.md).
While all platform notifications are also shown in the meshPanel (i.e. control planes) it can be useful to subscribe to notifications for specific platforms.
Notifications have a severity level (info > warning > critical) and you can select to only receive notifications above a certain level, i.e. selecting a minimum severity of info will also include warnings and critical notifications while selecting warning will *only* include warnings and critical notifications.
If you have important applications running in a specific platform you might be interested in notifications with a severity level of at least warning, so you'd be informed about service disruptions, platform outages, etc.


---


---
id: meshstack.OSB.dashboard-tutorial
title: "Tutorial: Dashboards"
---

> **Important! This functionality is only available on the meshStack Enterprise plan**
> If you are on a SaaS plan and you want to replicate Authorization information to another
> system, please consider using [Azure Active Directory Permission Replication](./meshstack.meshmarketplace.index.md#aad-permission-replication)
> or build your own integration using the [meshObject API](./api/).

Service Brokers can offer dashboards for their service instances. Users can use the dashboard to interact with the service, e.g. for monitoring and service configuration. This tutorial explains how to implement a dashboard for the OSB Services Platform

## Overview of the SSO Flow

Since only the OSB Services Platform knows which users may have access to a specific service instance, Service Broker Dashboards must integrate with the OSB Services Platform’s SSO provider (meshIdB). This section describes the OAuth code flow, that must be used by the Service Broker to provide a Dashboard integrated with meshStack Single-Sign-On (SSO).

### 1. Create restricted client in meshIdB for Service Broker

The platform (OSB Services) retrieves the desired SSO OAuth client information from the Service Broker when retrieving the service catalog (see figure below). The OSB Services Platform then proceeds with creating the client in meshIdB, if it doesn’t exist yet.

![OSB Marketplace integration](assets/osb-dashboard-1.png)

Service Brokers should be aware that there’s only a single, global namespace for dashboard client ids. It is recommended that Services use a client id  prefixed with a DNS name or other suitable identifier to ensure global uniqueness.

### 2. The OAuth flow + Authorization

When the user accesses the dashboard, the dashboard has to follow the auth flow as follows:

![OSB Marketplace integration](assets/osb-dashboard-2.png)

Service Brokers need to discover the URLs for initiating the OAuth flow and for retrieving the permissions on the service instance from OSB Services Platfrom.

## Implementing a dashboard

The OSB API spec does not specify all necessary steps to achieve properly secured dashboard integration with a OSB Services Platform. This section describes how Service Brokers can discover user permissions and the URLs necessary for OAuth integration with OSB Services Platform specifically, leveraging the [OSB API Profile](./meshstack.meshmarketplace.profile.md).

### Permissions on Service Instance Level

The authorization shall be done per service instance for every user who accesses the dashboard. This means that only users that are assigned to the project in the OSB Services Platform where the service instance was created, or users in the projects this service instance [is shared with](marketplace.service-instances.md#share-service-instance), shall have access to its dashboard. Therefore the OSB Services Platform provides a REST endpoint to retrieve the information whether the current user is allowed to access a specific service instance. This URL is submitted in the context object of a provision request as the property `permission_url`:

```json
{
  "permission_url": "https://{mesh-hostname}/serviceInstances/c48d065b-a123-4a1e-8021-2965928d022d/permissions",
  "...": "..."
}
```

When requesting the URL, the access token retrieved via the described OAuth flow, must be submitted in the Authorization header:

```yml
Authorization: Bearer eyHKJDSA57...
```

The response of this request contains a simple json object with a permission field, that can currently have the values `NONE` and `USER`.

```json
{
  "permission" : "USER"
}
```

If `NONE` is returned, the access to the dashboard must be denied for the user. If `USER` is returned, access must be granted. If the service instance id is not known by the OSB Services Platform (meshMarketplace), HTTP Status 404 is returned.

### Initiating the OAuth Flow

There are two ways for Service Brokers to initiate the OAuth flow for SSO. Implementers can choose the way that’s more convenient for them.

#### 1. Use OAuth URLs available in the context

To simplify the OAuth flow for the service brokers and to guarantee, that the service broker uses the same IdB as the platform, the `auth_url` is part of the context when provisioning a service instance.

```json
{
  "auth_url":"https://{mesh-hostname}/auth/realms/meshfed/protocol/openid-connect/auth?client_id=my-service-client-id&response_type=code&redirect_uri={redirect_uri}&nonce={nonce}&state={state}",
  "...": "..."
}
```

This URL is a template. The `redirect_uri` must be set by the Service Broker (to redirect to a specific URI containing the service instance id or similar). The random parameters nonce and state have to be generated and replaced by the service broker (see OpenID documentation for this.)
For the OAuth flow, a token endpoint is required too. It is a static link and the request must be built as described in the OpenId documentation.

```json
{
  "token_url": "https://{mesh-hostname}/auth/realms/meshfed/protocol/openid-connect/token",
  "...": "..."
}
```

#### 2. Use X-Api-Info-Location header as in Cloud Foundry

For being compatible with Cloud Foundry and making integration easy for Service Brokers, that are already using the Cloud Foundry SSO, an `X-Api-Info-Location` header is submitted on every request the meshMarketplace executes to the Service Broker.

The header contains an URL to retrieve general information like the auth URL.

```yml
X-Api-Info-Location: http://{mesh-hostname}/info
```

The response when calling this URL has the following content:

```json
{
  "authorization_endpoint": "https://{mesh-hostname}/auth/realms/meshfed/protocol/openid-connect/auth",
  "token_endpoint": "https://{mesh-hostname}/auth/realms/meshfed/protocol/openid-connect/token"
}
```


---


---
id: meshstack.how-to-API-keys
title: How to use scoped API keys
---
You can issue workspace scoped API Keys via the admin or workspace area. Those API keys authorize only for requests towards the meshObject API in scope of the respective workspace. Step by step we will enable the individual endpoints of the meshObject API to allow for more scoped requests.

How to set it up:

1. Open the respective workspace and go to Workspace Access → API Keys. 
2. Issue a new API key by clicking "create API key" and provide a name and an authorization scope.
3. Make sure to save the secret and key ID securely to make the request
4. Issue an API call towards the backend to receive a short-lived bearer token e.g. /api/login (Provide the following keys in the body of the request in the x-www-form-urlencoded format):
   
    - client_id: This is the key ID
    - client_secret: This is the key secret provided to you
    - grant_type is always specified as: client_credentials
      
5. Use the token in further request by specifying it in the authorization header

If you want to disable the creation of API keys in self service via the workspace area please reach out to support@meshcloud.io. By default this functionality is enabled. 


---


---
id: meshstack.gcp.landing-zones
title: Landing Zones
---

In GCP, a [Landing Zone](./meshcloud.landing-zones.md) is defined via folder the project will be assigned to. Policies can be applied
to these folders.

The [Landing Zone](./meshcloud.landing-zones.md) can be configured in the `Administration` section. If a project is selected to have a GCP tenant a Landing Zone must be selected by the user. By choosing a landing zone, platform specific configuration can be set (in this case for GCP). The options for GCP are:

## Resource Manager Folder Id

All newly created meshProjects get their corresponding GCP project assigned to this [Folder](https://cloud.google.com/resource-manager/docs/creating-managing-folders) in the [Organization Resource Hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy).

Folders and the application of organization constrains on the projects contained in them through the use of [Organization Policy Service](https://cloud.google.com/resource-manager/docs/organization-policy/overview) can be setup outside of meshcloud by a Platform Operator.

## Template Config URL

You can define an URL pointing to a template configuration for the Deployment Manager. These template, will be fetched and deployed during the execution process. These can be used to setup projects with certain pre-sets of resources.

In contrast to the official GCP documentation you **must leave out** the imports in your config file. It should have the following format:

```yaml
resources:
  - name: enable_api
    type: gs://likvid-gdm-templates/single_vm2/enable_api.jinja
  - name: vm_template
    type: gs://likvid-gdm-templates/single_vm2/vm_template.py
    properties:
      zone: europe-west1-b
```

> The maximum filesize currently is 1MB please [contact us](mailto:support@meshcloud.io) if you need support for bigger template configurations.

GCP uses a built-in service account called [Google APIs Service Agent](https://cloud.google.com/iam/docs/service-accounts#google-managed) to execute GDM templates.
This service account needs to have permission to access the bucket storing the GDM template. It's therefore necessairy to give the meshfed service account the following permissions on the storage bucket:

```text
storage.buckets.setIamPolicy
storage.buckets.getIamPolicy
storage.objects.get
storage.objects.list
storage.buckets.list
storage.buckets.get
```

We suggest to create a custom role containing these permissions.

As part of replication, meshStack will grant this permission to the "Google APIs Service Agent" service account. Reviewing the IAM permission of the bucket, Platform Operators will thus notice additional assignments of the `roles/storage.objectViewer` role to service accounts of the form `<PROJECT_ID>@cloudservices.gserviceaccount.com`.

The name of the template deployment is `template-<CUSTOMER_IDENTIFER>-<PROJECT_IDENTIFIER>` cut to a maximum length of 63 chars.

If the URL is changed or the underlying template updated the projects will automatically get an update of the template. Please make sure that the templates can be deployed without errors beforehand.

Please note that you probably want to enable all the necessary APIs on the GCP project in order to allow deployment of this template. Templates can enable APIs via the virtual template type `deploymentmanager.v2.virtual.enableService`. For more information see the official [Deployment Manager docs](https://cloud.google.com/deployment-manager/docs/configuration/supported-resource-types).

### Available Google Deployment Manager Properties

The properties of the provided configuration file will be expanded with properties from meshcloud and these can be used inside the template itself. The following properties are provided:

| Template Property  | Description                                                                   |
|--------------------| :---------------------------------------------------------------------------- |
| customerIdentifier | Workspace Identifier                                                          |
| tagCostCenter      | ID of the CostCenter defined for this meshProject.                            |
| projectIdentifier  | The project identifier                                                        |
| projectId          | The ID of the GCP project associated with this meshProject                    |
| tagCostCenter      | Example for a [metadata tag](./meshstack.metadata-tags.md) named `costCenter` |

As the example `tagCostCenter` in the above table indicates, any payment settings, project tags or workspace tags are also provided to the template.
The following modifications are applied to metdata tag keys by meshstack before making them available as properties:

- Parameters are prefixed with `tag`
- First letter of metadata tag key is capitalized

In the example, a metadata tag named `costCenter` would be provided as a property with name `tagCostCenter`.
See [metadata tags](./meshstack.metadata-tags.md) for more information.

> If you are planning on converting any of the template properties into GCP labels, please be aware of the limits and requirements
> that GCP has [described in their docs](https://cloud.google.com/compute/docs/labeling-resources#restrictions).
>
> Key takeaways here:
>
> - A resource can have a maximum of 64 labels
> - Keys and values can only contain lowercase letters, numeric characters, underscores and hyphens.
> - Label keys must start with a lowercase letter

## meshRole to Platform Role Mapping

The meshProject roles must be mapped to GCP specific roles. You are able to control this mapping with a Landing Zone setting. You can specifiy these mappings by adding role mappings and supplying a GCP Role. You can both use custom roles which look like `organizations/123123123123/roles/meshstack.project_developer` or predifined GCP roles like `roles/editor`.

You can specify multiple GCP roles for each meshRole. All defined GCP roles are added to the user group. Additional roles can be managed for the user group outside of meshStack. meshStack does not remove roles from a user group. It only adds the mapped roles specified in the landing zone definition.

## Cloud Function URL

If you specify a Cloud Function URL this function will get invoked during a project replication. This can happen several times and thus your function invocation must be idempotent. The function gets variables provided via HTTP headers similar to the [Azure Function](./meshstack.azure.landing-zones.md#azure-function).

Please make sure the GCP service user of the replicator is allowed to access this function.

Please review the [meshStack Landing Zone Http Header interface](./meshstack.metadata-tags.md#http-header-interface) for metadata meshStack makes available to Azure Functions.

In addition to the headers referenced above, meshStack provides the following GCP-specific HTTP headers:

| HTTP Header Name  | Description                                                |
| ----------------- | :--------------------------------------------------------- |
| x-mesh-project-id | The ID of the GCP project associated with this meshProject |


---


---
id: meshcloud.tenant
title: meshTenant
---

meshTenants are the representation of a [meshProject](./meshcloud.project.md) in a [meshPlatform](./meshcloud.platforms.md).
meshTenants are isolated cloud environments protected by multi-tenant mechanisms of the cloud platform. The following types of meshTenants are supported by meshStack:

- Accounts in AWS
- Subscriptions in Microsoft Azure
- Projects in Google Cloud
- Namespaces in Kubernetes & OpenShift
- Projects in OpenStack
- Spaces in CloudFoundry

## Using your Tenant

To use your tenant, open the tenant control plane by going to the [project control plane](./meshcloud.project.md#manage-meshprojects) and opening one of its tenants.

![Tenant Control Plane](assets/tenants/control-plane.png)

In the tenant control plane you can log in to the cloud platform, manage your Building Blocks, view costs associated to the tenant and book additional services for the tenant from the [marketplace](./marketplace.index.md).

## Replication and Reconciliation

meshStack combines the meshProject configuration (managed in self-service by the [meshWorkspace](./meshcloud.workspace.md) admins), the [Landing Zone](./meshcloud.landing-zones.md) and [meshPlatform](./meshcloud.platforms.md) configuration (managed by the platform operator) to compute a **desired state** for each meshTenant. For private cloud platforms this may include applying certain [quotas](./meshcloud.tenant-quota.md) to your meshTenant.

meshStack continuously reconciles the **actual state** of meshTenants with their desired state. This process is called replication and ensures that all cloud tenants governed by meshStack are in a known and expected state.

## Metadata Tags

meshStack automatically derives [metadata tags](./meshcloud.metadata-tags.md) for meshTenants based on the metadata tags set on the meshProject, the [payment method](./meshcloud.payment-methods.md) configured on the meshProject and
the meshWorkspace it belongs to.

Any update to tenant metadata (e.g. a change in payment method) triggers a new meshTenant reconciliation cycle.

## Delete a meshTenant

> Only users with the role [Workspace Manager](meshcloud.workspace.md#assign-meshworkspace-roles) or [Workspace Owner](meshcloud.workspace.md#assign-meshworkspace-roles) have access to the administrative functionality described in this section.

If you would like to delete a meshTenant that is no longer used, open the corresponding meshTenant and navigate to **Deletion**.

> If you delete the entire meshProject [submitted for deletion](meshcloud.project.md#delete-a-meshproject) instead,
> the meshProject will be deleted once all meshTenants within the meshProject have been deleted successfully.

When you delete a tenant it will be removed from the project view and submitted to the tenant deletion queue. You will also immediately loose access to the tenant in the cloud platform.
You can review the tenant deletion queue on the "Deletion Queue" tab from your Workspace view.

Tenant deletion always requires approval. It is possible that an operator will reject the deletion of a tenant, in which case it will be reinstantiated into the project.

Operators can configure how meshStack processes tenants on the deletion queue per landing zone.
meshStack will update the status of your tenant in the Deletion Queue accordingly and send notifications to keep you updated about deletion progress.

> If you are a platform operator and want to learn more about the approval and deletion workflows in the Admin Area, read more [here](./administration.delete-tenants.md)

## Reuse of an existing tenant

meshStack does not support reusing platform tenants. Imagine a tenant has been deleted, but the underlying platform tenant has not been deleted by the platform operator. You may think of reusing this tenant in another project. This is not supported by meshStack and will lead to an error during import. The reason for this current limitation is handling the reuse of tenants in the metering system. Having the same tenant being used by different projects (perhaps even within the same month), makes it hard or in some cases even impossible to decide which project to charge for this tenant. Therefore reusing platform tenants is currently not supported by meshStack.

> Read best practices on building a solid tenant management in your cloud foundation on the [cloud foundation website](https://cloudfoundation.org/maturity-model/tenant-management/).

## Deprovisioning / Deleting Tenants

Before a meshTenant can be [automatically deleted](meshcloud.tenant.md#automatic-deletion) by meshStack, users must make sure that no resources are left in the cloud platform tenants. This is a security measure as we do not want to accidentally delete a tenant with resources still used from the cloud platforms. We therefore check the absence of resources prior of tenant deletion and upon presence of a resource we stop the deprovisioning process.

This security check is currently supported for the platforms:

- CloudFoundry
- OpenStack
- OSB Services

> Since this security measure is very important, fully automated deprovisioning of projects from other platforms is currently not supported and requires [manual intervention](administration.projects.md#delete-tenants). We are looking into extending support for further automating this process in the future.


---


---
id: meshstack.how-to.create-project
title: How to create a meshProject
---

If you are not familiar with what a meshProject is, please check the [official meshcloud documentation](meshcloud.project.md).

## Prerequisites

- Permissions: Your user needs either the Workspace Manager or Workspace Owner role in the meshWorkspace for which you want to create the meshProject.
- Valid Payment Method: Your meshWorkspace has a payment method that is not expired.

## Step-by-Step Guide

> Check out the [video tutorial](https://www.youtube.com/watch?v=NYQa-WVtfDM) version of this guide.

 1. Make sure you are in the meshWorkspace the new meshProject will belong to. Do this by checking the drop-down in the upper-left corner.
    ![Select meshWorkspace in the upper left corner](./assets/project-creation/choose-workspace.png "Pick meshWorkspace")
 2. Start the meshProject creation by clicking the `Create Project` button, either in the navigation bar at the top (A) or
    in the workspace control plane under **Projects** > **Overview** (B).
    ![Start meshProject Creation](./assets/project-creation/start-project-creation.png "Start Project Creation")
    A project creation wizard will appear.
    ![Project Creation Wizard](./assets/project-creation/open-project-wizard.png "Project Creation Wizard")
 3. First you have to give your project a name. The best practice is to use the name of the application, product,
    or project plus the environment type. The identifier is automatically generated but can be modified by you.
    We recommend to keep the identifier as it is.
    ![General Information](./assets/project-creation/choose-project-name.png "Naming")
 4. The lower part of the first page allows you to tag your meshProject. Some tags are required to be specified by you. You can recognize the required tags by the red line on the left side of the input field. Some of the tags you choose might have an impact on the landing zone you are allowed to choose. This happens if there is a policy that might restrict the usage. Click next![Tags](./assets/project-creation/choose-tags.png "Tags")
 5. Select the payment method provided via the meshWorkspace and click Next.
 6. Now we come to the most important part. Choose at least one of the platforms for your future meshProject.
    If you want to have for example an AWS account, pick AWS. Click next.
    ![Select Platform](./assets/project-creation/choose-platform.png "Select Platform")
 7. We now have to configure any possible platform configuration. For public cloud platforms & Kubernetes-based platforms
    this means picking a landing zone (A).
    Additionally, for some landing zones there might be services included as part of the landing zone (B). These can be
    either required, meaning you have to book them, or they can be optional, which means you can consider booking the
    service, but you can also decide to skip it. If you would like to have multiple instances of a service, you can
    click on 'Add another one' and another instance of the service will be included.
    Once all values are filled in, a green box should appear at the bottom,
    and you will be able to continue to the next step by clicking Next.
    ![Landing Zone & Services](./assets/project-creation/choose-lz-and-services.png "Landing Zone & Services")
 8. Now add any team members who should have access to the new meshProject and the corresponding cloud tenants.
    You can also add yourself by clicking the `Add myself` button. The access of your team members to the project can be
    changed at any point in the project control plane under **Project Access** > **Current Access**. Click Next to continue
    ![Add Users and Groups](./assets/project-creation/add-yourself.png "Add Users and Groups")
 9. At last, a 'Review & Create' page will be shown. You can verify here whether your about-to-be-created project is
    looking as you want it to be. If everything looks good, hit 'Create Project' and your project will be created!
10. You will land on the project control plane of your new project. It might take a while to replicate the tenant(s) of
    your project. You can check the replication status of your tenant(s) in the project control plane.
    ![Check Replication Status](./assets/project-creation/replication-status.png "Check Replication Status")

### Congratulations, you are done


---


---
id: meshstack.replication-configuration
title: Replication Configuration
---

Certain aspects of the replication configuration are similiar accross all platforms. This keeps complexity low and makes it easier to setup a meshStack installation. The concepts are described in this section.

## String Templating

Some properties for the different platforms allow you to use string templates to control the creation of e.g. Azure Subscription names or creates user group names in the target platform.
These string pattern work like the following example:

```text
#{workspaceIdentifier}.#{projectIdentifier:%.7s}-test.#{tenantPlatformNumber:%03d}
```

The engine will substitute `#{PLACEHOLDER}` with the actual contextual value (see table below). Optionally you can provide a `String.format()` pattern after the `:` which will be used to transform the value provided for the placeholder. Consider a case where the workspace ID is 'my-workspace', the project ID is 'my-project', and the tenantPlatformNumber is 4. In the example above `%.7s` will use the first seven characters of the project identifier of the current project and pattern `%03d` applied to 4 will produce 004. The above string would evaluate into this:

```text
my-workspace.my-proj-test.004
```

For further details on the patterns supported by `String.format()`, please consult the Java official documentation.

The template engine allows you to use the following placeholders if not described otherwise in the corresponding documentation:

| Placeholder          | Type   | Description                                                                                                                            |
| -------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| workspaceIdentifier  | string | Workspace Identifier                                                                                                                   |
| projectIdentifier    | string | Project Identifier                                                                                                                     |
| meshProjectId        | number | Internal ID of the meshProject. Every project is guaranteed to have a unique ID, but tenants on different platforms can share this ID. |
| platform             | string | Platform Identifier                                                                                                                    |
| rand                 | string | A string of up to 100 random alpha numeric characters.                                                                                 |
| tenantPlatformNumber | number | A sequential number of the tenant on this very platform.                                                                               |

Note that you can also use tags! The placeholders for these are generated automatically. For example, if you have a tag
in meshStack called `projectOwner`, the template engine placeholder for this would be `tagProjectOwner`.

> **Attention** For some cloud platforms certain strings must be globally unique (for example the AWS account alias). The `projectIdentifier` is not unique in meshstack. A combination of at least the `workspaceIdentifier` and `projectIdentifier`
> is highly recommended to avoid name collisions. For platforms with globally unique requirements like GCP or AWS a randomized part or a unique static prefix can also help to prevent sporadic replication problems.

---


---
id: meshstack.how-to.start-with-OSB-Services
title: How to start with the OSB Services
---

## Overview

The Marketplace Catalog enables you to provide all type of Platfrom Services including OSB Services

Offering your Services in the meshStack has the following benefits:

- easier reach users which already are approaching cloud services
- out-of-the-box billing capabilities
- (optional) user assignment through the meshStack

We suggest you to set up your Service Broker using meshcloud's open-source [UniPipe Service Broker](https://github.com/meshcloud/unipipe-service-broker). UniPipe will enable you a quick setup, development and time-to-market.
UniPipe will reduce your own code development efforts as it provides the basic functionality required by the [Open Service Broker API](https://www.openservicebrokerapi.org/) reference.

## Requirements

If you want to offer an OSB service in the Marketplace you have to meet the following requirements:

- You have your own meshWorkspace in the meshPanel where you can add your Open Service Broker
- You have OSB platform to offer your OSB Services trhought it
- You have a running Service Broker that implements the [Open Service Broker API](https://www.openservicebrokerapi.org/).
  - To learn more about the OSB API, read the complete the [API spec](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md).

## How to start using UniPipe

### UniPipe Wiki

The [UniPipe Wiki](https://github.com/meshcloud/unipipe-service-broker/wiki) will provide you most information to start and set up your own service broker in a short time.

### How to deploy UniPipe

Once you implemented your service broker, you can deploy it. The UniPipe Wiki has a detailed description on [how to deploy UniPipe](https://github.com/meshcloud/unipipe-service-broker/wiki/How-To-Guides#-how-to-deploy-unipipe-service-broker)

## How to set up your Service Broker in the OSB Services Platform

Service development in the OSB Services Platform is documented in [meshcloud docs](./meshstack.meshmarketplace.development.md).

- Log in into the meshPanel.
- Open the Workspace Overview.
- Select the Service Broker tab and dadicated subtub.
- Click on '+ Register'

![Add Service Broker](./assets/marketplace/marketplace-service-broker-overview.png)

- Register the Service Broker by entering the required parameters.

![Register Service Broker](./assets/marketplace/marketplace-register-service-broker.png)

You can now start booking and using your OSB services within your own meshWorkspace. This is useful for testing and verifying whether your service broker works as intended.

Once you are ready for other teams to book your offered services, you can [publish](./meshstack.meshmarketplace.development.md#publish-your-service-broker) your service broker.


---


---
id: meshcloud.workspace
title: meshWorkspace
---

A meshWorkspace usually represents a product team or department in your organization. Self-service within a meshWorkspace
allows you to invite and manage team members, create [meshProjects](meshcloud.project.md) and maintain organizational metadata like payment methods.

## Workspace Creation

Organizations implementing meshStack can choose to offer self-service workspace registration via meshPanel or externalize
the process to some existing ITSM or process automation system. Partners can read more about these options [here](meshstack.onboarding.md#workspace-registration).

In any case, the meshWorkspace creation process always involves collecting basic workspace information like name, identifier
and any additional [metadata specific to your organization](meshstack.metadata-tags.md#workspace-tag-schema).

## Managing your meshWorkspace

Every aspect of your meshWorkspace can be managed in the so-called [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace). The workspace control plane is the highest control plane. From that level, you can navigate down to the [project control plane](./meshcloud.project.md#manage-meshprojects) & [tenant control plane](./meshcloud.tenant.md#using-your-tenant). Each control plane has a similar layout. Depending on your permissions within the workspace and the meshStack configuration, you will have access to different tabs like **Settings** or **Financials**. The workspace control plane below shows the control plane from the perspective of a Workspace Manager.

![Workspace Control Plane User Interface](assets/Workspace-overview.png)

General information of a meshWorkspace (like its name) and [Workspace Tags](meshstack.metadata-tags.md#workspace-tag-schema) can be edited under the **Settings** tab.
The workspace identifier is also shown here, but it can never be changed,
as it is used as an immutable identifier of the meshWorkspace for its
representation in the different cloud platforms. You are however able to change the display name of the meshWorkspace.

If configured by your Cloud Foundation team, you may also be able to edit additional workspace [metadata tags](./meshcloud.metadata-tags.md) in the Settings Tab.

## Invite Users to a Workspace Team

If you would like to give others access to your meshWorkspace and the related meshProjects, go to your **Workspace Access** tab.
You can access them by pressing the settings icon on the top right of the meshPanel.
From here, navigate to **Current Access**. Here you can invite users or groups to the meshWorkspace.
You can search for users via first & last name, email and username. The users that can be found via
this search depend on the configured IAM system in you meshInstallation. It is e.g. possible to search for users in an Active Directory or a Google Cloud Directory. Additionally all users already known to meshStack can be found via this user search. Besides users, also [groups](#user-groups) can be searched for. You can search for groups via their name and identifier.

If you want to invite a user that it is not known to the connected IAM system and meshStack, you are able to invite a user by providing
the first and last name as well as an email address. The invited user will be matched via the email address when he logs in the first time to meshStack.
The "invite user" link is available when the search did not return any results.

You can initially setup the meshWorkspace role in the dropdown which describes the access level of the invited user or group.
Press "+" to add to the meshWorkspace. All users and members of the group will receive an email with the information,
that they have been granted access to your meshWorkspace.

Assigning a meshWorkspace role is necessary in order to give access to [meshProjects](meshcloud.project.md) insight the meshWorkspace.
If 4 eyes-principle is active, the user or group will not be assigned directly to your meshWorkspace. Another Workspace Manager has to approve this role assignment first. Therefore the user or group will appear in the "Pending Requests" section.

## Workspace User Groups

For not having to assign multiple users individually to your projects, you can also group them in a user group. User groups can be assigned roles on a [meshWorkspace](#invite-users-to-a-meshworkspace-team) and a [meshProject](meshcloud.project.md#access-control-on-a-meshproject) in the same way as for usual users.

You can view workspace user groups within your workspace by going to the **User Groups** section in the **Access Control** tab.
Currently, creating a group is only supported via the [meshStack API](/api/) and to create one you will need a Workspace identifier, which you can find on the Workspace overview.
![workspace-identifier](assets/workspace-identifier.png)

### Creating Groups in meshStack

You can create groups directly in meshStack using the `meshWorkspaceUserGroup` declarative API endpoint. This API allows you to create workspace-specific groups, add users to these groups, and remove users. 

However, be aware that whenever you update the group, you must send the full list of members, as this API will replace the existing members with the list you provide.

## Assign Workspace Roles

You can change the role assigned to each user or group on the current meshWorkspace.
To change the assigned role choose a new role from the dropdown.

A user or a group can be assigned multiple roles simultaneously. All users and members will receive the combined rights of all their assigned roles.

The following roles are available:

- **Workspace Owner**: Has full access to the meshWorkspace and its projects and can manage access to the meshWorkspace. A user that has this role will be the contact person for any matters related to the meshWorkspace. There can be maximum two Workspace Owners in a meshWorkspace. If a Workspace Owner already exists, that Workspace Owner can assign the Workspace Owner role to another user. If a Workspace Owner doesn't exist, the Workspace Managers can assign a Workspace Owner.
- **Workspace Manager**: Has full access to the meshWorkspace and its projects and can manage access to the meshWorkspace.
- **Workspace Member**: Has full access to project resources, but **cannot** manage access, create projects, etc. of the meshWorkspace.

### Workspace Roles

The following table provides details about the functionality available to the different roles.

<!-- TODO: we should add a better hierarchy at some point and thin this list down -->

|                                                                                                                      | Workspace Owner | Workspace Manager | Workspace Member |
|----------------------------------------------------------------------------------------------------------------------| :------------: | :------------: |:----------------:|
| View Projects                                                                                                        |    &#10003;    |    &#10003;    |  (if assigned)   |
| [Workspace&nbsp;Projects](meshcloud.project.md#manage-meshprojects)                                                  |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Create&nbsp;Project](meshcloud.project.md#create-a-new-meshproject)                                     |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Edit&nbsp;Project](meshcloud.project.md#manage-meshprojects)                                            |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;&nbsp;&nbsp;[Add&nbsp;meshTenants](meshcloud.project.md#adding-meshtenants)                              |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;&nbsp;&nbsp;[Delete&nbsp;meshTenants](meshcloud.tenant.md#delete-a-meshtenant)                           |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;&nbsp;&nbsp;[Payment&nbsp;Information](meshcloud.project.md#provide-payment-information-for-meshproject) |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;&nbsp;&nbsp;[Access&nbsp;Control](meshcloud.project.md#access-control-on-a-meshproject)                  |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Expired&nbsp;Access](meshcloud.project.md#expiration-of-a-principal-assignment)                         |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Project&nbsp;Statements](meshcloud.project-metering.md#project-statement)                               |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Delete&nbsp;Project](meshcloud.project.md#delete-a-meshproject)                                         |    &#10003;    |    &#10003;    |                  |
| [Workspace&nbsp;Users](meshcloud.workspace.md)                                                                       |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Give&nbsp;Access](meshcloud.workspace.md#invite-users-to-a-meshworkspace-team)                          |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Edit&nbsp;Access](meshcloud.workspace.md#assign-meshworkspace-roles)                                    |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Remove&nbsp;Access](meshcloud.workspace.md#remove-assigned-meshworkspace-roles)                         |    &#10003;    |    &#10003;    |                  |
| &nbsp;&nbsp;[Assign&nbsp;Workspace&nbsp;Owner](#assign-meshworkspace-roles)                                          |    &#10003;    |                |                  |
| [Workspace&nbsp;User&nbsp;Groups](meshcloud.workspace.md#user-groups)                                                |    &#10003;    |    &#10003;    |                  |
| [Workspace&nbsp;Settings](#workspace-deletion)                                                                       |    &#10003;    |    &#10003;    |                  |
| [Payment&nbsp;Methods](meshcloud.payment-methods.md)                                                                 |    &#10003;    |    &#10003;    |                  |
| [Service&nbsp;Broker&nbsp;Development](meshstack.meshmarketplace.development.md)                                     |    &#10003;    |    &#10003;    |                  |

> The roles that are available meshStack Administrators are described in the [Administration](administration.index.md) section.

meshWorkspace roles grant rights in meshStack only. In order to access cloud resources users need to be [granted a role on a meshProject](meshcloud.project.md#access-control-on-a-meshproject).

## Remove assigned Workspace Roles

If you would like to remove a user or group from your meshWorkspace go to the **Workspace Access** tab and select **Current Access**. You can click the "trash" icon in the **Current Access** section to remove the user or group from your meshWorkspace. If 4-AP is active in your meshInstallation and the role request has not been approved by another Workspace Manager yet, click the "trash" icon in the "Access Requests" section. When removing someone from the meshWorkspace, the user or group is automatically removed from all projects it has access to. All users won't be able to access cloud resources of your projects anymore, if they are not assigned via another role binding anymore. The users or members of the group will be informed via email, that their access to the meshWorkspace was revoked.

## Roles Recertification

If you do not have a central Identity and Access Management (IAM) system for recertifying roles, you can still recertify roles locally in meshStack by controlling the duration of access for a Workspace. To do this, navigate to the Settings page and select the Compliance tab. From there, you can choose a specific time frame for a particular Workspace role, such as a 6-month limit for the Workspace Owner role. This means that users cannot be assigned to the Workspace Owner role for longer than 6 months. By choosing a specific time frame, you also make it mandatory to set an expiration date for Workspace roles. This means that an expiration date for a Workspace role will be required during Workspace creation or when assigning users afterward. After the expiration date, users will be automatically unassigned from Workspace.

Role recertification is also available for assigning users to the role via API. When you enable Workspace Role Recertification in the Settings, the system will automatically set an expiration date when you create a WorkspaceUserBinding or WorkspaceGroupBinding using the meshObject API. For instance, if you've configured on the Settings page to limit a Workspace Owner's access to 6 months, any Workspace Owner created via the API will automatically have an expiration date of 6 months from the date they were created.

## Workspace Deletion

Before a meshWorkspace may be deleted, a check is performed to verify the following:

- all meshProjects in the meshWorkspace have been deleted
- all published Service Brokers in the meshWorkspace have been [deactivated](meshstack.meshmarketplace.development.md#deactivation-of-service-brokers)

The deletion can be performed only by the Workspace Owners! You can delete the workspace under **Deletion** in the workspace control plane. You will be asked for confirmation and a deletion reason.

Note : The deletion of a workspace can not be reversed!

The following steps will be done during deletion:

- all assigned users & groups as well as pending binding requests will be removed from the meshWorkspace
- all payment methods on the meshWorkspace will be soft-deleted, so meshPartners can still get details like info on usage of these payment methods
- all policy violations related to the deleted meshWorkspace will be removed
- a "deleted" event is written to the workspace events, including a reason that was provided during deletion

meshWorkspaces are soft-deleted, so meshPartners can still see deleted meshWorkspaces and their events in the Admin Area. Deleted meshWorkspaces and meshPaymentMethods will be highlighted by a "Deleted" label.


---


---
id: marketplace.service-brokers-vs-building-blocks
title: Service Brokers vs. Building Blocks
---

[Building Blocks](administration.building-blocks.md) are the meshStack's standard mechanism to repetitively roll out infrastructure
across workspaces. Building Blocks are the recommended way of doing so. Besides Building Blocks, meshStack also supports OSB Services, which can be relevant if you have an existing investment into OSB Services. This page aims to help you understand how these two mechanisms compare.

Building Blocks are currently more actively being worked on, but the Service Broker-based on OSB Services Platform (old meshMarketplace)
will continue to be supported in the future.

The table below describes each capability and to what extent it is supported by the respective feature (Building Blocks or Service Brokers)

✅ - supported

🟨 - works to some extent

⏰ - not supported yet

❌ - not supported and not planned for the future

|                                           | Building Blocks                                                                   | Service Brokers                                                                                                                       |
|-------------------------------------------|-----------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| Provision resources with Terraform        | ✅ This works very easily                                                          | 🟨 Works using [UniPipe Service Broker](https://github.com/meshcloud/unipipe-service-broker), but requires more implementation effort |
| Run Custom Processes outside of Terraform | ✅ Async provisioning is supported and allows writing back status updates from external systems into meshStack                                                                                 | ✅ Service Brokers run on OSB API which means you can build anything you want as long as the interface is compliant with OSB API       |
| Automated Deletion of Resource            | ✅ Terraform Building Blocks can run `tf destroy` automatically                    | 🟨 Possible but logic needs to be implemented in the service broker                                                                   |
| Request User Configuration                | ✅ You can define a form for your users via the UI                           | ✅ Works with JSON schema and allows for a lot of different variations                                                                 |
| Manage Instances via API                  | ✅                                                                                 | ✅ But missing deletion of meshServiceInstances                                                                                        |
| Manage Definitions via API                | ⏰                                                                                 | ❌                                                                                                                                     |
| Custom Pricing Models                     | ✅ via [meshResourceUsageReports API](https://docs.meshcloud.io/billing-api/index.html#_put_meshresourceusagereports)                                                                                | ✅ Can be made part of the definition                                                                                          |
| Sandbox Development Process               | ✅ Developers can test drafts of building blocks that cannot be booked by any other workspaces | ✅ Developers can create a private service broker that cannot be booked by any other workspaces                                        |
| Allow non-admins to contribute            | ✅ Workspace users offer building blocks via the service management area and get it approved by an Admin to be used by other workspaces in the meshStack                              | ✅ Workspace users integrate service broker and get it approved by an Admin to be used by other workspaces in the meshStack         |
| Versioning                                | ✅                                   | ❌ Not possible. There is no such thing as service versions                                                                            |
| Works without cloud platforms             | ✅ Building Blocks can create a tenant as part of a custom platform                                 | ✅ Service Brokers work without having a cloud tenant                                                                                  |
| View all consumption in Admin Area        | ✅ There is a list with all building blocks in the Admin Area                      | ❌ There is only a list of service brokers but not service instances                                                                   |
| Tag and Policy Support                    | ✅                                                                                  | ❌                                                                                                                                     |
| Integration on Landing Zones              | ✅ Can be set as recommended or mandatory on a landing zone                        | ❌                                                                                                           |
| Define Interdependencies                  | ✅                                                                                 | ❌                                                                                                                                     |
| Share Instances between Projects          | ⏰                                                                                 | ✅ Service Instances can be shared between Projects                                                                                |


---


---
id: meshstack.how-to.integrate-meshplatform-azure-manually
title: How to manually integrate Azure as meshPlatform
---

> The recommended way to set up Azure as a meshPlatform is via the public terraform [Azure meshPlatform Module](https://github.com/meshcloud/terraform-azure-meshplatform). If you use it then the steps given below are not needed.

## Set up the Replication Service Principal

meshStack uses separate service principals for different tasks based on the best practice of least privilege principle. There are two possible ways to setup Subscription creation:

1. Pre-provisioned Subscriptions
2. Using an Enterprise Enrollment/Customer Agreement Account

Depending on the way you choose to setup, you can either use an App Registration or an Enterprise Application principal. But in order to use an Enterprise Enrollment Account with automatic [Subscription provisioning](#subscription-provisioning), the usage of an App Registration principle is **mandatory**.

In order to manage user roles and permissions, meshcloud requires a Service Principal for the replicator which is placed in the AAD Tenant containing your Azure Subscriptions and workloads.
The Service Principal must be authorized in the scope of this AAD Tenant.

### Set AAD Level Permissions

1. Under **Azure Active Directory** &rarr; **Enterprise applications**, click on **New application**.
2. Click on **Create your own application**.
3. Choose a name for example, `meshReplicator`.
4. Choose "Register an application to integrate with Azure AD".

![Enterprise application registration](assets/app-creation-1.png)
5. Choose "Accounts in this organizational directory only, Single tenant".
![Choose single tenant](assets/app-creation-2.png)
6. It can take some time to show up in the overview, but then please write down its Object ID (will later correspond to `objectId`) and Application (client) ID (will later correspond to `client-id`).
7. In the AAD overview now go to **App registrations** (the created app should show up there as well).
8. Click on the app.
9. Add either a client secret or federated credentials.
    - **Client secret**: generate a client secret and note it down as well.
    - **Federated credentials**: the `federated credential scenario` should be set to "Other issuer". The values for `Issuer` and `Subject identifier` will be shown by the panel during platform configuration after selecting "Workload Identity Federation" as the authentication type.
10. Under **API permissions** → **Add a permission** → **Microsoft Graph API** (not Azure AD Graph API) → **Application permissions**:
    - `Directory.Read.All` - this permission is required to search the directory for existing users, groups and service principals
    - `Group.ReadWrite.All`  this permissions is required to create new groups
    - `User.Invite.All` - this permission is required if you want to enable [B2B User Invitation](#b2b-user-invitation)
11. Click **Grant permissions** and make sure to also grant admin consent for each permission by clicking **Grant admin consent** in the permissions screen of the app.
12. In the **Overview** section of your app also write down the **Directory (tenant) ID**.

Platform Operators need to supply these variables to the [meshStack Configuration](#meshstack-configuration) for this Azure Platform Instance.

### Set Azure RBAC Permissions

Created subscriptions will have the Service Principal of the replicator registered as an owner at first. As soon as all needed maintenance steps are performed (e.g. renaming the subscription, moving it into the final management group), the replicator removes itself as an owner.

All permissions left are therefore granted only via the Management Group hierarchy. The meshstack software does **not** need access related to actual workload inside these subscriptions. However, in order to perform certain maintenance tasks, the following permissions/roles must be granted to the replicator principal:

```hcl
# Assigning Users
"Microsoft.Authorization/permissions/read",
"Microsoft.Authorization/roleAssignments/*",
"Microsoft.Authorization/roleDefinitions/read",

# Assigning Blueprints
"Microsoft.Resources/deployments/*",
"Microsoft.Blueprint/blueprintAssignments/*",
"Microsoft.Resources/subscriptions/resourceGroups/read",

# Fetching Blueprints
"Microsoft.Management/managementGroups/read",
"Microsoft.Management/managementGroups/descendants/read",

# Assigning Subscriptions to Management Groups
"Microsoft.Management/managementGroups/subscriptions/write",
"Microsoft.Management/managementGroups/write",

# Permissions for reading and writing tags
"Microsoft.Resources/tags/*",

# Permission we need to activate/register required Resource Providers
"*/register/action",

# Rename pre-provisioned subscriptions, not required for Enterprise Enrollment
"Microsoft.Subscription/rename/action",

# The following permission is only required if you plan to use this principal for Azure Resource Group
# integeration.
"Microsoft.Resources/subscriptions/resourceGroups/write",
```

You must grant the meshcloud Service Principal this access to all [Management Groups](https://docs.microsoft.com/en-us/azure/governance/management-groups/) used in [Landing Zones](./meshstack.azure.landing-zones.md).

1. In Azure Portal, navigate to the "Management Groups" blade.
2. Click on the "Details" link of the management group you want to give access to.
3. Select "Access Control (IAM)" from the menu.
4. Create a role assignment of the custom IAM role created above for the [replicator Service Principal](#replicator).

> Access to the Management Groups may require the "Global Administrator" role with [elevated access](https://docs.microsoft.com/en-us/azure/role-based-access-control/elevate-access-global-admin). In case you're not able to see all management groups after elevating access, try signing out and back in to Azure Portal.

In order to enable meshStack to cancel Azure Subscriptions as part of [tenant deletion](./administration.delete-tenants.md), please also include the following permission. We strongly recommend you assign this permission only on Management Groups where you want to allow automated tenant deletion.


```hcl
"Microsoft.Subscription/cancel/action"
```

### Set up a policy to prevent Privilege Escalation

Furthermore in order to prevent the replicator from assigning itself more permissions, we recommended to add the following policy on a root management group level:

```json
{
    "properties": {
        "mode": "all",
        "displayName": "meshcloud Privilege Escalation Prevention",
        "description": "Prevent replicator SPN from assigning itself new roles.",
        "policyRule": {
          "if": {
            "allOf": [
              {
                "equals": "Microsoft.Authorization/roleAssignments",
                "field": "type"
              },
              {
                "allOf": [
                  {
                    "field": "Microsoft.Authorization/roleAssignments/principalId",
                    "equals": "<objectId>"
                  }
                ]
              }
            ]
          },
          "then": {
            "effect": "deny"
          }
      }
    }
}
```

## Set up Subscription Provisioning

To provide Azure Subscription for your organization's meshProjects, meshcloud supports using Enterprise Enrollment or allocating from a pool of pre-provisioned subscriptions. The Enterprise Enrollment is always the preferred one if you have an Enterprise Agreement as it allows full automation by meshStack for account creation.

### Use an Enterprise Enrollment

meshcloud can automatically provision new subscriptions from an Enterprise Enrollment Account owned by your organization. This is suitable for large organizations that have a Microsoft Enterprise Agreement, Microsoft Customer Agreement or a Microsoft Partner Agreement and want to provide a large number of subscriptions in a fully automated fashion.

> Microsoft currently has limitation of a [maximum of 2000 Subscriptions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/programmatically-create-subscription?tabs=rest#limitations-of-azure-enterprise-subscription-creation-api) per Enrollment Account (EA). It's therefore possible to configure meshStack to consume subscriptions from multiple EA's for the same [meshPlatform](./meshcloud.platforms.md). Please contact our experts for more details.

#### Set up the Enrollment Account

We recommend using dedicated enrollment accounts (EA) for exclusive use by meshcloud.

> EA Administrators must be careful to choose an EA Account Owner that is placed in the meshcloud AAD Tenant!

Subscriptions provisioned through the EA get automatically associated with the AAD Home-Tenant of the EA Account Owner.
If your organization uses Microsoft (i.e. outlook.com) identities as EA Account Owner, please invite the EA Owner user first into the meshcloud AAD Teant before creating the enrollment account.

For setting up the replicator configuration you need the scope of the enrollment account. Microsoft states this is the ID, however their documentation is inconclusive about this. The recommendation is to use a REST call to [get the Enrollment Account ID/Scope](https://docs.microsoft.com/en-us/azure/cost-management-billing/manage/programmatically-create-subscription-enterprise-agreement?tabs=rest-getEnrollments%2Crest-EA#find-accounts-you-have-access-to) (it should be executed in the scope of a user who is the owner of this EA account):

```bash
GET https://management.azure.com/providers/Microsoft.Billing/billingaccounts/?api-version=2020-05-01
```

the response is:

```json
{
  "value": [
    {
      "id": "/providers/Microsoft.Billing/billingAccounts/1234567",
      "name": "1234567",
      "properties": {
        "accountStatus": "Unknown",
        "accountType": "Enterprise",
        "agreementType": "EnterpriseAgreement",
        "soldTo": {
          "companyName": "Contoso",
          "country": "US "
        },
        "billingProfiles": {
          "hasMoreResults": false
        },
        "displayName": "Contoso",
        "enrollmentAccounts": [
          {
            "id": "/providers/Microsoft.Billing/billingAccounts/1234567/enrollmentAccounts/7654321",
            "name": "7654321",
            "type": "Microsoft.Billing/enrollmentAccounts",
            "properties": {
              "accountName": "Contoso",
              "accountOwnerEmail": "kenny@contoso.onmicrosoft.com",
              "costCenter": "Test",
              "isDevTest": false
            }
          }
        ],
        "hasReadAccess": false
      },
      "type": "Microsoft.Billing/billingAccounts"
    }
  ]
}
```

The value for a billing scope and id are the same thing. The id for your enrollment account is the billing scope under which the subscription request is initiated. Please note the field `value[].enrollmentAccounts[].id` of your desired enrollment account, as it needs to be used as the `enrollmentAccountId` in the [Platform Connection Config](administration.platforms.md#platform-connection-config).

#### Grant Enterprise Enrollment Account Permissions

The Service Principal needs the `Subscription Creator` role.

When using an [Enterprise Enrollment Account (EA) for Subscription provisioning](#enterprise-enrollment-account), an EA Administrator must authorize the [meshcloud Service Principal](#service-principal-setup) on the Enrollment Account.

This happens via a PUT request against `https://management.azure.com/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingRoleAssignments/{billingRoleAssignmentName}?api-version=2019-10-01-preview`.

##### Method 1: Use the Try it Button

The Mircosoft [API documentation](https://docs.microsoft.com/en-us/rest/api/billing/2019-10-01-preview/enrollmentaccountroleassignments/put) offers a **Try it** button which you can use to execute the call.

Using the Try it Button is also mentioned in the Mircosoft [role assignment documentation](https://docs.microsoft.com/en-us/azure/cost-management-billing/manage/assign-roles-azure-service-principals).

##### Method 2: Use a PowerShell Script

Replace the parameters in the following PowerShell script and execute it in a cloud shell:

```powershell
# Manual input
$principalId = "11111111-1111-1111-1111-111111111111" # Object ID of the replicator enterprise application
$aadTenantId = "11111111-1111-1111-1111-111111111111" # Your AAD tenant id
$billingAccountId = "1234567" # You can find the billing account id in the Azure portal on the Cost Management + Billing overview page.
$enrollmentAccountId = "7654321"

# Build the request
$token = (Get-AzAccessToken -ResourceUrl 'https://management.azure.com').Token
$headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
$headers.Add("Content-Type", "application/json")
$headers.Add("Authorization","Bearer $token")
$billingRoleAssignmentName = (New-Guid).Guid

$url = "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/$billingAccountId/enrollmentAccounts/$enrollmentAccountId/billingRoleAssignments/$billingRoleAssignmentName`?api-version=2019-10-01-preview"

# Subscription Creator. See https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/assign-roles-azure-service-principals#permissions-that-can-be-assigned-to-the-spn
$roleDefinitionId = "/providers/Microsoft.Billing/billingAccounts/$billingAccountId/enrollmentAccounts/$enrollmentAccountId/billingRoleDefinitions/a0bcee42-bf30-4d1b-926a-48d21664ef71"

$body = "{
`"properties`": {
  `"principalId`": `"$principalId`",
  `"principalTenantId`": `"$aadTenantId`",
  `"roleDefinitionId`": `"$roleDefinitionId`"}`n}"

# Send request
Invoke-RestMethod $url -Method 'Put' -Headers $headers -Body $body | Format-List

# Check that the creation was successfull
Invoke-RestMethod $url -Method 'Get' -Headers $headers | Format-List
```

> The Azure documentation also mentions to use the correct API versions for both the Subscription creation and the role assignment call. For Subscription creation, the replicator uses the API version `...?api-version=2020-09-01`, which reliably works together with the above mentioned PUT call of the EA Account role assignment with the API version: `...?api-version=2019-10-01-preview`.

#### Ensure Retained Subscription Owners

Azure requires that there's at least one "Owner" or "Classic Administrator" role assignment on each Subscription. Unfortunately, it's not a sufficient workaround to inherit the Owner role via the Management Group Hierarchy onto the Subscription. Instead a direct role assignment must exist.

In contrast to other provisioning methods, EA provisioning will not retain a default "Classic Administrator" role assignment on the subscription from the billing account owner. Platform Operators should therefore configure at least one explicit owner under `subscriptionOwnerObjectIds`. We recommend to use the EA Account owner as Subscription Owner. It could also be an empty AAD group or the [Blueprint Service Principal](#blueprint-configuration).

> You should never grant subscription owner roles to the meshStack replicator SPN.

### Use a Customer Agreement

If your company has a Customer Agreement with Microsoft you can also use an automatic REST API in order to create new subscriptions. It is a very similiar process to the [Enterprise Agreement](#set-up-enterprise-agreement-provisioning) variant. The difference is you need two principals, one on the Billing Account tenant that creates the subscription and another one on the target AAD tenant that receives its ownership.

#### Create Source Tenant Principal

1. On the tenant that contains your billing account create a new Enterprise Application.
2. Add either a client secret or federated credentials to it and note down the `Directory (tenant) ID`, `Application (client) ID`, `Object ID`.
    - **Client secret**: generate a client secret and note it down as well.
    - **Federated credentials**: the `federated credential scenario` should be set to "Other issuer". The values for `Issuer` and `Subject identifier` will be shown by the panel during platform configuration after selecting "Workload Identity Federation" as the authentication type.
3. Select the billing profile or invoice section under which you want to create the subscriptions by following the [documentation](https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/programmatically-create-subscription-microsoft-customer-agreement?tabs=rest#find-billing-profiles--invoice-sections-to-create-subscriptions) from Microsoft. Write down the ID that looks something like this `/providers/Microsoft.Billing/billingAccounts/5e98e158-xxxx-xxxx-xxxx-xxxxxxxxxxxx:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx_xxxx-xx-xx/billingProfiles/AW4F-xxxx-xxx-xxx/invoiceSections/SH3V-xxxx-xxx-xxx`.
4. Go to the billing account and give the newly generated principal one of those roles there: `Owner`, `Contributer`, `Azure Subscription Creator` on an invoice section or `Owner` or `Contributor` on a billing profile or billing account. This allows the principal to generate new Subscriptions.

#### Create Target Tenant Principal

The requirements for the principal on the target tenant is identically with the one from the Enterprise Agreement provisioning. Please follow the section [Set up the Replication Service Principal](#set-up-the-replication-service-principal).

#### meshPanel Configuration

When creating a new platform configuration in the meshPanels admin section, choose Customer Agreement and fill in the form with the data you just noted down. The `Principal Client Secret`, `Principal Object ID` and `Billing Account Principal Client ID` refer to the data of the service principal from the billing/source tenant AAD.

The `Destination AAD ID` must be an ID. Please don't use the domain name variant of it e.g. `*.onmicrosoft.com` but use its UUID form. The principal data in the **Access Configuration** part refers to the target tenant AAD service principal.

> If the source AAD tenant is the same as the destination AAD tenant, ensure to use an ID and not the domain name variant for the source AAD tenant as well.

### Use pre-provisioned Subscriptions

If your organization does not have access to an Enterprise Enrollment, you can alternatively configure meshcloud to
consume subscriptions from a pool of externally-provisioned subscriptions. This is useful for smaller organizations that wish
to use "Pay-as-you-go" subscriptions or if your organization partners with an [Azure Cloud Solution Provider](https://learn.microsoft.com/en-us/partner-center/azure-plan-lp) to provide your subscriptions.

The meshcloud Azure [replication](./meshcloud.tenant.md) detects externally-provisioned subscriptions based on a configurable prefix in the subscription
name. Upon assignment to a meshProject, the subscription is inflated with the right [Landing Zone](./meshstack.azure.landing-zones.md) configuration
and removed from the subscription pool.

## Set up the Metering Service Principal

To read resource usage, a metering principal is needed. It requires the following role on all resources which should be accessed by meshStacks's metering service:

- `Cost Management Reader`

## Set up Blueprint

The `Azure Blueprints` service principal id is different in every AAD Tenant, so we need to find the id
of the app in the managed AAD Tenant.

The easiest way to accomplish this is to start an Azure cloud shell in a subscription on the meshcloud AAD Tenant and execute the following command:

```powershell
Get-AzureRmADServicePrincipal -ApplicationId f71766dc-90d9-4b7d-bd9d-4499c4331c3f
```

The response should be similar to

```text
ServicePrincipalNames : {f71766dc-90d9-4b7d-bd9d-4499c4331c3f}
ApplicationId         : f71766dc-90d9-4b7d-bd9d-4499c4331c3f
ObjectType            : ServicePrincipal
DisplayName           : Azure Blueprints
Id                    : 2a6a62ad-e28b-4eb4-8f1e-ce93dbc76d20
```

This `Id` needs to be configured in the Azure Platform configuration.

## B2B User Invitation

You can optionally activate AAD B2B guest invitations for users missing in the AAD tenant managed by the meshPlatform.
This configuration is useful if you have one or more "workload" AAD tenants for Azure Subscriptions while having a central
"home tenant" for your organization's user identities that handles O365 and related services.

Before users can access an AAD tenant they've been invited to using Azure B2B, they need to go through Azure's
["Consent Experience"](https://docs.microsoft.com/en-us/azure/active-directory/external-identities/redemption-experience) and accept the invitation. meshStack supports two different entry points into this process:

- The "Go to Azure Portal" link displayed in meshPanel redirects users into Azure Portal and selects the right AAD tenant and Subscription. This will trigger the consent experience in case the user's B2B invitation is pending acceptance.
- meshStack can instruct Azure to send invitation mails directly via the `sendAzureInvitationMail` configuration option.

> B2B Invitations require meshStack to know the user's valid email address which is usually fetched from the [euid](./meshstack.identity-federation.md#externally-provisioned-identities).


---


---
id: meshstack.meshmarketplace.index
title: Integration
---

The Open Service Broker (OSB) platform provides a common integration point for any remote service which can be provisioned by an API (e.g. a database). A lightweight service broker component implementing the [Open Service Broker API Specification](https://github.com/openservicebrokerapi/servicebroker/blob/v2.14/spec.md) allows such services to become a resource within a meshProject and be included in the project lifecycle management at the meshStack platform.

> To learn more about providing a service ecosystem in your cloud foundation team, have a look at the [maturity model](https://cloudfoundation.meshcloud.io/maturity-model/service-ecosystem/).

## OSB Services Platform

The OSB Services Platform allows users to manage service instances attached to a meshProject. The OSB Services Platform uses the official Open Service Broker API standard to communicate with Service Brokers, which are responsible for the actual provisioning of service instances through their service implementation. This guide aims to provide a quick overview of the Open Service Broker API and implementation specific topics. It is required that service implementers study the Open Service Broker API specification for in-depth information.

## Locality of Services

The OSB Services Platform provides support for global and local services. Service Providers must choose which type of Service they want to offer so that the service is appropriately integrated into the user interface.

### Global Service

- global entry point for consumers (API), reachable from all networks
- Service is provided in a location agnostic manner
- Service may offer configuration of data locations etc. through configuration/dashboards
- Examples: CDN, DNS, Backup

### Local Service

- Local entry point for consumers (API), may be reachable only within a specific location
- Service is provided from a single location only
- Location of data etc. is important
- Examples: DBaaS

## OSB API Profile

meshcloud implements an extended [OSB API Profile](./meshstack.meshmarketplace.profile.md) that allows brokers a deeper integration with meshStack. Please review the documentation to learn more about the use-cases this API profile enables.

## Authentication & Authorization

### Marketplace to Service Broker

All communication between the OSB Services platform and Service Brokers is secured using HTTPS Basic Auth and a pre-shared key. Service owners that also develop brokers for platforms like Cloud Foundry or OpenShift will be familiar with this model.

### Replicating Authorization Information

OSB Services platform supports two different options for authenticating and authorizing users.

- (Enterprise Plans only) use an OIDC client in meshIdB as described in the [OSB dashboard tutorial](./meshstack.meshmarketplace.dashboard-tutorial.md)
- replicate permissions to Azure Active Directory groups ([learn more](#aad-permission-replication))

If the above options do not work for your use case, you can also consider extracting the authorization information from meshStack
using the [meshObject API](/api/).

## Deprecating OSB Services

At some point along the lifecycle of an OSB service you might want to deprecate it, i.e. existing service instances will
remain and keep working but you prevent the booking of new service instances.

You can do so by removing the service definition from the service catalog. meshStack will retain all known information about
the service and service instances but from there on it will no longer be possible to book new instances of
the service.

### Undeprecating an OSB Service

Did you wrongly deprecate a service? Or was the deprecation only temporary? You can bring back the service at any time.
Just place it back in the service catalog (with the same identifier!) and meshStack will pick it up again, and it will be
made available in the marketplace and made bookable for customers.

## Configuring OSB Services Platforms

OSB Services platforms can only be configured by meshcloud via Dhall. It is not yet available in self-service. Please consult the following example as a reference of possible configuration settings.

```dhall
let PermissionReplication = ./PermissionReplication.dhall

in    λ(Secret : Type)
    → { platform : Text, permissionReplication : PermissionReplication Secret }
```

The default `permissionReplication` for setting every OSB Services platform is an instance of `MeshIdb`, which
offers no further configuration options. Note that these platforms do not need to be explicitly configured at this time.

### AAD Permission Replication

Platforms that want to use AAD group permission replication need to configure an instance of `AzureAd`

```dhall
let InviteB2BUserConfig =
  { redirectUrl = "https://example.com"
    {-  Redirect URL used in the Azure invitation mail sent -}
  , sendAzureInvitationMail = false
    {- Flag if an Invitation mail by Azure should be send out -}
  }

in    λ(Secret : Type)
    → { groupNamePattern :
          {- A pattern for deriving AAD Group names. Please see details described below -}
          Optional Text
      , servicePrincipal :
          {- Either friendly domain name or your tenants GUID -}
          { aadTenant = "<AAD_TENANT>"
          , objectId = "<SERVICE_PRINCIPAL_OBJECT_ID>"
          , clientId = "<SERVICE_PRINCIPAL_CLIENT_ID>"
          , clientSecret = "<SERVICE_PRINCIPAL_CLIENT_SECRET>"
          }
      , b2bUserInvitation :
          {-
          Optionally configure the replicator to create Azure B2B guest invitations for
          users missing in the target AAD tenant.
          -}
          Optional InviteB2BUserConfig
      , roleMappings :
          {-
          Each mesh project role (specified by key, i.e. user) is mapped to an
          AAD Group via an alias. This alias is available as a parameter in the
          groupNamePattern. Example:
          List { mapKey : Text, mapValue : { alias : Text } }
          -}
      }
```

Role mappings must be configured for all [meshProject roles](./meshcloud.project.md#project-roles). Note that in
contrast to the [Azure replicator](meshstack.azure.index.md) replication for the OSB Services platform will not create any
Azure-role assignments.

### AAD Group Name

The name of the generated subscriptions can be fully customized. A `printf` format string is used. You can read about all the available options in the official Java documentation about [`String.format`](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax).

For example the default string pattern `%s.%s-%4$s` would generate the group name `workspace.project-role`.

> Operators must be careful to ensure resulting group names are unique for project-role combinations. Groups should also not conflict with existing AAD groups.

The arguments available here are:

1. argument: meshWorkspace identifier
2. argument: meshProject identifier
3. argument: meshProject ID (numeric)
4. argument: role name alias.


---


---
id: administration.tenants
title: meshTenants
---

You can find a description of meshTenants [here](./meshcloud.tenant.md).

## Viewing tenant status

![Tenant Overview](assets/tenant-overview.png)

You can see the full list of meshTenants with their replication status in the Administration area. Click on `Tenants` below the `Platforms` header. The list contains all tenants and their status, which is either:

- successful
- in progress
- failed

Additionally, the list can be filtered on workspace, project, location, platform, landing zone and replication status.

For more information, click on 'View more' in the tenant list and in this screen additional information is available. You can especially see detailed information about what happened during tenant replication to the cloud platform. You can see which steps have been executed and if errors or warnings occurred, you will also see them here.

![Replication Details](assets/tenants/replication-status.png)

### Trigger meshTenant replication

Via the button at the top right of the replication status mentioned in the section before you can trigger a replication for this meshTenant. If you e.g. resolved a problem in the platform, you can easily verify whether the issue for the meshTenant was actually solved.

### Tenant Quotas

In the tenant list you can filter in the `Quota Request` column to only get meshTenants with an open [Tenant Quota Request](meshcloud.tenant-quota.md). Platform Operators have to take action on these requests and either approve or decline them. They also have the option to change the quota before approval if the request cannot be approved as is.

It is also possible to change tenant quota proactively as a platform operator, even if no tenant quota request exists. This is important, as meshStack will always make sure the defined quotas are applied in the platform. That means it is not possible to apply different quotas in the platform, as they will be overwritten on every replication by meshStack. If no quota request has been made yet by the meshWorkspace, default quotas defined in the [meshLandingZone](administration.landing-zones.md#defining-quotas) are applied.

When a quota request is active for a meshTenant you will see info about the quotas currently applied to the tenant, the requested quota and you have the option to overwrite requested quotas.

![View and Approve Quota Request](assets/tenants/admin-tenant-quota-request.png)


---


---
id: administration.workspaces
title: meshWorkspaces
---

With a Partner Account you can easily manage multiple workspaces with the meshcloud Portal. The meshcloud administration area is the
place to create and manage your workspaces. You can access the meshcloud **Administration** Area by opening the settings menu and
navigating to the **Administration** Area.

When selecting **Workspaces** in the menu bar on the left you can see the list of all workspaces managed by you.

## Create managed Workspaces

### Manually register a new Workspace

With meshcloud you can easily create workspaces.

1. Login to the meshPanel with your partner credentials.
2. If not logged in, please login with your Partner account credentials.
3. On the toolbar at the top, please make sure that you have navigated into the 'Admin Area'.
4. Select **Workspaces** in the menu bar on the left.
5. There is a button `+ Create Workspace` on the top-right of the table. After clicking the button, you will be navigated to the workspace creation screen. Here you can enter the name and identifier of the new workspace as well as the user(s) that should be assigned to the workspace. Keep in mind that you are able to configure restricted tags, this is not possible for non-partner users.

> **Attention**: Identifiers can not be changed. Please choose them carefully.

### Approve new Workspaces

A meshStack installation can be configured to require a manual approval by a partner/admin for new meshWorkspace registrations. Users who register receive an email notifying them, that their account is currently being verified. As soon as a partner/admin approves the request, they receive another email. This email informs users, that they are now approved and can start working with the cloud resources. Depending on the configuration, users may also have to confirm their email address via a confirmation link, that is available in the second email.

## Manage Workspaces

### Disabling Workspaces

Partners can disable meshWorkspaces in case the responsible workspace managers do not provide valid [Payment Methods](meshcloud.payment-methods.md) or do not maintain correct [metadata](meshstack.metadata-tags.md).

Setting the meshWorkspace status to **Disabled** has the following effects on [meshProjects](meshcloud.project.md) and [meshTenants](meshcloud.tenant.md) owned by this workspace:

- users can no longer access [meshTenants](meshcloud.tenant.md) via meshPanel

Disabling a workspace does not technically prevent users from accessing tenants when logging in directly on the cloud platform. To prevent this access so, partners must add themselves to the workspace as an admin and manually remove user permissions.

If you want to prevent a workspace from creating new [meshProjects](meshcloud.project.md), you can [adjust the workspace's meshProject quota](#set-workspace-quotas).

### Access managed Workspaces

As a partner user you can assign yourself a role on managed workspaces. The role that will be assigned can either be "Workspace Member" or "Workspace Manager" depending on the configuration of meshstack ([read more here](meshstack.onboarding.md#workspace-user-invitations)). If you are assigned as a Workspace Member you cannot execute step four and five.

1. Go to **Administration &gt; Workspaces** and click on the **Users** icon on the managed workspace you want to edit.
2. In the **Workspaces Users** view click on the button **Add Myself** in the top right corner.
3. After you have successfully assigned yourself to the account you can now choose the account in the top left drop-down. Please select the
   new managed workspace there.
4. In the toolbox go to **Account &gt; Users** where you can invite and add users to the managed workspace.
5. Invited users will receive an e-mail with a link to get access to this new workspace. For more details on user invitation, also see [meshWorkspace](meshcloud.workspace.md).

### Send messages to workspace users

Partner are able to send short notification messages to the users of their managed workspaces. Recipients will see these notifications
upon login.

In order to send such a message:

1. Login to the meshPanel with your partner credentials.
2. Navigate to the **Administration** area via the toolbox on the top right and then click on **Workspaces** in the menu.
3. In the **Actions** column click on the envelope icon.

Write your messages and choose which recipient should receive the messages: **All must read** will show the message to all recipients and everyone has
to acknowledged the message. Or you can choose **Single read only** which will hide the message for all other users if one single user has acknowledged
it. This is useful e.g. for maintenance task required to be done by the project team. Once one team member has solved the task, displaying the
notification is no longer necessary.

### Set Workspace Quotas

Partners and Administrators can manage the quota, that limits the maximum number of projects per workspace.

1. Login to the meshPanel with your credentials.
2. Navigate to the **Administration** area via the toolbox on the top right and then click on **Workspaces** in the menu.
3. In the **Actions** column click on the **Quota** icon on the managed workspace you want to edit.
4. Then you can increase and decrease the number of projects per workspace.

### Edit Workspace Tag Values

Partner users can edit tag values for tags defined in both [restricted and unrestricted meshTags](meshstack.metadata-tags.md) for managed **meshWorkspaces** by navigating to the **Workspaces** list and clicking the `Workspace Tags` button.

## Audit Workspaces

### Account History

Sometimes additional information about the lifecycle of a workspace is required. The archive icon in the list of workspaces shows all major events that happened on the workspace.

The following events are available:

| Event | Description |
| ------| ----------- |
| **CUSTOMER_REGISTERED**| A new meshWorkspace registered in self-service. |
| **CUSTOMER_CREATED**| A new meshWorkspace was created by a partner/admin. |
| **USER_INVITED**| A user was invited to a meshWorkspace. |
| **USER_ACCEPTED_INVITATION**| A user accepted the invitation. |
| **USER_INVITATION_CANCELLED**| An invitation was cancelled by a workspace manager. |
| **USER_REMOVED**| A user was removed from the meshWorkspace. |
| **USER_ROLE_CHANGED**| The role of a user was changed on the meshWorkspace. |
| **CUSTOMER_QUOTA_EDITED**| The quota of a meshWorkspace was changed. |
| **USER_ASSIGNED_HIMSELF**| A partner/admin assigned himself to a meshWorkspace. |
| **CUSTOMER_STATUS_CHANGED**| A partner/admin changed the status of a meshWorkspace (i.e. disabled or enabled the meshWorkspace). |
| **CUSTOMER_APPROVED**| A partner/admin approved a new meshWorkspace registration. This event is only available, when the [manual workspace approval](#approve-workspace) is activated. |


---


---
id: meshstack.authorization
title: Authorization
---

As described in [Identity Federation](meshstack.identity-federation.md) a SSO solution to access multiple cloud platforms is a central feature of meshStack. This section about **Authorization** describes in details on which level and how authorization is granted.

meshStack uses an RBAC authorization model. The default product configuration includes roles aggregating individual permissions (rights). These roles are modeled after functional roles expected in typical usage scenarios.

> Make sure to review the [meshModel](meshcloud.index.md) for background on terminology used in this document.

## Overview

meshStack includes **meshObject roles** that manage permissions on different [meshObjects](meshcloud.index.md). For example meshWorkspace Roles describe permissions on a meshWorkspace object.

### Role Bindings

**Role bindings** assign a meshUser or meshWorkspaceUserGroup a meshObject role on specific meshObject. Role bindings are also exposed via the [meshStack API](/api/). For example, a `meshProjectUserBinding` associates a meshUser with a meshProject and a meshProject Role.

Role bindings can also have a managed expiry date after which meshStack will automatically revoke the role.

Some roles also include permissions that allow users to manage role bindings in self-service. For example, a user with the "Workspace Manager" [meshWorkspace Role](meshcloud.workspace.md#assign-meshWorkspace-roles) can add new role bindings to that meshWorkspace.

### Access Requests

Any change in role binding always occurs via an **access request**. Access requests can be either approved or denied. Access requests may be subject to **approval conditions**. Partners can configure these conditions to meet a range of organisational and regulatory requirements like e.g. a 4 eyes principle.

Role requests produce an audit trail and may trigger notifications to involved parties.

## meshObject Roles

### meshWorkspace Roles

[meshWorkspace Roles](meshcloud.workspace.md#assign-meshWorkspace-roles) control the permission on a [meshWorkspace](meshcloud.workspace.md) and the [meshObjects](meshcloud.index.md) owned by that meshWorkspace. Users must have a corresponding role binding in order to access meshObjects owned by a meshWorkspace like [meshProjects](meshcloud.project.md).

Users with the right permissions can [assign meshWorkspace roles](meshcloud.workspace.md#assign-meshworkspace-roles) in self-service.

### meshPartner Roles

The [meshPartner](administration.index.md) is a special type of meshWorkspace. meshPartners own other meshWorkspaces and therefore have far-reaching permissions managed in [meshPartner Roles](administration.index.md).

Users with the right permissions can assign meshWorkspace roles in self-service with the same process used to [assign meshWorkspace roles](meshcloud.workspace.md#assign-meshworkspace-roles).

### meshProject Roles

[meshProject roles](meshcloud.project.md#project-roles) grant users access to meshProjects and their associated [meshTenants](meshcloud.tenant.md). meshProject roles are special in that they do not grant permissions within meshStack (apart from permission to view the meshProject). Instead meshStack replicates meshProject role bindings to the associated meshTenants according to their [meshPlatform](meshcloud.platforms.md) and [Landing Zone](meshcloud.landing-zones.md) configuration.

Users with the right permissions can [assign meshProject roles](meshcloud.project.md#assign-user-to-a-meshproject) in self-service. Users and groups can only have meshProject role bindings as long as they also have a role binding on the meshWorkspace that is the owner of that meshProject. When a user or group loses access to a workspace, meshStack will automatically remove all associated project role bindings.

## Configuration Options

### Available meshProject Roles

Operators globally configure the names and identifiers of meshProject roles available in their meshStack implementation. The individual [meshPlatform](meshcloud.platforms.md) and [Landing Zone](meshcloud.landing-zones.md) configuration determines how these meshProject roles are mapped to cloud roles/permissions for an individual meshTenant.

The default configuration of meshStack ships with these roles and intended use.

- Project Reader: A read-only user, like a controller or similar.
- Project User: A default user, like a developer, who can manage resources in the cloud platform.
- Project Admin: An admin user, who can also change configurations of the project in the cloud platform.

It is possible to define **additional custom roles**. These roles can also be referenced in the landing zone configuration to map them to roles available in the cloud platform.

<!--snippet:mesh.meshfed.web.project-->

The following configuration options are available at `mesh.meshfed.web.project`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let ProjectRoleConfiguration =
    {-
        roles:
            The list of roles available on meshProjects. Each role has a display name and an
            identifier used to reference the role in configuration (e.g. in Landing Zones).
    -}
      { roles : List ProjectRole }
```
<!--Example-->
```dhall
let example =
        { roles =
          [ { name = "Project Admin"
            , identifier = "admin"
            , description = Some
                "Can fully access the project in the cloud platform with administrative permissions including changing project configuration."
            , rank = 3
            }
          , { name = "Project User"
            , identifier = "user"
            , description = Some
                "Can use, create, and manage cloud resources within the cloud platforms project."
            , rank = 2
            }
          , { name = "Project Reader"
            , identifier = "reader"
            , description = Some
                "Can only view project resources in the cloud platform without the ability to use, manage and create new resources."
            , rank = 1
            }
          ]
        }
      : ProjectRoleConfiguration
```
<!--END_DOCUSAURUS_CODE_TABS-->

### Role Request Approval

In case you are required to implement a 4-eye-principle for access requests for compliance purposes you can configure the meshStack to do so. The approval can be configured in the [meshStack configuration model](meshstack.index.md#configuration) under `meshfed.web.user.rolerequest`. See the [role request configuration reference](meshstack.onboarding.md#workspace-user-invitations) for details.

If the `minApprovalCount` option is set to 2 or higher upon adding a project role binding, a popup will ask the inviting user to enter some additional information like why this role is required and for how long. This information will be visible to workspace managers who then can accept or decline such a request.

<figure>
  <img src="assets/authorization.additional-role-info.png" style="width: 50%;" alt="Additional Information Role Request Popup">
  <figcaption>Popup requesting additional information for a project role request</figcaption>
</figure>

New project role requests must be approved before the binding is created. The workspace manager making the role request registers an implict approval of the request. Each workspace manager can only reqister a single approval for an access request. This ensures that a _different_ workspace manager must register the 2nd approval before the binding is created.

> Note: if you make a role request on behalf of another workspace manager, that user (or another workspace manager) still has to approve or reject this request. This is intentional behavior to make users aware of any role changes done on their behalf.

Workspace managers will be notified by email about pending approvals. The affected user is also informed via mail about approved or rejected role requests. In case of a workspace user group, all users of the group are informed.

When any workspace manager declines the role request, the role request is immediately cancelled.

> Note: When a workspace has less workspace managers than the requested `minApprovalCount`, role requests will get automatically approved when all workspace managers have registered an approval. The meshPanel can be configured to display a warning in this case.

Its recommended to configure a warning to be shown to the user if this happens so another admin can be invited to the workspace. To do so configure the [meshStack configuration model](meshstack.index.md#configuration) under `panel.mesh.dashboardNotification`:

```dhall
{ show4EyePrincipleWarning = Some True }
```

It's not possible to configure required approval for removal of role bindings. Removal of role bindings
do not require approval and are made effective immediately.

### Authorization in Cloud Platforms

meshStack [replicates](./meshcloud.tenant.md) project role bindings to the cloud platform. During this process, meshStack translates the role binding to platform-specific role assignments according to the configuration provided by a Platform Operator on the platform or landing zone level.

> Please consult the documentation for the different cloud platforms for more details on the supported authorization mechanisms and their configuration.


---


---
id: administration.index
title: Administration Roles
---

Partners Users have access to the so called **Administration Area**. The administration area enables partner users to manage their child [meshWorkspace](./meshcloud.workspace.md) accounts within the meshcloud platform.
Assigning Partner Users can only be done by Partner Admins.

Different groups of people may need access to the different administration area functionality. Therefore, the following administrative roles are currently
available to users of the administration area:

- **Partner Admin**: It's basically the account with administration rights. Has full access to all functionality and can manage users of the
  administrator/partner account.
- **Partner Employee**: Has full access to all administration functionality, but **cannot** manage policies, tag definitions or users of the administrator/partner account.
- **Platform Operator**: An operator of a cloud platform, that is managed by the meshcloud platform. This role can perform tasks related to
  platform operations in the administration area.
- **Ops Support**: Not all Ops operations must be executed by Platform Operators. E.g. setting quotas is a task that can also be done by
  a separate Ops Support team.
- **Controller**: A Controller has access to billing and usage information of workspace projects.
- **Onboarding Support**: A support team in place to help users who want to sign up may also need access to some administration
  functionality which is granted by this role.
- **Compliance Manager**: Has the rights to manage policies and tag definitions.
- **Replication Operator**: A supportive role that can assist by viewing tenants' replication status.
  This role is helpful for meshcloud employees to debug any potential issues with tenant replication.

See the [meshWorkspace](meshcloud.workspace.md) documentation for details about how you can manage the roles of your users. This set of roles is easily extendable by adding roles to reflect individual access requirements of your organization.

The following table provides details about the functionality available to the different roles by default. The Access rights can also be adapted individually
per meshcloud installation.

|                                                                                                                     | Partner Admin        | Partner Employee     | Platform Operator | Ops Support | Controller | Onboarding Support | Compliance Manager | Replication Operator |
|---------------------------------------------------------------------------------------------------------------------| :------------------: | :------------------: | :---------------: |:-----------:| :--------: | :----------------: | :----------------: | :------------------: |
| [Workspace&nbsp;List](administration.workspaces.md)                                                                 |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |  &#10003;  |      &#10003;      |      &#10003;      |         &#10003;     |
| &nbsp;&nbsp;Payment&nbsp;Methods&nbsp;List                                                                          |       &#10003;       |       &#10003;       |                   |             |  &#10003;  |                    |                    |                      |
| &nbsp;&nbsp;Manage&nbsp;Payment&nbsp;Methods                                                                        |       &#10003;       |       &#10003;       |                   |             |  &#10003;  |                    |                    |                      |
| &nbsp;&nbsp;[Project&nbsp;List](administration.projects.md)                                                         |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |  &#10003;  |      &#10003;      |      &#10003;      |         &#10003;     |
| &nbsp;&nbsp;&nbsp;&nbsp;[Manage&nbsp;Quota](administration.projects.md#set-project-quotas)                          |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |            |                    |                    |                      |
| &nbsp;&nbsp;&nbsp;&nbsp;Edit&nbsp;project&nbsp;tags                                                                 |       &#10003;       |       &#10003;       |     &#10003;      |             |  &#10003;  |                    |      &#10003;      |                      |
| &nbsp;&nbsp;&nbsp;&nbsp;[History](administration.projects.md#project-history)                                       |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |            |      &#10003;      |      &#10003;      |         &#10003;     |
| &nbsp;&nbsp;[List&nbsp;Workspace&nbsp;Users](administration.workspaces.md#access-managed-workspace-accounts)        |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| &nbsp;&nbsp;&nbsp;&nbsp;[Add&nbsp;yourself](administration.workspaces.md#access-managed-workspace-accounts)         |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| &nbsp;&nbsp;&nbsp;&nbsp;[Send&nbsp;message](administration.workspaces.md#send-messages-to-workspace-users)          |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| &nbsp;&nbsp;&nbsp;&nbsp;Pending&nbsp;role&nbsp;requests                                                             |       &#10003;       |       &#10003;       |                   |  &#10003;   |            |      &#10003;      |                    |                      |
| &nbsp;&nbsp;[Project&nbsp;Export](administration.projects.md#project-export)                                        |       &#10003;       |       &#10003;       |                   |             |  &#10003;  |                    |                    |                      |
| &nbsp;&nbsp;[Quota&nbsp;Export](administration.projects.md#quota-export)                                            |       &#10003;       |       &#10003;       |     &#10003;      |             |  &#10003;  |                    |                    |                      |
| Compliance                                                                                                          |       &#10003;       |       &#10003;       |                   |             |            |                    |      &#10003;      |                      |
| &nbsp;&nbsp; List [policies](administration.policies.md)                                                            |       &#10003;       |       &#10003;       |                   |             |            |                    |      &#10003;      |                      |
| &nbsp;&nbsp; Manage [policies](administration.policies.md)                                                          |       &#10003;       |                      |                   |             |            |                    |      &#10003;      |                      |
| &nbsp;&nbsp; List [Tags](meshstack.metadata-tags.md)                                                                |       &#10003;       |       &#10003;       |                   |             |            |                    |      &#10003;      |                      |
| &nbsp;&nbsp; Manage [Tags](meshstack.metadata-tags.md)                                                              |       &#10003;       |                      |                   |             |            |                    |      &#10003;      |                      |
| Project Management                                                                                                  |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |            |      &#10003;      |                    |                      |
| &nbsp;&nbsp;[Delete&nbsp;Tenants](administration.delete-tenants.md#delete-tenants)                                  |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |            |      &#10003;      |                    |                      |
| &nbsp;&nbsp;&nbsp;&nbsp;[History](administration.projects.md#project-history)                                       |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |            |      &#10003;      |                    |                      |
| &nbsp;&nbsp;[Chargeback&nbsp;Statements](meshcloud.project-metering.md#chargeback-statements)                       |       &#10003;       |       &#10003;       |                   |             |  &#10003;  |                    |                    |                      |
| [Platforms](administration.platforms.md)                                                                            |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| &nbsp;&nbsp;[Platform&nbsp;Notifications](administration.platforms.md#platform-notifications)                       |       &#10003;       |       &#10003;       |     &#10003;      |             |            |                    |                    |                      |
| &nbsp;&nbsp;[Platform&nbsp;Restrictions](administration.platforms.md#restrict-platform-access)                      |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |            |                    |                    |                      |
| &nbsp;&nbsp;[Landing&nbsp;Zones](administration.landing-zones.md)                                                   |       &#10003;       |       &#10003;       |     &#10003;      |             |            |                    |                    |                      |
| &nbsp;&nbsp;[Usage&nbsp;Reports](meshcloud.project-metering.md#tenant-usage-reports)                                |       &#10003;       |       &#10003;       |                   |             |  &#10003;  |                    |                    |                      |
| &nbsp;&nbsp;[Tenants](administration.tenants.md)                                                                    |       &#10003;       |       &#10003;       |     &#10003;      |  &#10003;   |            |                    |                    |         &#10003;     |
| &nbsp;&nbsp;View [Unmanaged Tenants](administration.unmanaged-tenants.md)                                           |       &#10003;       |       &#10003;       |     &#10003;      |             |            |                    |                    |         &#10003;     |
| &nbsp;&nbsp;Assign [Unmanaged Tenants](administration.unmanaged-tenants.md#assigning-unmanaged-tenants)             |       &#10003;       |             |           |             |            |                    |                    |             |
| [User&nbsp;List](administration.users.md)                                                                           |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| &nbsp;&nbsp;Create User                                                |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| &nbsp;&nbsp;[Delete&nbsp;User](administration.users.md#delete-user)                                                 |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| &nbsp;&nbsp;[Download&nbsp;User&nbsp;Info](administration.users.md#download-user-information)                       |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| [API Users](administration.apiusers.md)                                                                             |       &#10003;       |            |                   |             |            |                    |                    |                      |
| [Service&nbsp;Broker](administration.service-brokers.md)                                                            |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| &nbsp;&nbsp;[Approve&nbsp;Service&nbsp;Broker](administration.service-brokers.md#approve-service-broker)            |       &#10003;       |       &#10003;       |                   |             |            |                    |                    |                      |
| [List Building&nbsp;Blocks&nbsp;&amp;&nbsp;Definitions](administration.building-blocks.md)                          | &#10003; | &#10003; | &#10003; |  &#10003;   | | | | &#10003; |
| &nbsp;&nbsp;&nbsp;[Manage&nbsp;Building&nbsp;Blocks&nbsp;&amp;&nbsp;Definitions](administration.building-blocks.md) | &#10003; | &#10003; | &#10003; |  &#10003;   | | | | &#10003;|
| &nbsp;&nbsp;&nbsp;[Delete&nbsp;Building&nbsp;Blocks&nbsp;&amp;&nbsp;Definitions](administration.building-blocks.md) | &#10003; | &#10003; | &#10003; |             | | | |                    



Please review [meshWorkspace roles](meshcloud.workspace.md#assign-meshworkspace-roles) for roles available to end-users of your meshStack implementation.

## Admin Groups

To avoid assigning multiple users individually, you can create Admin Groups. These groups can be assigned to roles in the same way as individual users.
You can view Admin Groups within your Administration Area by going to the **Admin Groups** section on the **Admin Access Control** page. Currently, the creation of Admin Groups is only possible via the [meshStack API](/api/), namely [meshWorkspaceUserGroups API endpoint](/api/index.html#mesh_workspaceusergroup), and to create one you will need a unique identifier, which you can find in the Admin Group section. In the example provided, the identifier is named "demo-partner," but it is unique to every meshStack.
![admin-group](assets/admin-group.png)


---


---
id: meshcloud.budget-alerts
title: Budget Alerts
---

## What are Budget Alerts?

meshStack has the possibility to send out budget alerts to Customer Users to make them aware of any (soon to be) exceeding of predefined budgets.

This is very helpful to make users aware of any unexpected expenditure compared to the budget that was defined by an administrator.

In the below screenshot you can see an example of a budget alert that was received by a user.

![Budget Alert Example](./assets/budget_alert_example.png)

It contains the necessary information for the user to be aware of where the problem lies, and how severe it is.

> Current limitation to how meshStack handles currencies: Although budgets can be applied in Dollar and Euro, budget alerts and payment method status only considers Euro. It is planned to expand the support for currencies besides Euro further in the future.

## How do I use Budget Alerts?

Budget alerts do not have to be configured. They will automatically be sent out if the conditions are right. A budget alert will be sent to a user if the following conditions are met:

- The user is a Workspace Manager or Workspace Owner in a meshWorkspace.
- The meshWorkspace has a payment method with a configured limit. The cloud consumption should be 80% or more on this payment method limit, e.g. €400 costs out of a €500 limit.

The budget alert will be sent via e-mail on Monday morning each week. To prevent spam, the user will receive all relevant budget alerts in a single e-mail, and not as one separate e-mail per budget alert.

## What do I do if a Budget is exceeded?

To deal with an exceeded budget, there are two options:

### 1. Increase the Limit of the Payment Method

The first and easiest option to fix a budget that is reaching its limit is to increase the limit. This has to be done by an administrator. Reach out to one of your Cloud Foundation administrators to get this done.

### 2. Request a new Payment Method

Another option is to request a new payment method. If configured by your Cloud Foundation team, in the workspace control plane, you can go to “Financials” → “Payment Methods” and click “Request Payment Method” which will open a form on a new page to request a new payment method for your meshWorkspace.
Once the new payment method is created, do not forget to set it as the active payment method on the project.

> For admins: click [here](./meshcloud.payment-methods.html#external-payment-method-registration) to learn how to configure a payment method request button.


---


---
id: administration.users
title: meshUsers
---

To manage users of your workspaces go to the **Users** section of the **Administration** area.

To search for a user, please follow these steps:

1. Click on **meshStack Users** in the **Administration** Area.
2. Enter a part or the complete first name, last name or email address of the user you are searching for.
3. The list will restrict the results to your search criteria automatically.

## Delete User

If you also want to delete a user follow these additional steps:

1. Click the trash icon.
2. In the confirmation dialog,  enter the username or email address of the user you want to delete. This avoids deleting users accidentally.
3. Click **"Confirm Deletion"** to finally delete the user.

After you have completed the deletion, all role bindings of the users will be removed from all workspaces and projects automatically.

Deleted users will only be flagged as deleted. Everything except their username will be pseudonomized via a SHA-256 hash (mandatory for privacy compliance by the EU GDPR).
Future audits of these users' actions will thus still be possible. Furthermore, you can reuse the usernames of deleted users. This enables you to invite users with usernames that once belonged to deleted users or reinvite them with the same username once they've been deleted.

## Download User information

To retrieve detailed information about which systems under meshStack management contain a user's personal information, just click the disc icon in the user list and a file containing this information will be downloaded.

## Guest Users

It's possible to flag meshUsers as "guest users". Guest users are intended for scenarios where a cloud foundation team wants to manage permissions for  external users via meshStack.
A common scenario where this occurs is when you organization collaborates with external partners on cloud projects and these partners "bring their own" indentities.

Guest users have the following properties

- They are not expected or unable to sign in via the configured Enterprise  [Identity Provider](./meshstack.identity-provider.md).
- Guest users are not able to login to meshPanel. It's sufficient for guest users to access any assigned cloud tenants directly via the cloud platform.
- Guest users do not receive email notifications from meshStack, e.g. about changed role assignments
- Guest users have an `euid`, see [configuring externally-provisioned identities](./meshstack.identity-federation.md#configuring-externally-provisioned-identity-federation).
- Guest user identities are available in the cloud platform's IAM directory with an `euid`, e.g. via AAD B2B or disabling domain restricted sharing on GCP


---


---
id: meshstack.building-blocks.meshStack-http-backend
title: Terraform/OpenTofu state managed by meshStack
---

Terraform and OpenTofu use state files to store infrastructure configuration details and access this information every time there are configuration changes. Please refer to the respective docs here:

- [OpenTofu](https://opentofu.org/docs/language/settings/backends/configuration)
- [Terraform](https://developer.hashicorp.com/terraform/language/backend)

meshStack accesses the building block state with every new run or on deletion. With the built-in http backend, you can store the state file within meshStack. This means it won't be necessary to configure an extra backend within your Terraform/OpenTofu sources. In this case meshStack automatically takes care of the state of the building block. 

> Additionally, you can also use the natively supported Terraform backend for remote state management if you prefer implementing that configuration. 

It is of course possible to also access and manipulate the state with [API Keys](./meshstack.how-to-API-keys.md). 

## Enabling the meshStack http backend for a Building Block

> In case your building block sources contain an explicitly defined backend configuration, this will always take precedence.
> This means that meshStack won't use its built-in http backend, even if enabled, in case it finds a backend configuration within
> the Terraform/OpenTofu code.

When creating a building block definition you can specify to use the built-in http backend for all building blocks of this definition by enabling the `Use meshStack's Http backend` - option within the `Implementation` part of the configuration.
The component running the building block will now configure Terraform/OpenTofu to use meshStack's http backend, but only in case no other backend configuration was found in the building block sources.
The generated backend configuration is equivalent to a Terraform/OpenTofu configuration that looks as follows:

```hcl
terraform {
  backend "http" {
    address = "https://your-meshstack.url/api/terraform/state/workspace/{workspaceIdentifier}/buildingblock/{buildingBlockUuid}
    // [...]
  }
}
```

Please note that including a configuration for meshStack's http backend in your source, as shown above, will not work because basic authentication values are not supported in this context.

## API key access to the state

You can create API keys with permissions to access the state of a specific building block. The permissions you need to add to the API key are grouped under the headline `Terraform/OpenTofu Backend`.
Once you got a Bearer Token with your API key, the state of a building block can be accessed via\
(`GET` / `POST` / `DELETE`) `/api/terraform/state/workspace/{workspaceIdenfifier}/buildingblock/{buildingBlockUuid}`.

## Limitations

There are currently two main limitations around meshStack's http backend:

1. Locking of the state is not yet supported, meaning you cannot configure a lock- or unlock - URL. Please make sure to avoid parallel write access to the state. Parallel access won't happen within meshStack but only in case you want to manipulate the state while a building block run is in progress.
2. meshStack will not perform a state transfer in case you run a building block first with the automatically configured http backend and later with an explicitly defined backend. State migration from a previous backend towards meshStack is currently not possible. If you want to migrate the state from meshStack towards a new remote backend, this can be achieved by following these steps:

   1) Create the infrastructure for your new backend
   2) Retrieve the current state from meshStack with help of an API key
   3) Update your Terraform/OpenTofu code to use the new backend
   4) Run Terraform/OpenTofu manually once and use the `-migrate-state` flag during [init with OpenTofu](https://opentofu.org/docs/cli/commands/init/) or [init with Terraform](https://developer.hashicorp.com/terraform/cli/commands/init)
   5) Update the respective building block definition
   6) Upgrade all building blocks for the definition

---


---
id: meshstack.cloudfoundry.metering
title: Metering
---

meshStack supports metering and billing for all versions of Cloud Foundry.

## Prerequisites

- Cloud Foundry user with `GlobalAuditor` role
- CloudFoundry APIs are accessible by meshStack metering collector components

## Supported Resources

Resources with the following traits are addressable in the [Product Catalog](meshstack.billing-configuration.md#defining-a-custom-product-catalog). Platform Operators can use the traits of these resources to define fine-granular product and pricing rules.

### Service Instance
<!--snippet:mesh.kraken.productcatalog.traits.cloudfoundry.service.instance#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let ServiceInstanceTraits =
    {-
      planId:
        Id of the service plan.

      type:
        Type of the service instance. One of MANAGED_SERVICE_INSTANCE, USER_PROVIDED_SERVICE_INSTANCE, UNKNOWN.
    -}
      { planId : Optional Text, type : Text }
```
<!--Example-->
```dhall
let example
    : ServiceInstanceTraits
    = { planId = Some "c3d68603-6fbb-43cf-a2cc-b134dafca178"
      , type = "MANAGED_SERVICE_INSTANCE"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


### Application
<!--snippet:mesh.kraken.productcatalog.traits.cloudfoundry.app#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let AppResourceTraits =
    {-
      appState:
        Application state. One of RUNNING, STOPPED

      event:
        Last recorded application event. One of STARTED, STOPPED, TASK_STARTED, TASK_STOPPED, BUILDPACK_SET or UNKNOWN.

      instances:
        Number of application instances.

      ramMb:
        RAM per application instance in MiB.

      size:
        Application size, the product of application instances * RAM. In MiB.
    -}
      { appState : Optional Text
      , event : Text
      , instances : Integer
      , ramMb : Integer
      , size : List Integer
      }
```
<!--Example-->
```dhall
let example
    : AppResourceTraits
    = { appState = Some "RUNNING"
      , event = "STARTED"
      , instances = +2
      , ramMb = +1024
      , size = [ +1, +1024 ]
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->


---


---
id: meshstack.cloudfoundry.index
title: Integration
---

meshStack supports integration with Cloud Foundry. Cloud Foundry is a PaaS platform which provides convenient application hosting capabilities to software and DevOps engineers.

meshStack supports project creation, configuration, access control, quota management and billing for Cloud Foundry.

## Integration Overview

To enable integration with Cloud Foundry, Platform Operators configure one or multiple `Platform`s of `PlatformType` Cloud Foundry in the [Platform Administration](./administration.platforms.md) in meshPanel.

## Prerequisites 

Your Cloud Foundry must support the v3 Cloud Foundry API.
We have officially validated meshStack with support for Cloud Foundry `v3.108.0`.

### UAA Federated Users

meshStack will identify and assign users to roles in Cloud Foundry based on their `euid` (external user id) as described in [Identity Federation](meshstack.identity-federation.md#externally-provisioned-identities).

You should set up your Cloud Foundry and UAA so that they store the `euid` value in the `User.userName` field of the [UAA User object](https://docs.cloudfoundry.org/api/uaa/version/77.8.0/index.html#get) and `User.username` field of the [Cloud Foundry user object](http://v3-apidocs.cloudfoundry.org/version/3.164.0/index.html#users).

## Integration Configuration

> The recommended way to set up Cloud Foundry as a meshPlatform is via the public terraform [Cloud Foundry meshPlatform Module](https://github.com/meshcloud/terraform-cloudfoundry-meshplatform).

### meshStack Admin User Accounts

meshStack requires two technical admin user accounts for integration with Cloud Foundry. We recommend your assign these 
users the following [Cloud Foundry roles](https://docs.cloudfoundry.org/concepts/roles.html) and [UAA scopes](https://docs.cloudfoundry.org/concepts/architecture/uaa.html#scopes).

- the `replicator` admin account must have permission to create orgs, spaces, groups and assign roles. This user requires the
  `Admin` role and additionally needs the `cloud_controller.admin`, `uaa.admin` and  `scim.read` scopes in UAA.
- the `metering` admin account is used to collect [metering data](./meshstack.cloudfoundry.metering.md). This requires the `Global Auditor`.

The tenant [replication](./meshcloud.tenant.md) ensures spaces and orgs are created within the CF platform and appropriate permission rights are set when users access the CF platform. If a user's project permissions are modified, meshStack updates the permissions for this user accordingly within the CF platform.

### Spaces & Organizations

By default, meshStack will replicate [tenants](./meshcloud.tenant.md) as Cloud Foundry Spaces and create a
Cloud Foundry Organization for every [workspace](./meshcloud.workspace.md).

### Permission Replication

During replication, meshStack will make sure that users have access to the Cloud Foundry spaces they are assigned to in meshStack.
It is currently not possible to configure a custom role mapping for Cloud Foundry landing zones. All meshStack project roles
will be mapped to the `Space Developer` role in Cloud Foundry.

Users will additionally receive the `Org User` role on the Organization created for their workspace.


---


---
id: meshstack.how-to.get-started-with-meshstack
title: How to get started with meshStack
---

This guide accompanies you to get started setting up a Internal Developer Platform with meshStack.

> **Prerequisites:**
> Your new meshStack is set up and the link to the meshPanel was provided to you.
> You need to be able to log into your meshStack and have admin area access.

## Step 1: Access the Admin Area of Your meshStack

The Admin Area is the central place to setup, customize and operate your very own Internal Developer Platform via meshStack.
To return to this view at a later point in time, you can always press the "Admin Area" button in the top bar.

## Step 2: Create Your First Workspace

Workspaces provide you the opportunity to onboard and structure your use cases. Those workspaces can act as consumers and/or providers of services within the marketplace. The marketplace is 
the central place in meshStack to offer services that others consume. 

Now lets get started by creating the first workspace in your meshStack. To open the wizard, click on "Create Workspace +" as shown in the picture below.

![Create meshWorkspace](assets/create-workspace.png)

## Step 3: Create your First Service 

The most central aspect of an Internal Developer Platform is offering services to other teams in your organization to jumpstart their projects, secure their application or extend their environments with additional resources.

In order to start the step by step guide for you first building block, access the created workspace and click on Platform Builder on the top right corner.
To offer your first service with meshStack, follow [AWS S3 Quickstart Guide](./meshstack.building-aws-quickstart-guide.md).


---


---
id: meshstack.gcp.metering
title: Metering
---

meshStack imports metering data from [GCP Cloud Billing data BigQuery Export](https://cloud.google.com/billing/docs/how-to/export-data-bigquery). Any data that was exported to the BigQuery dataset before the start of the month in which meshStack GCP metering was enabled will not be collected.

meshStack also periodically collects the currently active projects in order to apply the per tenant fee.

## Configuration

[Connection information](meshstack.how-to.integrate-meshplatform-gcp-manually.md#set-up-the-service-account-for-metering) and metering behavior can be configured via the [Platform Connection Configuration](administration.platforms.md#platform-connection-config).

## Billing Data Import

The data is collected incrementally from the exported billing data by filtering by the `export_time` attribute.
Any entries with `cost_type` `tax` are ignored in the metering process.
The monthly totals are calculated by aggregating by the `invoice.month` attribute.

## Configuring Seller Information

If you would like to see the GCP costs attributed to a seller in the [chargeback statments](./meshcloud.project-metering.md#chargeback-statements), a product needs to be created manually in the meshcloud [Product Catalog](meshstack.billing-configuration.md#defining-a-custom-product-catalog). This product should have a `resourceType` of `sellerInfo` and should be scoped to a `platformType` of `Gcp`. An example is shown below.

```json
{
    "resourceType": "sellerInfo",
    "displayName": "GCP Seller Info",
    "scope": {
        "platformType": "Gcp",
        "location": null,
        "platformInstance": null,
        "localProjectId": null
    },
    "usageTypes": [],
    "description": "",
    "sellerId": "GCP",
    "sellerProductGroup": null,
    "@metadata": {
        "@collection": "Products",
        "Raven-Java-Type": "io.meshcloud.kraken.core.metering.Product"
    }
}
```

## Additional Filter

Filter the costs meshStack collect via the `Additional Filter` option.

Example for a filter for projects in organization `632614034120` and folder `493343334220`:

`and STARTS_WITH(project.ancestry_numbers, '/632614034120/493343334220')`


---


---
id: meshstack.user-group-provisioning
title: User & Group SCIM Synchronisation
---

Provisioning users and groups to meshStack works based on the [SCIM 2.0](https://en.wikipedia.org/wiki/System_for_Cross-domain_Identity_Management) standard.
We provide an SCIM API that enables external systems such as an Azure Active Directory (AAD) to directly
manage up-to-date user and group information within meshStack. `Provisioning` means changes about users and groups
in the external system are automatically mirrored to the provisioned equivalents in meshStack. For example, when
the members of a certain AAD group are changing and provisioning is set up, those changes will be reflected in the group within meshStack as well
without additional effort. That way we can model the complete lifecycle of users and groups automatically.

## Enable SCIM

By default, in meshStack, users can be created using a variety of methods such as the Panel, IDP, and other available options. If you prefer to manage
your users exclusively via SCIM, you need to enable this setting in the Admin area. This disables all other methods to prevent conflicts and double
assignments. To enable SCIM, go to the Settings page in the Admin area, and in the 'Manage' tab, turn on the 'SCIM only user management' button.
By default, this button is turned off, allowing users and groups to be created through other means.

<img src="assets/scim-user-management.png" alt="SCIM only user management">

## Provisioning with SCIM

SCIM clients are the source for users and groups. They need to address users and groups in order to manage the creation,
updates and deletion. Because they cannot know user or group identifiers in advance they will attempt to find a user or
group by a unique attribute: for users it selects the `userName`, for groups it uses the `displayName`. As a result these fields need to be unique.
To support a wider range of userName formats, meshStack will look up users by their username and uses the email
as a fallback.

**Attention** Each SCIM client handles requests a bit differently. The way the scope of the synchronization is specified plays a huge role when it comes to load and performance. Because of this we specify the officially supported amount of groups and users for each client for now. For the AAD SCIM client we support the synchronization of an unlimited amount of groups with a maximum of 250 users each at the moment. If you want to sync more users please reach out to us via <support@meshcloud.io>.

### Example

The AAD as an SCIM client looks up an existing user by calling:

```sh
GET .../api/scim/v2/Users?filter=userName+eq+"johndoe@company.com"
```

Let's assume there is a user with the username `johndoe@company.com`, then meshStack will then answer with an SCIM ListResponse containing
the matching UserResource, e.g. like this:

```json
{
  ...
  "Resources": [
    {
      "schemas": [
        "urn:ietf:params:scim:schemas:core:2.0:User"
      ],
      "id": "54fbbbaa-c80c-49df-b13d-27133cb81740",
      "userName": "johndoe@company.com",
      ...
    }
  ],
  ...
}
```

From that response the AAD retrieves the user's id and can from now on refer to this user with the identifier `54fbbbaa-c80c-49df-b13d-27133cb81740`.
Let's further assume that the AAD wants to update the members of a group with the identifier `d90c1657-63b1-44be-8cdc-e3a8ffc5a7d1` and the aforementioned user
is the only member, then the AAD will send the following PatchOperation:

```sh
PATCH .../api/scim/v2/Groups/d90c1657-63b1-44be-8cdc-e3a8ffc5a7d1
{
    "schemas": [
        "urn:ietf:params:scim:api:messages:2.0:PatchOp"
    ],
    "Operations": [
        {
            "op": "Add",
            "path": "members",
            "value": [
                {
                    "value": "54fbbbaa-c80c-49df-b13d-27133cb81740"
                }
            ]
        }
    ]
}
```

## SCIM API limitations

The SCIM standard introduces comprehensive functionality to work with user and group resources.
The implementation of meshStack's SCIM API does not support all features of SCIM. Here is a list of current limitations:

- SCIM endpoints on `/ResourceTypes` and `/Schemas` are not supported
- Filtering options to search resources are reduced:
  - For users: only simple equals filters on *one* of the following fields: `id`, `userName`, `externalId`
  - For groups: only simple equals filters on *one* of the following fields: `id`, `displayName`
- The parameter for excluded attributes in the search endpoints is limited:
  - For users to: `name`, `userName`, `emails`
  - For groups to: `members`, `displayName`

## Global Groups

The established concept of a group in meshStack is called a "meshWorkspaceUserGroup". Those are always related to a meshWorkspace,
so they exist with a relation to one.  With the provisioning of users and groups to meshStack we introduce a new type of
groups called "global groups". Those are not owned by a meshWorkspace but are rather available to all of them.
They cannot be modified manually or programmatically but are synced only via an external system, in this case an Azure AD.
Assignment of global groups to meshWorkspaces and meshProjects within the meshPanel works the same way as it does for meshWorkspaceUserGroups.

## AAD Configuration

The following guide shows how an AAD can be configured to enable SCIM user and group provisioning to meshStack. In order
to connect to meshStack you will need a Basic Authentication user with permissions to access the SCIM Api. Please refer
to the [Authentication](/api/#authentication) section within the API Docs for the credentials configuration.

### General Setup Steps

To set up the provisioning on AAD side, have a look at [Microsoft's guideline](https://docs.microsoft.com/en-us/azure/active-directory/app-provisioning/configure-automatic-user-provisioning-portal) and please follow these steps:

1. [Enable SCIM](meshstack.user-group-provisioning.md#enable-scim) in meshStack.
2. Create a new non-gallery Enterprise Application (EA) in your AAD that is dedicated to the provisioning. A step-by-step guide is available [here](https://docs.microsoft.com/en-us/azure/active-directory/app-provisioning/use-scim-to-provision-users-and-groups#getting-started).
3. In the EA set up the meshStack endpoint as target API:
   1. Go to the "Provisioning" section and then to "Admin Credentials"-
   2. Use your meshStack's backend URL as endpoint: `https://meshfed.<meshStack>/api/scim/v2/`.
   3. Create an [API user](administration.apiusers.md) with permission `Use all SCIM endpoints provided by meshStack` in meshStack.
   ![Create API User](assets/aad-user-and-group-sync.png)
   4. Set the base64 encoded Basic Auth Credentials as "Secret Token".
   ![Set Secret Token](assets/scim-secret-token.png)
4. Go to "Settings" menu within "Provisioning" and configure which users and groups should be provisioned. You can either:
   1. Sync only users and groups that are assigned to your EA.
   2. Sync all users and groups from your AAD. This option should always be combined with Scopes as described in the step below.
5. To fine-tune which users and groups are synced go to "Provisioning", then "Mappings" and then to "Users" / "Groups". For users and groups you can separately define Scoping Filters as described in the [official guidelines](https://docs.microsoft.com/en-us/azure/active-directory/app-provisioning/define-conditional-rules-for-provisioning-user-accounts#create-scoping-filters) from Microsoft.
    - Add filter rules by navigating to the `Attribute Mapping`, then go to `Source Object Scope` and select `Add scoping filter`. This applies for both groups and users.
    ![assets/aad_provisioning_scim/scim_source_object_scope.png](assets/aad_provisioning_scim/scim_source_object_scope.png)

6. In the Mapping for Users make sure that you have the mappings configured as described in the [user mappings table](#user-mappings-table) and remove all other mappings. Note that the externalId attribute should be mapped to the AAD Attribute that is used as the euid in meshStack.
7. Start the provisioning process and regularly monitor the provisioning logs.

### User Mappings Table

| AAD Attribute                                                 | SCIM app attribute (meshStack)             |
|---------------------------------------------------------------|--------------------------------------------|
| userPrincipalName                                             | userName                                   |
| Switch([IsSoftDeleted], , "False", "True", "True", "False")   | active                                     |
| displayName                                                   | displayName                                |
| mail                                                          | emails[type eq "work"].value               |
| givenName                                                     | name.givenName                             |
| surname                                                       | name.familyName                            |
| Join(" ", [givenName], [surname])                             | name.formatted                             |
| Attribute which is used as euid in your meshStack             | externalId                                 |

### How to map attributes via expressions

In various scenarios, modifying user attributes before synchronizing them with meshStack can be beneficial. For instance, certain organizations require the utilization of specialized user accounts for administrative tasks. These "admin users," in contrast to "normal users" employed for daily office activities, frequently lack email attributes. The following is a method to establish a mapping that assigns the email attribute using an expression.

Navigate to the enterprise application and open the expression builder.
Use the expression builder to build the desired expression.

![Expression builder](assets/aad_provisioning_scim/mapping-1.png)

In this example, the expression is `IIF(Left([userPrincipalName], 4) = "sadm", [otherMails], [userPrincipalName])`.
When a user's userPrincipalName begins with `sadm`, the otherMails attribute is retrieved. If it does not begin with `sadm`, then the userPrincipalName itself is returned.

After finalizing the expression, proceed to open the user mapping settings.

![User mapping table](assets/aad_provisioning_scim/mapping-2.png)

Within the user mappings table, edit the attribute you want to modify.

![Edit attribute in user mapping table](assets/aad_provisioning_scim/mapping-3.png)

Choose Mpaping type Expression and insert the expression you have built earlier.

![Insert expression](assets/aad_provisioning_scim/mapping-4.png)

The synchronisation will now use the expression to map values from Entra ID to meshStack users.


## User Lifecycle with AAD and SCIM

The following section describes how users are created and removed from meshStack when you have Azure Active Directory
(AAD) configured as described above.

### Creation

AAD sends a request to create a user via SCIM if that user is in the provisioning scope of the Enterprise Application.

### Deactivation

SCIM deactivation requests are sent, for example, in the following cases:

- A user has moved out of the provisioning scope.
- A user was explicitly disabled in AAD.
- A user was removed in AAD, but not permanently deleted yet: If the user is still visible in the "Deleted users"
  section in AAD, then the user is deactivated, but not deleted.

Deactivating a user via SCIM has the following consequences in meshStack:

- The user will have their access rights revoked from all platforms.
- The user will be unable to log in to meshPanel. This is also the case when federated authentication is used with an
  IdP other than AAD. For example, if AAD is used to synchronize users to meshStack, but Google SSO is used for
  authentication, users are unable to login if AAD deactivated them via SCIM, regardless of their activation status in
  Google.

User deactivation is reversible: If meshStack subsequently receives an SCIM request to activate this user, then the user
will regain their previous access rights on all platforms as well as the possibility to log in to meshPanel.

### Deletion

SCIM deletion requests are sent, for example, in the following cases:

- The user was *permanently* deleted in AAD.
- The user was previously deleted in AAD, and has now automatically been permanently deleted in AAD after a given
  period (usually 30 days) has passed.

**Attention**: A previous version of this guide has explicitly demanded to configure AAD such that user deletion via
SCIM is disabled, because previous versions of meshStack did not support deletion. With the current version of
meshStack, deletion is supported. If you have previously disabled user deletion and now want to enable it, please
proceed as follows:

In the Azure portal, visit the service "Azure Active Directory" and the section "Enterprise Application". Then, navigate to
"Provisioning" → "Edit attribute mappings" to see the user mapping. Below "Target Object Actions", three checkboxes are
displayed: "Create", "Update" and "Delete". Ensure that all three checkboxes are checked.

Deleting a user via SCIM has the following consequences in meshStack: The user will be irrevocably deleted and only the
bare minimum of information required for GDPR compliance is retained. After deletion, it is possible to create a new
user with the same username and email as the previously deleted user, but the deleted user cannot be restored.


---


---
id: meshstack.aws.landing-zones
title: Landing Zones
---

AWS Landing Zones use Cloud Formation templates to orchestrate configuration of managed AWS accounts. In the following section the options for this Landing Zone are described.

You have two paths for provisioning AWS accounts. You can simply use CloudFormation StackSets in order to bootstrap your account or you can use an existing, "external" (in the sense of not controlled via meshstack) Account Vending Machine (AVM). Decide for a bootstrap path and configure the Landing Zone accordingly.

## Parameters

Each Landing Zone has parameters which control its behavior. The available parameters are described below.

### Target Organization Unit ID

This parameter is optional. If it is set all meshProjects placed under this Landing Zone will be put under this Organization Unit (OU). This might be helpful if a SCP (Service Control Policy) should be assigned to all of these projects. If left empty a new OU will be created for every workspace and all of his meshProjects with AWS platform will be placed in it.

You must provide the ID of the OU which can be found in the AWS Organizational Management panel. The IDs start with `ou-*`.

You can also use a root account under which the accounts will be placed when they are created. Root IDs start with `r-*`.

### Account Enrollment

This parameter defines whether created AWS accounts of this Landing Zone are enrolled with AWS Control Tower or not. In order to successfully enroll accounts, an already enrolled [Target Organization Unit ID](#target-organization-unit-id) has to be defined. The enrollment also requires a global enrollment configuration set for the AWS platform, as specified in [AWS Control Tower Integration](./meshstack.aws.index.md#aws-control-tower-integration)

### AccessStack Template URL

This StackSet will be created in every new AWS account. It usually contains simple bootstrapping resources such as required roles.

### StackSet ARN

Platform Operators can also configure an [CloudFormation StackSet](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/what-is-cfnstacksets.html) on an AWS Landing Zone. meshStack will then ensure that all AWS Accounts provisioned using this Landing Zone will receive a StackInstance from the StackSet. This allows Platform Operators to leverage that StackSet to centrally manage configuration and resources for all AWS Accounts under the landing zone.

Each AWS project which now gets this Landing Zone assigned will be setup to receive the Cloud Formation Stack Instance setup.

The following parameters can be used in the StackSet template:

| Parameter      | Description                                                                                                                     |
| -------------- | :------------------------------------------------------------------------------------------------------------------------------ |
| AccountName    | Name of the created [AWS account](https://docs.aws.amazon.com/organizations/latest/APIReference/API_Account.html)               |
| AccountEmail   | Email associated with the created [AWS account](https://docs.aws.amazon.com/organizations/latest/APIReference/API_Account.html) |
| AccountId      | Unique Id of the created [AWS account](https://docs.aws.amazon.com/organizations/latest/APIReference/API_Account.html)          |
| AccountArn     | ARN of the created [AWS account](https://docs.aws.amazon.com/organizations/latest/APIReference/API_Account.html)                |
| ProductName    | meshWorkspace Identifier                                                                                                             |
| ~~CostCenter~~ | ID of the CostCenter defined for this meshProject.(Deprecated, please use tagCostCenter)                                        |
| ContactEmail   | E-Mail of the meshProject creator. Currently this is the user who created the project.                                        |
| Stage          | The meshProject identifier                                                                                                          |

In addition, any payment settings, project tags or workspace tags can also be used in the StackSet template. These parameter keys will have the prefix `tag`.
For example, the value of the tag `costCenter` will be made available via the key `tagCostCenter`.

> If you are planning on converting any of the StackSet parameters into AWS tags, please be aware of the limits and requirements
> that AWS has [described in their docs](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html#tag-conventions).
>
> Key takeaways here:
>
> - A resource can have a maximum of 50 user created tags
> - The characters _ . : / = + - @ are not allowed in tag keys or values.
> - Tag keys (and values) are case sensitive. It is recommend to use a consistent capitalizing strategy.

**Known Issues**: If you use parameters in your AWS template please make sure the parameters are used in a resource depending on them. If a parameter is specified without a relationship towards a resource in the template, the update calls to this parameter will get silently ignored from AWS. In such a case the parameter won't receive a new value during a project replication. Only if you reference a parameter in a way that a change will affect a resource a real update is performed. A working parameter update could be this example, where the parameter alters the name of a S3 bucket:

```json
{
  "Parameters": {
    "tagCostCenter": {
      "Type": "String",
      "Description": "ID of the CostCenter."
    }
  },
  "Resources": {
    "ExampleBucket": {
      "Type": "AWS::S3::Bucket",
      "Properties": {
        "BucketName": {
          "Fn::Join": [
            "-",
            [
              "examplebucket",
              {
                "Ref": "tagCostCenter"
              }
            ]
          ]
        }
      }
    }
  }
}
```


#### StackInstance Deploy Region

The StackInstances will be deployed in this region.

> **Important:** A StackInstance can currently only be deployed in one region. In order to work around you can create another StackInstance in different regions triggered by the first instance.

### meshRole to Platform Role Mapping

The meshProject roles must be mapped to AWS specific roles. Your are able to control this mapping with a Landing Zone setting. You can specifiy these mappings by adding role mappings and supplying a AWS Role Name here. The replicator will try to create this roles if necessairy so please make sure it has the correct right to do so, otherwise replication will fail. If you dont want to provide the meshStack with these rights
you can also make sure that these roles already exist in AWS and the meshStack will only assign the users to these roles.

You can also add multiple policies to such a role (by providing either a policy name or an ARN). During the meshProject replication meshStack will make sure that these policies are assigned to the AWS role (please make sure the replicator principal is allowed to do so, otherwise replication will fail as well). If no policy is assigned it is assumed that the roles will be pre-configured with the correct roles via for example some kind of account vending machine.

### Lambda ARN

As some users might have already their own custom AWS account provisioning solution, usually called Account Vending Machines (AVM), other mechanisms are needed in order to bootstrap newly created AWS accounts.

While it is possible to trigger an AVM execution via a StackSet a better alternative is usually to trigger it by an custom Lambda function invocation. During the AWS account [replication](./meshcloud.tenant.md) meshStack is able to invoke such a function with custom parameters. From this function the external AVM can start its provisioning process.

> Please make sure the `MeshfedServiceRole` has the rights in order to trigger the configured Lambda.

The Lambda is called synchronously, so please make sure your Lambdas execution time is kept low. If you have to do long running tasks its a good advice to call another lambda in an async fashion from the initial Lambda call, so you can return to the replication code without hitting HTTP timeouts.

If the function could not be invoked because of a server error for example a permission error prevents the function of being called, this is regarded as a replication error and will fail the project replication.
If the function itself signals an error, the error code returned by the function is currently not used but only logged for reference. This is done in order to allow the replication of the meshProject to be continued.

The following parameters can be used in the Lambda function and are provided as a JSON payload like the following pattern:

```json
{
  "AccountName": "max-muster",
  "AccountEmail": "max@muster.de",
  // ...
}
```

| Parameter      | Description                                                                                                                     |
| -------------- | :------------------------------------------------------------------------------------------------------------------------------ |
| AccountName    | Name of the created [AWS account](https://docs.aws.amazon.com/organizations/latest/APIReference/API_Account.html)               |
| AccountEmail   | Email associated with the created [AWS account](https://docs.aws.amazon.com/organizations/latest/APIReference/API_Account.html) |
| AccountId      | Unique Id of the created [AWS account](https://docs.aws.amazon.com/organizations/latest/APIReference/API_Account.html)          |
| AccountArn     | ARN of the created [AWS account](https://docs.aws.amazon.com/organizations/latest/APIReference/API_Account.html)                |
| ProductName    | meshWorkspace Identifier                                                                                                             |
| ~~CostCenter~~ | ID of the CostCenter defined for this meshProject.(Deprecated, please use tagCostCenter)                                        |
| ContactEmail   | E-Mail of the meshProject creator. Currently this is the user who created the project.                                        |
| Stage          | The meshProject identifier                                                                                                          |

In addition, any payment settings, project tags or workspace tags can also be used as Lambda function parameters. These parameter keys will have the prefix `tag`.
For example, the value of the tag `costCenter` will be made available via the key `tagCostCenter`.

## Account Vending Machines

In order to detect the finished execution of the AVM meshStack looks for certain tags on the AWS account. If such a tag is present the success of the external [replication](./meshcloud.tenant.md) is assumed and the [replication](./meshcloud.tenant.md) process is handed back to meshStack.

Currently the account must contain these tags to be picked up:

- ProductName: Must contain the meshWorkspace identifier
- Stage: Must contain the meshProject identifier

> These tags will soon be customizable in the AWS Landing Zone configuration.

Please contact meshcloud for more details and reference configurations.

## Example meshLandingZone

This section serves as an example on how you can use a meshLandingZone to bootstrap the newly created AWS account.

### Create the Access Stack

Create a meshLandingZone with the following Access Stack configured. This will create the `AWSCloudFormationStackSetExecutionRole` in the newly provisioned account. This role has the [minimum permissions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html#stacksets-prereqs-advanced-perms) for StackSets to work plus IAM permissions. The IAM permissions are needed because the StackSet we deploy later on will need to perform some IAM operations.

```json
{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Parameters": {
    "AutomationAccountId": {
      "Type": "String",
      "Default": "987654321321",
      "Description": "The ID of the Automation Account"
    }
  },
  "Resources": {
    "AWSCloudFormationStackSetExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": "AWSCloudFormationStackSetExecutionRole",
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "AWS": {
                  "Fn::Join": [
                    "",
                    [
                      "arn:aws:iam::",
                      {
                        "Ref": "AutomationAccountId"
                      },
                      ":root"
                    ]
                  ]
                }
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "Path": "/",
        "Policies": [
          {
            "PolicyName": "MinimumCloudFormationPolicy",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "cloudformation:*",
                    "s3:*",
                    "sns:*"
                  ],
                  "Resource": "*"
                }
              ]
            }
          },
          {
            "PolicyName": "AllowStackSetsToCreateIAMResources",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "iam:*"
                  ],
                  "Resource": "*"
                }
              ]
            }
          }
        ]
      }
    }
  }
}
```

### Create the StackSet

Create a StackSet in the automation account via the AWS console using the following template and set the StackSet ARN in the meshLandingZone to the ARN of the newly created StackSet.

This StackSet example defines two roles. One is the `OrganizationAccountAccessRole` which has admin privileges. This role trusts the management account and can be used to login to the new account with admin privileges if you require that. The other role is the `CrossAccountLambdaExecutionRole` which will be assumed by the Automation Account's Lambda function to perform its tasks.

After creating the StackSet, configure the StackSet section in the meshLandingZone with the ARN.

> Update the following Default parameters with the correct values.

```json
{
  "Parameters": {
    "ManagementAccountId": {
      "Type": "String",
      "Default": "123456789123",
      "Description": "The ID of the Management Account"
    },
    "AutomationAccountId": {
      "Type": "String",
      "Default": "987654321321",
      "Description": "The ID of the Automation Account"
    }
  },
  "Resources": {
    "OrganizationAccountAccessRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": "OrganizationAccountAccessRole",
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "AWS": {
                  "Fn::Join": [
                    "",
                    [
                      "arn:aws:iam::",
                      {
                        "Ref": "ManagementAccountId"
                      },
                      ":root"
                    ]
                  ]
                }
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "Path": "/",
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/AdministratorAccess"
        ]
      }
    },
    "CrossAccountLambdaExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": "CrossAccountLambdaExecutionRole",
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "AWS": {
                  "Fn::Join": [
                    "",
                    [
                      "arn:aws:iam::",
                      {
                        "Ref": "AutomationAccountId"
                      },
                      ":role/AutomationAccountLambdaServiceRole"
                    ]
                  ]
                }
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "Path": "/",
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/IAMReadOnlyAccess"
        ]
      }
    }
  }
}
```

### Create the Lambda

Create the `AutomationAccountLambdaServiceRole` with the following policy and trust relationship in the automation account. Additionally attach the `AWSLambdaBasicExecutionRole` managed policy so that the Lambda can log to CloudWatch.


<!--DOCUSAURUS_CODE_TABS-->
<!--Policy-->
```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AllowAssumeRoleForCrossAccountAccess",
            "Effect": "Allow",
            "Action": "sts:AssumeRole",
            "Resource": "arn:aws:iam::*:role/CrossAccountLambdaExecutionRole"
        }
    ]
}
```
<!--Trust relationship-->
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```
<!--END_DOCUSAURUS_CODE_TABS-->

Create the Lambda function that will run the automation. Set the Execution Role of the Lambda to `AutomationAccountLambdaServiceRole`.

```python
import json
import logging
import boto3

import http.client

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)


def lambda_handler(event, context):
    logger.debug("Received event " + json.dumps(event))
#  E.g EVENT FORMAT:
# {
#     "tagEnvironment": "Test",
#     "tagConfidentiality": "Public",
#     "tagYOUR_REPLICATED_TAG": "VALUE",
#     "ProductName": "CUSTOMER_NAME (meshcloud)",
#     "ContactEmail": "CONTACT_EMAIL (admin@meshcloud.io)",
#     "Stage": "PROJECT_NAME (test-aws-integration)",
#     "AccountName": "CUSTOMER_NAME.PRODUCT_NAME (meshcloud.test-aws-integration)",
#     "AccountEmail": "AWS_ROOT_ACCOUNT_EMAIL (awsexample+meshcloud.test-aws-integration@meshcloud.io)",
#     "AccountId": "NEW_ACCOUNT_ID (001228688548)",
#     "AccountArn": "NEW_ACCOUNT_ARN (arn:aws:organizations::122242404000:account/o-9y4kda3oxr/001228688548)"
# }

# E.g HTTP REQUEST TO ANOTHER WEBSITE
    connection = http.client.HTTPSConnection("httpbin.org")
    headers = {
        "Meshcloud-Replicated-Environment-Tag": event['tagEnvironment'],
        "Meshcloud-Account-Id": event['AccountId'],
        "Meshcloud-Customer-Name": event['ProductName'],
        "Meshcloud-Project-Name": event['Stage'],
        'Content-type': 'application/json',
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36"
    }
    body = json.dumps({"Hello": "World!"})
    connection.request('GET', "/anything", body, headers)
    response = connection.getresponse()
    print(response.read().decode())

# ASSUME CROSS ACCOUNT ACCESS ROLE FROM NEW ACCOUNT
# You can assume the role that you have created with StackSet template and execute custom automations on your new account.
    accountId = event["AccountId"]
    sts = boto3.client('sts')
    assumed_role_object = sts.assume_role(
        RoleArn="arn:aws:iam::"+accountId+":role/CrossAccountLambdaExecutionRole",
        RoleSessionName="LambdaSession"
    )

    logger.debug("Successfully assumed role in the new account.")

    credentials = assumed_role_object['Credentials']
    accessKey = credentials['AccessKeyId']
    secretKey = credentials['SecretAccessKey']
    sessionToken = credentials['SessionToken']

# E.g Print all IAM Roles from the new Account
    iam = boto3.client(
        'iam',
        aws_access_key_id=accessKey,
        aws_secret_access_key=secretKey,
        aws_session_token=sessionToken
    )

    logger.debug("Print all roles from the new acccount:")
    response = iam.list_roles()
    for role in response['Roles']:
        logger.debug(role['RoleName'])

    return {
        'statusCode': 200,
        'body': 'Success'
    }
```

Configure the Lambda ARN in the meshLandingZone with the ARN of the above created Lambda.
This Lambda will be invoked during account provisioning and execute the automation.


---


---
id: meshstack.building-blocks.self-hosted-runners
title: Self-Hosted Runners
---

> Self-hosted runners are not GA yet. This documentation is an early draft until self-hosted runners are GA.

You can host your own runners and customize the environment used to execute building blocks.

Self-hosted runners offer more control of hardware, operating system, and software tools than meshcloud-hosted runners provide. Self-hosted runners can be physical, virtual, in a container, on-premises, or in a cloud.

Your runner connects to meshStack via meshStack API. 

## Differences between meshcloud-hosted and self-hosted runners

meshcloud-hosted runners offer a quicker, simpler way to execute your building blocks, while self-hosted runners are a highly configurable way to execute building blocks in your own custom environment.

### meshcloud-hosted runners

- Receive automatic updates for the operating system, preinstalled packages and tools, and the self-hosted runner application.
- Are managed and maintained by meshcloud.
- Support the natively available implementation types.

### Self-hosted runners

- Can use cloud services or local machines that you already pay for.
- Are customizable to your hardware, operating system, software, and security requirements.
- Support workload identity federation.
- Support custom implementation types.

## Requirements for self-hosted runner machines

You can use any machine as a self-hosted runner as long at it meets these requirements:

- The machine can reach your meshStack instance API.
- The machine can reach APIs involved in executing building blocks.
- The machine has enough hardware resources for the type of building blocks you plan to run.

## Communication between self-hosted runners and meshcloud

The self-hosted runner connects to meshcloud to receive building block executions.

Since the self-hosted runner opens a connection to your meshStack, you do not need to allow meshStack to make inbound connections to your self-hosted runner.

```mermaid
graph LR

subgraph meshStack
  API
end

subgraph private network
  runner[self-hosted runner]
end

runner --HTTPS via public internet--> API
```

Additionally, self-hosted runner may need to download additional binaries. For example, the terraform runner reference implementation will download the terraform binary for the version defined in the building block definition.

## Self-hosted runner security

To eliminate the need for long lived credentials, you can set up workload identity federation for communication with cloud provider APIs for your self-hosted runners.


---


---
id: marketplace.service-management-area
title: Service Management Area
---

> Please note that the following functionality is only available to meshStacks that have the **Service Economy** module activated.
> Reach out to your Customer Success representative if you are interested in using this module.

## Introduction

The Service Management Area can be used by workspaces to offer their [platform services](./marketplace.index.md#platform-services) to the rest of the organization.
For example, the Azure team in your organization could set up a workspace to offer their Azure [Platform](./administration.platforms.md) from there to
the rest of the organization. Or the Networking team might want to offer their best-practice Cloud Network [Building Blocks](./administration.building-blocks.md)
to Application Teams.

Anyone in the organization can offer their valuable services to the rest of the organization through the
Service Management Area as long as it is approved by someone in the [Admin Area](./administration.index.md).

The Service Management Area can at any time be opened up from the Workspace Control Plane by clicking the
"Go to Services Management" button as depicted below.

![Introduction](assets/service-management-area/introduction.png)

If you would like to go back again to the regular Workspace View, click on "Go to Workspace Management".

## Getting Access

If you do not see the button to open the Service Management Area your workspace most likely does not 
have it activated yet. As can be seen in the screenshot, open your Workspace Settings and toggle "Enable Service Management Area".
Hit "Save" and you should see the "Go to Services Management" button now.

[!Getting Access](assets/service-management-area/getting-access.png)

## Types of Platform Services

The following three types of platform services can be created and offered in the Service Management Area:

1. [Platforms](./administration.platforms.md). Platforms are a high-level concept in meshStack where users can book
   their own isolated tenant (environment) in a given cloud platform. meshStack has a handful of first-party supported
   platforms, but it also offers the ability to [create your own platforms](./meshstack.how-to.create-your-own-platform.md)
   with the use of Terraform.
2. [Building Blocks](./administration.building-blocks.md). Building Blocks are standardized extensions to cloud tenants that users
   can book and roll out. These can be either rolled out using Terraform, or manually. Example use cases are an on-premise
   connectivity to a cloud tenant.
3. [Service Brokers](./administration.service-brokers.md). Service Brokers are self-hosted components that can execute
   automation and provision workloads using the Open Service Broker API that can be booked by users in the meshStack.
   As the automation is fully managed by someone it can provision and do anything that you would like.

## Development & Testing

By default, anything that you create in your Service Management Area will be available to you inside the workspace and 
not directly published in the Service Catalog.
For development & testing purposes you can consume any of your created platform services mentioned above in
**your own workspace**. They will be marked as "Private". This will give you an idea of the user experience and allows you
to debug any potential issues with the Platform Configuration or Terraform code.

![Private](./assets/service-management-area/private.png)


## Publishing

After you are done with the development & testing phase, you can go the Control Plane of your provided service in the Service Management Area and submit it for publication by clicking the "Submit for publishing" button.

![Publishing](./assets/service-management-area/publish-button.png)

Once approved by your cloud foundation team, it will become accessible to all workspaces within the organization.
If your publication request gets rejected, you can easily identify the reason by hovering over the rejected label or checking the rejection comment in the history.

![Rejection](./assets/service-management-area/rejection-details.png)

Once you've addressed the identified issues, you can resubmit it for publishing.

> If you are an administrator and want to know how
> to manage and approve workspaces service you can learn more [here](./administration.workspace-services.md).


---


---
id: meshstack.aws.reserved-instance-guide
title: Reserved Instances & Savings Plans Guide
---

## Benefit Priority

An important piece of information regarding Reserved Instances to know before following this document, quoting from the AWS documentation,

> Reserved Instances are first applied to usage within the purchasing account, followed by qualifying usage in any other account in the organization.

and regarding Savings Plans

> In a Consolidated Billing Family, Savings Plans are applied first to the owner account's usage, and then to other accounts' usage.

Because of this, there are two main approaches when purchasing Reserved Instances and Savings Plans

## Centralized Purchase

In this approach, the Cloud Foundation team buys the Reserved Instances and Savings Plans under their own AWS Account.

Because of how AWS applies the benefit of Reserved Instances, if the cloud foundation team is not running any workload, all other AWS accounts in the organisation will have the opportunity to benefit from the purchased reserved instances and savings plans. When using this approach, charging the amortized cost of the usage is enough for the chargeback process. The same applies for Savings Plans.

Since the Cloud Foundation Team has a good overview of the resource usage across all accounts, having the cloud foundation team purchase the Reserved Instances and Savings Plans can result in optimum utilization.

## Individual Purchase

In this approach, the teams themselves (or meshWorkspaces in meshcloud terminology) pay the Cloud Foundation team upfront, and the Cloud Foundation team buys Reserved Instances and Savings Plans under the meshWorkspaces' tenants.

There might be meshWorkspaces/meshProjects that can estimate their own workload and would prefer to have Reserved Instances or Savings Plans that give them priority. This ensures them the benefit of the RI or SP rather than having to share with other tenants and only have a chance of benefiting. Or a certain team (meshWorkspace) has leftover budget from the current budgeting period and would like to purchase RIs or SPs with that.

In this situation, the payment to the Cloud Foundation team happens at the time of purchase, and such tenants should not be charged for the usage of the RI and SP via the amortized cost, because they have already pre-paid. (Note that the upfront fee component is only available in All Upfront and Partial Upfront RIs & SPs. It doesn't apply for No Upfront ones.)

To allow for this workflow, meshStack can be configured to add a line item in the tenant usage report for the month on which the Reserved Instance or Savings Plan starts, and the amount of this line item will be equal to the upfront payment of the RI or SP. Additionally, a discount which is equal to the amortized upfront cost will be added to the report every month until the end of the RI or SP lifetime.

This discount will achieve one of the following results

1. **Cancel out the amortized cost for usage** : If the purchasing account fully used the RI or SP, this discount will cancel out that usage, because they have already paid for that upfront.

2. **Cancel out the amortized cost for non-usage** : If the purchasing account did not use the RI or SP and no other account utilized it either, there would be amortized cost line items in the tenant usage report for this non-usage. These would also be cancelled out by the above mentioned discount, because the purchasing application team (represented by a meshWorkspace) has already made the payment upfront.

3. **Provide a discount in the case of some other account utilizing it** : If the purchasing account did not use the RI or SP but some other account did use it, then the other account will pay the cost of the usage to the Cloud Foundation team via the amortized costs. The purchasing account will effectively get a reduction in their total costs via the above mentioned discount.

Enabling these settings allows Platform Operators to consciously deviate from the default accrual basis accounting (via amortized cost) and switch to a "cashflow basis" accounting for RI/SP usage. The benefit of enabling this setting is that it will give a more accurate view of the usage of the budget by a meshProject.


---


---
id: meshstack.building-aws-quickstart-guide
title: AWS S3 Quickstart Guide
---

## Introduction

Welcome to the **AWS building block quickstart guide**! This guide provides step-by-step instructions to help you
quickly set up your first meshStack building block and deploy AWS resources using Terraform.

## Goals

By the end of this guide, you will have achieved:

1. Creating a [building block definition](./administration.building-blocks.md) that deploys an AWS S3 Bucket using Terraform.
2. Deployed & tested the building block.
3. Publishing the building block on the marketplace.

## Prerequisites

Before starting, ensure you have the following:

- An AWS account with a service user that has permission to manage S3 buckets.
  - Tip: have a look at our [Terraform code](https://github.com/meshcloud/meshstack-hub/tree/main/modules/aws/s3_bucket/backplane) for defining a service user to learn more.
- Terraform code to provision an S3 bucket. We highly recommend using our [template](https://github.com/meshcloud/meshstack-hub/tree/main/modules/aws/s3_bucket/buildingblock) to get started.
- Access to a meshStack workspace that has the [service management area enabled](./marketplace.service-management-area.md).  
  If you do not see the service management area, go to settings -> general in your workspace and enable the service management area.

## Creating Definition

1. **Open the list of building block definitions in the service management area.**

   When entering your workspace, click the blue “Go to Services Management” button at the top-right if you haven’t already.
   Then open the menu on the left-hand side and click on “Building Blocks → Building Blocks”.

2. **Create a new building block definition**

   In the list, click on the button “+ Create new Definition”. A wizard will open where we will have to enter all
   the necessary information to run the S3 bucket using Terraform.

3. **Select a type**

   For this guide, select “Workspace Building Block”. It works without needing a tenant, which makes things simpler.

4. **Configure appearance**

   Now enter a fitting name, description, and logo. You can also use our example information below:

   Name: `AWS S3 Bucket`

   Description: `Deploy a simple AWS S3 Bucket based on best practices. You will be able to read and write into this bucket.`

   Logo: You can copy the logo from below or use your own.

   ![Simple Storage Service.png](./assets/s3_logo.png)

5. **Skip over other settings**

   You can also enter more information on this screen, but you can leave all of this as it is for now.

   - Notification user: receive notifications when things require their attention. This is set to your user by default.
   - Support & documentation: you can enter URLs that will be visible to users in the marketplace to request support or read more documentation.

6. **Entering Terraform implementation details**

   If still on the general page, click “Next” and let’s start filling in all details for running Terraform as part of this building block.

   You will be asked which implementation type to use. Pick “Terraform” here. Additional settings will show up.

   - Enter a desired Terraform version or leave the default value.

   > 💡Any versions entered over 1.5.5 will run using [OpenTofu](https://opentofu.org/).  
   > This is an open-source, friendlier alternative of Terraform.

   - Enable the option “Use meshStack’s Http Backend” if using our template.
     Learn more about how this meshStack backend works [here](./meshstack.building-blocks.meshStack-http-backend.md).
   - Enter a git repository URL. You can either enter your own or use our template, for which the git repository URL
     is `https://github.com/meshcloud/meshstack-hub.git`
       - The AWS Bucket Terraform code is under folder `modules/aws/s3_bucket/buildingblock`.
         Make sure to enter this folder under "Git Repository Path".
   - You can leave "Git Reference" empty for now. With this field, you can pin the used Terraform files to a certain
     git tag, branch, or commit.
   - If you don’t use a self-hosted git repository, a “Test Connection” button will appear.
   - Click this button and if everything is correct you should see all Terraform files related to your AWS S3 bucket.
       - If anything has gone wrong, you will receive an error message instead. Analyze the given error, try to
         resolve the issue, and try again.
   - For “Execution Mode” leave this as it is. In complex scenarios, you can take over the status reporting of your
     building block using meshStack APIs.
   - For “Deletion Mode” leave this as it is too. We highly recommend using “Delete Resources” which means that
     meshStack will clean up the underlying infrastructure resources upon deletion using `terraform destroy`.

7. **Entering inputs**

   If you haven’t already, click “Next” on the implementation page.

   You will land on the “Dependencies” page.

   > meshStack can work with [dependencies between building blocks](./administration.building-blocks.md#dependencies).
   > We will skip this in this quickstart guide.

   Click “Next” again, and you should see a modal pop-up with imported inputs, authentication, and outputs.

   meshStack read out the Terraform files and automatically generated fitting inputs based on the defined variables, outputs, and providers.

   Leave all of them checked and click “Add selected”.

   You will now see all variables that are defined in Terraform plus the AWS authentication environment variables that
   are needed to manage resources in AWS. Let’s fill those in:

   (If you are unsure what rights are needed, take a look at our
   [Terraform IAM definition](https://github.com/meshcloud/meshstack-hub/blob/main/modules/aws/s3_bucket/backplane/iam.tf)
   for this quickstart guide)

   - For `AWS_ACCESS_KEY_ID` add the ID of an access key in AWS that has the right to manage S3 resources in the “Static Value” field.
   - For `AWS_SECRET_ACCESS_KEY` enter the secret of the access key in AWS in the “Static Value” field.

8. **Entering outputs**

   Move on to the outputs page by clicking “Next” on the bottom right.

   The outputs will also be there already based on the import from before. You can leave all of these as they are and click “Create Definition”.

🎉Your definition is created, well done! The hard work is finished. Let’s get to testing your new definition and make sure it works as expected.

## Testing the Definition

After the previous step, you should have landed on the control plane of your new building block definition.  
There should be a wizard explaining what the next step is. Let’s follow those recommendations.

1. **Deploy & start testing**

   Under “Test Definition” you’ll see a blue button “Deploy & Start Testing”. Click on it.

2. **Enter inputs**

   You will be prompted to enter all inputs that were configured before.
   For the "Region" you can leave that to the default and for the bucket name you should pick something globally unique,
   for example `meshstack-aws-s3-quickstart-guide-<your-name>`.
   After that you can click “Deploy Building Block”.

3. **Analyze the run**

   You will be redirected to the list of building blocks, and you should see the newly created building block in a pending state.  
   Let’s open it up and see if it runs successfully. Click on the name of the building block and open up the first run.
   You should see the Terraform logs which are automatically refreshed.

4. **Green light?**

   After a short moment, the building block should finish, and you should have a successful run!  
   If something went wrong, please check out the logs and see if you can resolve the given error.
   You can go back to the settings of the building block definition, make some changes, and trigger
   a new run in the list of runs. Keep trying until the building block runs successfully.

🎉The building block run is successful and with that, you deployed an S3 bucket on AWS using meshStack!

## Publishing the Building Block on the Marketplace

Now that your building block runs successfully in your workspace, let’s make it available to others in your organization via the marketplace.

1. **Open the marketplace**

   Navigate back to your workspace view (click the meshStack logo top-left) and open the **“Marketplace”** tab.
   You’ll see your building block listed there — it will have a **“Draft”** badge, meaning it’s only visible to you right now.

2. **Review your building block**

   Click on your building block to open it. Check that everything looks good — the name, description, logo, and any support or documentation URLs (if set).

3. **Test the consumption flow**

   Click **“Add Service”** to walk through the process your colleagues would use to consume the building block. Fill in the inputs you configured and confirm.

4. **Consume the building block**

   Click on “Add Service” on the top right and let’s see what the consumption process looks like for everyone.

   After clicking “Add Service” you’ll have to fill in the inputs you configured before. Fill them in and confirm.

5. **Submit for publishing**

   Go back to the service management area and open up your building block from before.

   On the top-right click the “Submit for Publishing” button. You will be prompted with some more information about the process.

   Go ahead and click “Yes, submit for review”.

🎉That’s it! Your new building block has now been submitted for review.
Once an admin approves you will be notified via e-mail and your building block
will be published and ready to be used by the rest of the organization! 🎉


---


---
id: meshstack.how-to.onboard-team-to-workspace
title: How to onboard your team to your meshWorkspace
---

If you are not familiar with what a meshWorkspace is, please check the [official meshcloud documentation](meshcloud.workspace.md).

## Pre-Requisites

- Permissions: Your user needs either the Workspace Manager or Workspace Owner role in the meshWorkspace where you want to add further users

## Step to Step Guide

- Make sure you are in the meshWorkspace you want to add further users. Do this by checking the drop-down in the upper-left corner.

![Select meshWorkspace in the upper left corner](assets/workspace/choose-workspace.png "Pick meshWorkspace")

- Go to the access control panel by clicking on the `Workspace Access` tab

![Click the Workspace Access tab](assets/workspace/workspace-access-control.png "Access Control")

- At the end of the `Current Access` list will be an input field. Type in the first-, last-name or email address to find and select the user you want to add. Choose a Workspace Role (Workspace Owner, Admin or Employee) and press the `+` button.

![Add a user to the Workspace](assets/workspace/workspace-access-control-add-a-user.png "add a user")

- Workspace Owner can only be granted to max. 2 users per Worksace. Also, only a Workspace Owner can grant another user the Owner role - except there is no Workspace Owner at all.

### Optional

meshStack provides the optional configuration for 4-eyes access controls.
Please check the [official meshcloud documentation](meshcloud.workspace.md#invite-users-to-a-meshworkspace-team).

- A second user with Workspace Manager or Workspace Owner permission needs to approve the access request. The second user must also navigate to the specific meshWorkspace (see step 1.), go to the `Workpsace Access` tab (see step 2.) and then click on the `Access Requests` tab in the second tab-row.
![Click the Access Requests tab](assets/workspace/workspace-access-approve.png "Access Control - Access Requests")


---


---
id: meshstack.openstack.index
title: Integration
---

OpenStack is an open source cloud platform that many enterprises use as a basis for a private IaaS cloud.
meshStack supports project creation, configuration, access control, quota management and billing for OpenStack.

## Integration Overview

To enable integration with OpenStack, Platform Operators configure one or multiple `Platform`s of `PlatformType` OpenStack in the [Platform Administration](./administration.platforms.md) in meshPanel.

## Prerequisites

OpenStack comes in many different distributions and flavors. Similar to our approach for supporting Kubernetes,
we try and maintain our OpenStack integration distribution-independent and purely based on "vanilla" OpenStack APIs.

The latest OpenStack release officially validated with meshStack is [OpenStack 2023.2 "Bobcat"](https://docs.openstack.org/2023.2/).
However, any later OpenStack releases that continues to maintain API compatibility with the API versions specified below is supported.

> As OpenStack is typically deployed "behind the firewall" in a private cloud settings, you may consider using an on-prem deployment of
> [meshStack Enterprise](./meshstack.managed-service.md). This enables meshStack to safely connect to your OpenStack APIs on your private network.

### Supported OpenStack Versions

Your OpenStack cloud must provide the `KeystoneV3` API with a minimum version of `3.0`.
This an essential pre-requesite for using meshStack's OpenStack integration.

meshStack also supports the following OpenStack APIs for advanced features

| Service and minimum Version                                                                  | [Resource Metering](./meshstack.openstack.metering.md) |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| [Nova 2.0](https://docs.openstack.org/nova/latest/reference/api-microversion-history.html)   | Servers                                                |
| [Cinder 3.0](https://docs.openstack.org/api-ref/block-storage/api_microversion_history.html) | Volumes<br>Volume Snapshots                            |
| [Neutron v2](https://docs.openstack.org/api-ref/network/v2/index.html#api-versions)          | Floating IPs<br>Routers<br>LBaasV2                     |
| [Glance v2](https://docs.openstack.org/api-ref/image/v2/index.html)                          | Images                                                 |
| [Heat v1](https://docs.openstack.org/api-ref/orchestration/v1/index.html#list-versions)      |                                                        |
| [Designate v2](https://docs.openstack.org/api-ref/dns/dns-api-v2-index.html)                 |                                                        |
| [Swift/radowsgw-swift v1](https://docs.openstack.org/api-ref/object-store/)                  |                                                        |

> Note: OpenStack integration with meshPanel as an UI for various OpenStack services is no longer available to new meshStack customers.

### Keystone Federated Users

meshStack will identify and assign users to roles in OpenStack based on their `euid` (external user id) as described in [Identity Federation](meshstack.identity-federation.md#externally-provisioned-identities).
meshStack expects that your OpenStack uses [Federated Identity](https://docs.openstack.org/keystone/2023.2/admin/federation/federated_identity.html). 

You should set up OpenStack Keystone so that your identity provider stores the `euid` value in the `User.name` field of the [Keystone User object](https://docs.openstack.org/api-ref/identity/v3/?expanded=list-users-detail,show-user-details-detail#show-user-details). 

## Integration Configuration

### meshStack Admin Accounts

meshStack requires two admin user accounts for integration with OpenStack. 

- the `replicator` admin account must have permission to create projects, groups and assign roles. This typically requires an `admin` role on the admin project, unless your OpenStack deployment has additional fine-grained policies available.
- the `metering` account must have `reader` role access across all OpenStack projects. This user is used to collect [metering data](./meshstack.openstack.metering.md) for all projects from OpenStack services.

### Permission Replication

During replication, meshStack will make sure that users have access to the OpenStack projects they are assigned to in meshStack.
If meshStack finds that a user does not exist in OpenStack yet, meshStack will log a replication remark and skip assigning that user's permission. 
When the user is created in OpenStack at any later time, meshStack will pick up this user to assign him to the according groups in the next replication.

Users will be assigned to the according groups (per project in meshStack) that meshStack creates in OpenStack.
Because OpenStack does only provide the `member` project-level role out of the box, meshStack currently supports only one default mapping of meshStack project roles to OpenStack project roles for all meshStack project roles.

### Keystone Domains

By default, meshStack will replicate [tenants](./meshcloud.tenant.md) as OpenStack projects in the `default` Keystone domain of OpenStack. You can optionally enable meshStack to create dedicated Keystone domains per Workspace.


---


---
id: meshstack.email
title: Email
---
 
For all email based communication (e.g. for [workspace registration](./meshstack.onboarding.md#workspace-registration)
or [workspace user invitations](./meshstack.onboarding.md#workspace-user-invitations)) meshStack will use the configured SMTP server.

> Tip for enterprise meshStacks: you can configure a custom e-mail footer by creating an object in the `messages` configuration below using mapKey `mail.footer`.
> Any valid HTML can be set as a value here. Contact your customer success team to get it set up.

<!--snippet:mesh.meshfed.mail-->

The following configuration options are available at `mesh.meshfed.mail`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
{-
    The configured smtp mail server is used by meshfed to
    send out notifications.

    enabled:
        If True, meshfed will send out mails.

    username:
        Username meshfed uses to log in at SMTP server.

    password:
        Password meshfed uses to log in at SMTP server.

    host:
        SMTP server address that meshfed connects to.

    port:
        The port that the SMTP server listens on.

    sender:
        address:
            Address that is shown as "sender"
        reply-to:
            Address that is shown as "replyTo"

    smtp:
        ssl:
            If True, enables SSL encryption (must be supported by SMTP server)

        starttls:
            If True, enables STARTTLS encryption (must be supported by SMTP server)

        auth:
            If True, enables authentication (must be supported by SMTP server)

    theme:
        logo:
            href:
                Location of the logo file

            url:
                Url that the image links to

        button-color:
            Color hex code for buttons

        messages:
            List of mappings to configure template messages

-}
  { enabled : Bool
  , username : Text
  , host : Text
  , port : Natural
  , sender : { address : Text, reply-to : Optional Text }
  , smtp :
      { ssl : { enable : Bool }, starttls : { enable : Bool }, auth : Bool }
  , theme : { logo : { href : Text, url : Text }, button-color : Text }
  , messages : List { mapKey : Text, mapValue : Text }
  }
```
<!--END_DOCUSAURUS_CODE_TABS-->

## FAQ

### Which mails is meshStack sending out and to whom?

Application Team receive mails when

- Workspace created
- Workspace permissions created, updated or removed
- Project permissions created, updated or removed
- Project Payment Method Assignment missing
- Budget exceeded
- Executing Building Block succeeded

Platform Operators receive mails when

- Building Block requires input (Recipients are defined per Building Block definition)

Optionally meshStack sends out mails to fixed set of recipients configured in dhall when

- Tenant marked for deletion
- Tenant created
- Replication failed

### Can the style of the mails be influenced? For example via HTML?

Button color and logo are configurable. The `theme.messages` templates support HTML elements like `<br>`.

### Can BCC be added

No. meshStack does not support adding addresses on BCC.


---


---
id: administration.policies
title: Policies
---

Policies are described in detail [here](meshcloud.policies.md). They can be set up between subjects.

The following subjects are available:

- Workspace
- Project
- LandingZone
- User/Group

You can see all existing policies in the **Administration** Area by navigating to **Compliance** > **Policies**.
If you want to see all detected policy violations, you can go to **Compliance** > **Policy Violations** in the **Administration** Area or on a workspace control plane.

> Creating and editing a policy triggers an evaluation process of the policy. This process may take a while. After the process ends, you can see the violations caused by the (updated) policy in the **Policy Violations**.

## Create Policies

Policy creation is only possible for a user who has a partner role.

1. Navigate to **Compliance** > **Policies**.
2. Click on the `+ Create Policy` button in the top right corner. The button is only visible for users with the right permission.
3. Configure your policy.

- **Policy Name**: choose a human-readable display name for the policy

- **Description (optional)**: add a description to make everyone aware of what your policy is about and why it is necessary

- **Policy Subjects**: select the subjects which shall be evaluated

- **Policy Subject Tags**: select a tag on both subjects that shall be evaluated against each other within this policy

- **Policy Evaluation Strategy**: select the evaluation strategy for how the subjects shall be evaluated (click [here](meshcloud.policies.md#policy-evaluation-strategy) to learn more about the different strategies)

- **How to Fix (optional)**: provide an additional hint on how users can resolve the situation when they violate a policy

To learn more about how policies work, please click [here](meshcloud.policies.md).

After creating a policy, every subject defined in the policy will be evaluated. All violations caused by the new policy will be logged. These can be either fixed by workspace managers or partner admins, by picking the right tag values.

## Edit Policies

1. Navigate to **Compliance** > **Policies**.
2. Click on the pencil icon in the 'Actions' column of the policy you want to edit in the policy list.

## Delete Policies

1. Navigate to **Compliance** > **Policies**.
2. Click on the trash icon in the 'Actions' column of the policy you want to delete in the policy list. A checkmark will appear in place of the trash icon.
3. Confirm the deletion by clicking on the checkmark icon within 5 seconds. After the deletion of your policy is finalized, your policy list will be updated. In case you don't confirm the deletion within 5 seconds, the trash icon will reappear.


---


---
id: meshcloud.index
title: Overview
---

## Introduction

Welcome to the meshStack documentation! This part of the documentation is intended for end users
of the meshStack platform. Be aware that meshStack might be rebranded in your organization and has a different name,
but everything you find in the documentation will apply to the meshStack you are using as well.

meshStack is useful for anyone who wants to use platform services in their organization and manage their costs.
Maybe you are an Application team that wants to create a few cloud projects in Microsoft Azure or Google Cloud,
use an organization-specific service like an On-Premise network connector, or maybe you are a Project Manager that
wants to manage the budget of a cloud project.

The actual cloud platforms and services that are available to you depend on the setup of the meshStack and your organization.
One organization might only offer Microsoft Azure, but another might offer all major cloud providers. Your meshStack will automatically
reflect whatever is available in your case.

## Concepts

To work with meshStack, the following concepts are of importance:

- [Workspace](./meshcloud.workspace.md): The workspace is the highest level that you will work with. In here, you will invite
  your entire team of managers, developers and more. In the workspace you will create one or more projects.
- [Project](./meshcloud.project.md): The project is a cloud-agnostic concept which usually maps to an environment of an application
  that you and your team are developing. The project will have a payment method assigned that acts as the budget. On the project
  you invite team members that are needed for that environment, e.g. for a production project you will invite your SRES. Within
  the project, you will have one or more cloud tenants.
- [Tenant](./meshcloud.tenant.md): The tenant is an isolated and tangible place in an actual cloud provider. It depends on what cloud
  you use what this maps to. For example for AWS this maps to an `Account`, for Azure this is a `Subscription` and for Google Cloud
  it is a `Project`. meshStack can easily let you log in and redirect you to the tenant in the respective cloud provider.
- [Landing Zone](./meshcloud.landing-zones.md): The landing zone is a template created by your organization that you pick
  when you create a new tenant. It cannot be changed afterward. The idea of the landing zone is that you already get a set
  of policies and perhaps resources to start using the cloud right away according to the compliance and best practices
  of your organization.
- [Building Blocks](./administration.building-blocks.md): A building block is a piece of infrastructure that can be booked
  by you on top of a tenant. The library of Building Blocks is fully maintained by your administration team, so it depends on
  what is available to you. You can view the library in the meshPanel.
- [Platform](./meshcloud.platforms.md): The platform is the actual cloud platform that you can use to create a new tenant
  and start consuming the cloud. When you create a new project, you can select which platform(s) you want to use and the
  respective tenants will be created in the background.

## meshPanel

The meshPanel is the self-service user interface for meshStack and provides different control planes to manage various aspects of your workspace depending on your rights:

- [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace): Manage the access of your team members in your [meshWorkspace](./meshcloud.workspace.md), change the tags or check the available payment methods for your meshWorkspace.

- [project control plane](./meshcloud.project.md#manage-meshprojects): Get an overview of all tenants of your [meshProject](./meshcloud.project.md). Add new team members to it or change the payment methods of your project.

- [tenant control plane](./meshcloud.tenant.md#using-your-tenant): Access the platform of your [meshTenant](./meshcloud.tenant.md), request Quotas for it or check the [usage reports](./meshcloud.project-metering.md#tenant-usage-reports).

The above description serves as an example what you are able to do as Workspace Manager. Workspace Members will have a lot less
access rights. Check out [Workspace Roles](./meshcloud.workspace.md#meshworkspace-roles) for more details.

> If you are an administrator, please be aware that there are a lot more user interfaces available
> to you. Read more in the [Admin Docs](./meshstack.index.md)

### Supported Browsers

- Firefox ESR
- last 2 Firefox versions
- last 2 Chrome versions

If you experience problems with other browsers like Edge (Chromium), Safari or with mobile browser let us know.
We are interested to make that work as well!

## Contributing

This documentation is open source! Please feel free to hit the `Edit` button any time and help us [improve](https://github.com/meshcloud/meshcloud-docs/blob/master/CONTRIBUTING.md) the documentation. Your feedback is very welcome.

## Getting Updates

We release regularly and provide weekly updates. If you want to stay on top of changes in meshStack you can use the following: 

- Have a look at the roadmap on the website under [www.meshcloud.io](https://www.meshcloud.io/en/product/).
- Subscribe to the [Product Newsletter](https://share.hsforms.com/1AbELCsdRRP6EaCkm1UeATwc0hrp) which is sent out every two weeks summarizing the most important changes.
- Have a look at the [release notes](/blog) or follow either one of [RSS](/blog/feed.xml) or [atom](/blog/atom.xml) directly. 


---


---
id: meshstack.metadata-tags
title: Managing Tags
---

Operators can configure meshStack to collect, attach and distribute organization-specific metadata to various [meshModel](meshcloud.index.md) objects using [metadata tags](./meshcloud.metadata-tags.md).

> To get more insight into how your cloud foundation can improve the use of metadata tags,
> read about [Cloud Tenant Tagging on cloudfoundation.org](https://cloudfoundation.meshcloud.io/maturity-model/security-and-compliance/cloud-tenant-tagging.html).

## Use Cases for Tags

> meshStack currently supports tags on [workspaces](meshcloud.workspace.md), [projects](meshcloud.project.md), [landing zones](meshcloud.landing-zones.md), [building block definitions](./administration.building-blocks.md) and [payment methods](meshcloud.payment-methods.md).
> Additionally, it is also possible to supply [default tags on meshUsers](#tags-on-meshusers) and [workspace user groups](meshstack.workspace-group-sync.md) are freely taggable via the meshStack API.

meshStack acts as an organization's central registry of cloud environments and services. It therefore needs to cover
a wide range of use cases for orchestrating organizational processes across multiple clouds, including;

- centralized management and configuration of [cloud platforms](./meshcloud.platforms.md)
- life-cycle management for [cloud tenants](meshcloud.tenant.md) and [security policy automation](./meshcloud.landing-zones.md)
- centralized Identity and Access Management (IAM) via [multi-cloud identity federation](meshstack.identity-federation.md)
- unified [chargeback process](./meshcloud.project-metering.md) across all cloud platforms and services

Many of these use cases can require organizational metadata to be shared across different systems. Common examples of
such metadata include:

- IT System identifiers that can link cloud tenants to an enterprise configuration management database
- Cost Center and department information
- Security and Operations contacts for a project
- Data Confidentiality Levels
- Project Staging Environment, e.g. QA or production

## Maximum Length for Tag Values

Tag values in meshStack can be up to 255 characters long. Different platforms have their own limits on tag length, character support, and quantity, so ensure they support the tags you want to replicate.

## How to view and define available tags?

> All actions below will require the partner role.

Navigate to **Compliance** > **Tags** in the **Administration** Area:

![Tag List](assets/metadata_tags/admin_area_tags_list.png)

This page will show you all tags that are currently active on supported meshObjects. If you would like to know more details about a tag, or create, edit, or delete a tag, you can do so by clicking on the large arrow ▶️ on the right for a meshObject.
The next page will show you more details about a tag such as the title, description or data type of the tag and allow you to modify existing and define new tags.

### How to modify an existing tag?

1. Navigate to **Compliance** > **Tags**.
2. Click on ▶️ of the meshObject type you want to modify the tag of. A list of active tags of the meshObject type will appear.
3. Click on the pencil icon in the 'Actions' column of the tag you want to edit in the list of active tags.

![Tag Edit](assets/metadata_tags/edit_button.png)


### How to define a new tag?

1. Navigate to **Compliance** > **Tags**.
2. Click on ▶️ of the meshObject type you want to define new the tag for. A list of active tags of the meshObject type will appear.
3. Click on `+ Create Tag` button in the top right corner.

You will be prompted with a new page where you can enter a lot of information. We will briefly explain what each fields means and why you should use it.

> Hint: after entering a name, you can view the tag input as if it were shown to the end user. You can do this on the right-side of the screen where it says 'Tag Preview'.
> This can help you get an idea of how it will look when end-users fill in the tag value.

- **Display Name**: This is the text that will be shown above the input field which the user reads. Note that is **not** the name of the tag itself.
- **Name**: This is the actual name of the tag as it will be displayed in the green bubble. It is also the name that is used for uniquely identifying the tag and when exporting it or when [using it within a landing zone](#exposing-tags-via-landing-zones). This name cannot be changed later (at the moment). We recommend using a name that is similar or the same as the Display Name. Keep in mind that the use of spaces is not allowed since the tag name is used for technical purposes.
- **Description (optional)**: This is the description of the tag that will be displayed in small grey text above the tag input. It is useful for giving extra information to the user when the name of the tag is not explanatory enough.
- **Tag Type**: This is the data type of the tag and also decides what kind of input the user will see. It will depend what you will fill in here depending on your needs. You can see the actual input in the Tag Preview on the right if you are curious how it looks.
- **Regular Expression (optional)**: This is only available for `e-mail` and `string` tag types and can be used to enforce that users enter a certain data format. Also make sure to mention this in the description to help users what to enter.
- **Default Value (optional)**: This can be used to give a default value to the user for contextual help or for filling in a default.
- **Mandatory**: If a tag is mandatory, it means the user cannot create a new meshObject without first filling in this tag value.
- **Restricted**: If a tag is restricted, it means only Partner users can enter this tag value. The input will also not be shown to the end-user when creating a new meshObject. This is useful if an organization doesn't want users to edit these values in self-service. For example, an organization can use restricted tags to implement a "segregation of duty" control to ensure that a partner user confirmed a project's data classification.
- **Immutable**: If a tag is immutable, it means tag values can be assigned only during the creation of a meshObject. Afterwards it is not longer possible to change the tag values.

> Replication is not supported for meshLandingZones

#### Replicate Tags to Cloud Platforms

- **Replication**:  If a tag has replication enabled, it will be used to tag an actual tenant in the cloud platform.
  - **Replication Tag Key**: Although we recommend using the exact same value as **Name** here, it's possible to use a slightly different tag key when it is used for replication. Also, keep in mind that the tag key will be prefixed, depending on what is configured for [tenant tags](#tags-in-cloud-tenants). When a tag key or value does not meet the cloud platforms' requirements, it will automatically be [sanitized](#tag-sanitization)


## How to delete a tag?

1. Navigate to **Compliance** > **Tags**.
2. Click on ▶️ of the meshObject type you want to delete the tag for. A list of active tags of the meshObject type will appear.
3. Click on the trash icon in the 'Actions' column of the meshPolicy you want to delete in the list of active tags. A prompt will appear.
4. Confirm the deletion by entering the tag key in the input field of the prompt. After the deletion of your tag is finalized your list of active tags will be updated.

> You can only delete a tag which it is not used by any [meshPolicies](meshcloud.policies.md).

## Tags on meshUsers

meshUsers are defined globally in meshStack and therefore their tags are identical within all meshWorkspaces. As described in [meshPolicies](meshcloud.policies.md#meshpolicies-for-meshUsers/Groups) there are use cases where it makes sense to just apply a set of default tags to all meshUsers. I.e. you want to allow to assign all users to "dev" and "qa" projects, but not to "prod" projects.

<!--snippet:mesh.web.user-->

The following configuration options are available at `mesh.web.user`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let UserTagsConfig =
    {-
          tags:
            Default tags will be applied to every active user in meshStack on every startup of meshStack and
            whenever a new user is added to a meshWorkspace or imported via API
    -}
      { tags : List { mapKey : Text, mapValue : List Text } }
```
<!--Example-->
```dhall
let example
    : UserTagsConfig
    = { tags = [ { mapKey = "environment", mapValue = [ "dev", "qa" ] } ]
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

## Exposing Tags via Landing Zones

meshStack makes metadata available to [Landing Zones](./meshcloud.landing-zones.md), for example by providing it as parameters to an [Azure Blueprint](meshstack.azure.landing-zones.md). The Landing Zone documentation for each of meshStack's supported platforms describes how meshStack makes **meshTenant metadata** available.

### meshTenant Metadata

> meshTenant metadata is part of a tenant's desired state. meshStack will therefore automatically reconcile any change to metadata with the actual tenant state.

meshStack automatically derives [metadata tags](./meshcloud.metadata-tags.md) for [meshTenants](./meshcloud.tenant.md) based on the metadata tags set on the [meshProject](./meshcloud.project.md), the [payment method](./meshcloud.payment-methods.md) configured on the meshProject and
the [meshWorkspace](./meshcloud.workspace.md) it belongs to.

It's possible that these objects have tags with the same tag key. For example, both the meshWorkspace and
meshProject could contain a `cmdb-id` tag. Setting the `cmdb-id` tag value on the
meshWorkspace provides it as a "default" value to all tenants owned by that meshWorkspace. A user can then override
this default value on an individual meshProject by providing a value for the optional `cmdb-id` tag on the meshProject.

When merging the tag sources for a meshTenant, meshStack therefore applies the following precedence rule:

```text
meshProject tags > payment method tags > meshWorkspace tags
```

You can find an example in the table below which explains this behavior:

| meshObject        | Tag Name | Tag Value |
| ----------------- | -------- | --------- |
| meshWorkspace     | cmdb-id  | 12        |
| meshPaymentMethod | cmdb-id  | 34        |
| meshProject       | cmdb-id  | 56        |

This example would result in `cmdb-id` being equal to `56` as the meshProject has the highest priority.

### HTTP Header Interface

Some Landing Zone assets like [GCP Cloud Functions](meshstack.gcp.landing-zones.md) or [Azure Functions](./meshstack.azure.landing-zones.md) receive metadata tags from meshStack using HTTP Headers. meshStack invokes these Landing Zone assets using the following HTTP headers:


| HTTP Header Name                 | Description                                                                                                                   |
|----------------------------------|:------------------------------------------------------------------------------------------------------------------------------|
| `x-mesh-customer-identifier`     | meshWorkspace Identifier                                                                                                      |
| `x-mesh-project-identifier`      | meshProject identifier                                                                                                        |
| `x-mesh-costcenter` *deprecated* | If available, ID of the CostCenter selected for this meshProject. Please use `x-mesh-tag-cost-center` or another tag instead. |
| `x-mesh-tenant-platform-number`  | A increasing sequence number for a meshProject tenant on a specific platform.                                                 |
| `x-mesh-landing-zone-identifier` | landing zone identifier                                                                                                       |
| `x-mesh-tag-${format(tagName)}`  | metadata tags as defined in the tags screen in the admin area                                                                 |

Headers for *metadata tags* are formatted to an http-header name by converting `camelCase` tag names into a dashed string i.e. `camel-case` and prefixing them with `x-mesh-tag-`.
As a full example, a tag named `myCustomerTag` would be provided as an HTTP header with name `x-mesh-tag-my-customer-tag`.

## Tags in Cloud Tenants

Beside having tags in meshStack, it is also useful for cloud-native users to be aware of the metadata within e.g. Azure. This is why meshStack
supports the ability to "replicate" the tags into the actual cloud platforms. The entire lifecycle of these tags can be managed by meshStack. This means tags on the cloud platform are updated and removed depending on the underlying metadata of the replicated meshProject. meshStack manages all tags of a prefixed namespace (e.g. the `meshstack_` prefix in the tag label `meshstack_costcenter:12345` indicates that this is a meshStack managed tag).

Use the config tab in the [platform control plane](administration.platforms.md#platform-control-plane) and the [tag definition user interface](#how-to-define-a-new-tag) to enable automatic replication of tags to cloud tenants.

![Tag Configuration Header](assets/platform_maintenance/tag-config-1.png)

![Tag Configuration](assets/platform_maintenance/tag-config-2.png)

Every platform might have different limitations about the tag names and values, which are described in the following sections.

### Extra metadata

The tag definition configuration describes on a per-platform basis how these tags are extracted and transformed into cloud platform tags.
The following extra metadata can be used in such a tag definition configuration:

| Tag Key                       | Description                                                                                                                                               |
| ----------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `${projectIdentifier}`        | The project identifier                                                                                                                                    |
| `${workspaceIdentifier}`      | The project's workspace identifier                                                                                                                        |
| `${workspaceName}`            | The projects's workspace name                                                                                                                             |
| `${projectName}`              | The project display name                                                                                                                                  |
| `${landingZoneName}`          | The name of the applied [landing zone](meshcloud.landing-zones.md). It contains `no-landingzone` if the tenant does not have a landing zone applied       |
| `${landingZoneIdentifier}`    | The identifier of the applied [landing zone](meshcloud.landing-zones.md). It contains `no-landingzone` if the tenant does not have a landing zone applied |
| `${paymentIdentifier}`        | The identifier of the payment method that is assigned to the project                                                                                      |
| `${paymentName}`              | The display name of the payment method that is assigned to the project                                                                                    |
| `${paymentExpirationDate}`    | The expiration date of the payment method that is assigned to the project. It contains `none` if no expiration date is set for the payment method         |
| `${paymentAmount}`            | The amount of the assigned payment method. It is `none` if no payment method is set                                                                       |
| `${contactMail}`              | The email of workspace owner of this project. It is `none` if no owner is set                                                                             |
| `${ownerUsername}`            | The username of the workspace owner of this project. It is `none` if no owner is set                                                                      |
| `${ownerFirstName}`           | The first name of the workspace owner of this project. It is `none` if no owner is set                                                                    |
| `${ownerLastName}`            | The last name of the workspace owner of this project. It is `none` if no owner is set                                                                     |
| `${additionalOwnerUsername}`  | The username of the additional workspace owner of this project. It is `none` if no additional owner is set                                                |
| `${additionalOwnerFirstName}` | The first name of the additional workspace owner of this project. It is `none` if no additional owner is set                                              |
| `${additionalOwnerLastName}`  | The last name of the additional workspace owner of this project. It is `none` if no additional owner is set                                               |

### Tag sanitization

Depending on the platform some limitations apply for maximum tag length or legal characters. You can learn more about these restrictions on [our blog post](https://www.meshcloud.io/2020/09/29/tags-and-labels-on-cloud-platforms-cheat-sheet-2020/).
To ensure that no replication fails because of these restrictions we automatically adapt the tags to ensure they comply with platform requirements. The following behavior happens for the cloud platforms:

### Azure Tags

The following resources are tagged:

- Subscriptions

During replication non conform tag keys and values are possibly adapted to the platform limitations by:

- If tag names are longer then 512 characters, the remaining characters are discarded
- If tag values are longer then 256 characters, the remaining characters are discarded
- Illegal characters are replaced with a `_`
- If a configuration would force a tag key to start with a forbidden prefix we signal an error and won't replicate this project

### AWS Tags

The following resources are tagged:

- Accounts

During replication non conform tag keys and values are possibly adapted to the platform limitations by:

- If tag names are longer then 128 characters, the remaining characters are discarded
- If tag values are longer then 256 characters, the remaining characters are discarded
- Illegal characters are replaced with a `_`

### GCP Tags

The following resources are tagged:

- Projects

During replication non conform tag keys and values are possibly adapted to the platform limitations by:

- If tag names are longer then 64 characters the remaining characters are discarded
- If tag values are longer then 64 characters, the remaining characters are discarded
- Keys and values are forced to be lowercase
- Illegal characters are replaced with a `_`

## Tags in Reports

meshStack includes meshWorkspace, meshProject and Payment Method metadata tags as extra columns in relevant reports, e.g. [Chargeback Statements](./meshstack.billing-configuration.md#chargeback).

---


---
id: meshstack.logging
title: Logging & Auditing
---

meshStack consists of different components. On the one hand there are first
party components, like meshfed and kraken. Additionally, there are services like
Keycloak (used for authentication and authorization) and databases. In order to
provide central access to the log files for meshcloud operators, a central
logging system build around Loki and Grafana is used to collect logs and make
them available for error analysis.

meshStack keeps track of events for auditing and monitoring purposes. You can find these events in the Event Logs page under the Compliance section in the Admin Area. These logs help answer questions like:

- Who created a Project? (by typing the Project name under the Event table and selecting 'created' in the Type column)
- Who granted or revoked access in a Workspace for a user? (by typing the user's name or email in the Change column, the Workspace name in the Workspace column, and selecting 'remove' in the Type column)
- What changes were made to Landing Zone settings? (by typing 'Landing Zone' in the Event column, selecting 'change' in the Type column, and the Landing Zone name in the Change column)"

and more

Application team could find Event logs for dedicated Workspaces under the Compliance section, specifically in the Event Logs subsection. This allows Workspace Owners and Managers to easily access and review relevant activity within their dedicated Workspace.

## Logging Actions on meshObjects and Users

Changes (add, change, delete) to data are logged to provide traceability.
Regarding logging of personal user data, meshStack only logs the Username or the
Keycloak Id of the user. No further personal information is logged.

| Event                                                                           | meshStack page (Where)                 |
| ------------------------------------------------------------------------------- | ---------------------------------------|
| Created / Changed / Deleted for Workspaces; Projects; Platforms                 | Event Logs (Admin Area & in Workspace) |
| Created / Deletion Requested / Deleted for Tenants                              | Event Logs (Admin Area & in Workspace) |
| Replication to cloud platform                                                   | Tenant Details (Admin Area)            |
| Created / Changed / Deleted for Landing Zones                                   | Event Logs (Admin Area)                |
| Added / Changed / Removed for Users in Workspaces and Projects                  | Event Logs (Admin Area & in Workspace) |
| Authentication ((invalid) Logins, Logout, Timeout of session, …)                | On request                             |
| Interactions with Service Brokers (create/update/delete instance & bindings)    | On request                             |

## Logging of Business-Related Administrative Access

Administrators have access rights, that exceed the normal user’s
capabilities. Therefore administrative actions require special control and
traceability.

| Event                                          | meshStack page / DB-Table (Where)                |
| ---------------------------------------------- | -------------------------------------------------|
| Assign yourself to a Workspace                 | Event Logs (Admin Area & in Workspace)           |
| Change Workspace and Platform quota            | Event Logs (Admin Area & in Workspace), mesh.log |
| Update financial information of a Project      | Event Logs (Admin Area & in Workspace), mesh.log |
| Send message to Workspace                      | mesh.log                                         |
| Deletion of a user                             | User table in deletedOn and deletedBy fields     |

## Security Relevant Events

This section overlaps in some parts with the previously mentioned log files, but
it summarizes all logs that are written for security related actions, like
giving and revoking access.

| Event (What?)                                                         | meshStack page / Log-File / DB-Table (Where)     |
| --------------------------------------------------------------------- | ---------------------------------------------    |
| Successful and denied login attempts, as well as logouts              | Keycloak Events, events.log                      |
| Created, changed, deleted Workspaces                                  | Event Logs (Admin Area & in Workspace), mesh.log |
| Password changes - Authorization via meshIdB                          | Keycloak Events, events.log, mesh.log            |
| Password changes - Authorization via federated IdP                    | Federated IdP                                    |
| Access Right changes (i.e. user rights)                               | Event Logs (Admin Area & in Workspace), mesh.log |
| Changes to logging configuration (especially deactivation of logging) | Can only be done by meshcloud, no logging atm    |
| Start and stop administrative processes (Batch-Jobs)                  | mesh.log                                         |

## Structure / Content, Format and Retention

### Structure

All log file entries always contain a formatted UTC timestamp and the log level.

### Keycloak Log

The Keycloak log only contains operational information. It is mainly used for
error analysis. Therefore only a few fields are provided in this log file.

- Class that wrote the log entry
- Name of current thread
- Message

### Keycloak Event Log

Keycloak writes all User and Admin Events into its database by default.
Additionally, those events can also be written to log files. In meshStack
writing to events.log is enabled. The log file contains the following
information:

- Name of current thread
- In which realm did the event occur
- Which keycloak client has been used
- Keycloak User Id of the user who triggered the event
- Client IP Address

Login Events:

- Event Type: LOGIN, LOGIN_ERROR, LOGOUT, …
- Event specific details, like identity provider used for login, or redirect_uri
  after logout

Admin Events:

- Operation Type: CREATE, UPDATE, DELETE
- Resource Path (which REST resource has been called)

### meshStack Service logs

The different meshStack services are all based on Spring Boot and write
structurally identical log files. The default Spring Boot log format is used.

- Process Id
- Name of current thread
- Class that wrote the log entry
- Message

It should be considered for the future to also log the userId, to correlate log
entries to user actions.

### Format

All log file entries always start with an UTC datetime. This is followed by the
log-level (DEBUG, INFO, WARN, ERROR, ...).

#### Log in Keycloak

`<timestamp> <log-level> [<class-name>] (<thread-name>) <message>`

Example:

`2018-10-23 05:42:34,357 WARN [org.keycloak.authentication.authenticators.browser.IdentityProviderAuthenticator] (default task-40) Provider not found or not enabled for realm`

#### Event Log in Keycloak

`<timestamp> <log-level> [<package-name>] (<thread-name>) type=<type>, realmId=<realmId>, clientId=<clientId>, userId=<userId>, custom-property=<custom-property>`

Dependent on the event type, multiple custom properties can be set.

Example Login Event:

`2018-08-30 16:18:29,916 DEBUG [org.keycloak.events] (default task-37) type=LOGIN, realmId=meshfed, clientId=meshfed-oidc, userId=4654c50d-2782-43c5-8be3-f89ee138b71e, ipAddress=10.2.28.155, identity_provider=cloudidp, redirect_uri=https://panel.meshcloud.io, consent=no_consent_required, identity_provider_identity=my-user-id, code_id=5b05b056-bc47-4a82-ab61-b5aa4968e4f3, username=my-user-id`

Example Admin Event:

`2018-08-30 16:36:26,889 DEBUG [org.keycloak.events] (default task-35) operationType=UPDATE, realmId=master, clientId=200c6050-d7d1-4430-914a-f45ab139e494, userId=e7a64cb7-b692-4af0-b965-f3efba739815, ipAddress=11.12.13.14, resourcePath=clients/f99f22d7-87d7-4f4e-8235-23e07f58974e/roles/my-workspace|my-project-noadmin`

#### Logs in meshStack services

`<timestamp> <log-level> <process-id> --- [<thread-name>] <class-name> : <message>`

Example:

`2018-10-23 10:36:49.771  INFO 47534 --- [ask-scheduler-8] d.c.web.project.ProjectDeletionService   : 0 project(s) have been deleted in the platforms`

## Retention Times

Log information must be available for as long as it is required for audit and
error analysis reasons. But also data privacy laws have to be considered. So
logs must be deleted after a certain amount of time. The following table shows
the recommended retention times for the different log types. The specific
retention times will be configured individually for a meshStack installation.

| Log-File / DB Entry         | Minimum Retention Time | Maximum Retention Time |
| --------------------------- | ---------------------- | ---------------------- |
| Keycloak Events in DB       | 2 month                | 12 month               |
| Keycloak Events in log file | 1 month                | 6 month                |
| Keycloak Logs               | 1 month                | 6 month                |
| meshStack component logs    | 1 month                | 6 month                |
| meshStack Events in DB      | 12 month               | 5 years                |

## Deletion Process of Log Files

As all components use logging frameworks, these frameworks are configured to
automatically delete log files after a configured period of time.

The retention time of Keycloak Events in the Keycloak Database is configured
within Keycloak. It is a configuration option of the tool.

meshStack events are deleted by a weekly job, that checks, whether events
exceeded the defined lifetime.

As the database is also backed up, deleted events will persist in the backup, as
long as the backup exists. Database backups of meshStack and Keycloak are
persisted for a configured amount of time (e.g. 24 days).

## Location of Log Files

All log files are stored locally in the VM, container or PaaS system, where the
component is running. For these instances user authentication is required (e.g.
via SSH with a private key) to access their logs.


---


---
id: meshstack.building-blocks.permission-delegation-aws
title: Permission Delegation on AWS
---

Building blocks are often managing resources in tenants that are owned by application teams. Such resource management might require privileged access and needs to be handled with great care.

Managing permissions to AWS accounts are always managed within the individual account, whereas in other platforms permissions can be inherited via a resource hierarchy. 
When providing a centralised service to application teams, you therefore have to design permission delegation explicitly.
In AWS permissions are granted using resource-based policy or cross-account IAM role that includes trust policy allowing one AWS account to access to resources in another account by assuming cross account role. In this document we describe the latter option.

## Deciding on a pattern

Depending on your requirements, we recommend different reference architectures.
Use this decision tree to find out the recommended reference architecture given your requirements.

```mermaid
graph TD

start((start))
start --> trust

trust{Can cloud foundation team establish <br> trust in target accounts?}
trust -- Yes --> cfManagesPermissions[building block establishes trust]
trust -- No --> userPermissionSetup[users establish trust]

cfManagesPermissions --> teams
userPermissionSetup[user manages permissions] --> credentials

teams{Who offers the main building block?}
teams -- cloud foundation team --> mainbb[cloud foundation team manages <br> permissions within main building block]
teams -- another platform team --> sidecarbb[cloud foundation team offers sidecare building block <br> that manages permissions for main building block]

sidecarbb --> credentials
mainbb --> credentials

credentials{Are long-lived credentials allowed?}
credentials -- No --> dedicatedRunners[set up dedicated self-hosted runners <br> with instance profiles]
credentials -- Yes --> sharedRunner[use shared runner and pass credentials <br> as static inputs to the building block] 
```

## Reference Architectures

The decision trees implies six possible combinations, each with a different reference architecture.
The diagrams in this section depict the three combinations where no long lived secrets are allowed for a building block "Managed VPC" in this example.
If long lived secrets are allowed, you can simplify the terraform runner setup, the rest stays the same.

### Cloud Foundation Team has the permission to manage cross-account trust

When the cloud foundation team has the permission to establish trust, create a dedicated role in the target account for managing the main building block later on.

#### Cloud Foundation Team offers main building block

If the cloud foundation team offers the main building block, this building block should manage the necessary access.

To summarize, in this reference architecture

1. the cloud foundation team has the permission to establish trust
2. the cloud foundation team offers the "Managed VPC" building block
3. no long lived secrets are allowed

![Reference Architecture for building block offered by cloud foundation team when no long lived secrets are allowed and the cloud foundation team has permission to establish trust](assets/building-blocks/cf-nocred-trust.png)

#### Another Team offers main building block

To summarize, in this reference architecture

1. the cloud foundation team has the permission to establish trust
2. a dedicated networking team offers the "Managed VPC" building block
3. no long lived secrets are allowed

![Reference Architecture for building block offered by dedicated team when no long lived secrets are allowed and the cloud foundation team has permission to establish trust](assets/building-blocks/ded-nocred-trust.png)

### Cloud Foundation Team does not have the permission to manage trust

To summarize, in this reference architecture

1. the cloud foundation team does not have the permission to establish trust, instead product owner reviews and provides the required cross-account trust
2. either the cloud foundation team or a dedicated networking team offers the "Managed VPC" building block
3. no long lived secrets are allowed

   
![Reference Architecture for no long lived secrets are allowed and the cloud foundation team does not have permission to establish trust](assets/building-blocks/ded-nocred-notrust.png)


---


---
id: meshstack.aws.avm-tutorial
title: "Tutorial: Account Vending Machine"
---

> This tutorial is work in progress!

Purpose: show you how to create secure landing zones for AWS.

Terms:

- **Managed Account** An AWS Account managed under this landing zone.
- **CFN** shorthand for AWS CloudFormation

## Acount Vending Machine

To use your existing AVM, make sure it has a single lambda as its Entry Point.

## Access Stack to boostrap Managed Accounts

### OrganizationAccountAccessRole

```yaml
AWSTemplateFormatVersion: 2010-09-09
Description: Configure the OrganizationAccountAccessRole

Resources:
  OrganizationAccountAccessRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: OrganizationAccountAccessRole # tbd check for collisions with existing roles
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS:
                - arn:aws:iam::${RootAccountId}:meshfed-service
            Action:
              - sts:AssumeRole
      Path: /
      PolicyDocument:
        Statement:
          - Sid: IamReadOnly
            Effect: Allow
            Action:
                - iam:GetRole
                - iam:ListSAMProviders
                - iam:ListRoles
                - iam:GetSAMLProvider
            Resource: '*' # tbd this may need to be more limited, but needs access on the LZ StackSet
          - Sid: IamUpdateSAMLProvider
            Effect: Allow
            Action:
                - iam:UpdateSAMProvider
            Resource: arn:aws:iam::*:saml-provider/meshstack-saml-idp
          - Sid: InvokeAccountVendingMachine
            Effect: Allow
            Action:
              - lambda:InvokeFunction
            Resource": arn:aws:lambda:<region>:${AutomationAccountId}:function:AVMEntryPoint
```

## Workflow

It's best practice to configure your AWS organization so that meshStack operates without any access to workload provisioned in managed AWS accounts. This requires careful plannign and analysis but results in increased security.

The flow of privileges is the following

- Account Provisioning
  - the `meshfed-service` user creates accounts using the AWS Organizations API on the root acount
    - the managed account contains an `OrganizationAccountAccessRole`
      - allows [AdministratorAccess](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html)
      - can be assumed from all principals of the root account


---


---
id: meshstack.billing-configuration
title: Configuration
---

## Chargeback

> Chargeback is the process of allocating IT cost to consumers and feeding it into the company-wide finance and controlling processes.

Each project in meshStack is associated with a Chargeback Account. meshStack periodically generates [chargeback statements](meshcloud.project-metering.md#chargeback-statements).

The attributes that shall be part of the billing info on the chargeback statements can be configured.

You need to specify a wait-period after which the chargeback statements are finalized. This period exists to allow the public cloud platforms to get all their usage events into the calculation. For private cloud platforms the waiting period is usually a few hours up to a day, but for public cloud providers it can be significantly longer. If you plan to use a public cloud provider, please choose the longest wait period for finalizing your chargeback statements. This ensures that all discounts and events of the month are included in the chargeback statement meshStack generates.

| Provider | Suggested Wait Period                                                                                                                                                               |
| -------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GCP      | 5 Days                                                                                                                                                                              |
| AWS      | 6 Days                                                                                                                                                                              |
| Azure    | Depends on the workspaces Azure EA account, please contact us and check when Azure bills you. It can happen in the middle of a month. So delays of about 15 days are to be expected. |

### Available metadata keys

The following metadata keys are derived from meshStack metadata and therefore available on every meshStack implementation

| Key                   | Description                                      |
| --------------------- | :----------------------------------------------- |
| last_modified         | Date when metadata was last modified             |
| contactMail           | email address of the project owner               |
| ownerUsername         | Username of the project owner                    |
| ownerFirstName        | First name of the project owner                  |
| ownerLastName         | Last name of the project owner                   |
| paymentName           | Name of the payment method                       |
| paymentIdentifier     | Identifier of the payment method                 |
| paymentExpirationDate | Expiration date of the payment method            |
| paymentAmount         | Amount available for payment method              |

### Available tag keys

It is also possible to derive [meshTags](meshstack.metadata-tags.md) as metadata keys by using its tag name.

### Configuration example

<!--snippet:mesh.kraken.api.statements-->

The following configuration options are available at `mesh.kraken.api.statements`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let Statements =
    {-
      relevant-meta-keys:
        A list of metadata and tag keys that shall appear in chargeback statements as billing info.
        General payment information can be accessed via paymentName, paymentIdentifier, paymentExpirationDate
        and paymentAmount. Custom Tags can be referenced via their property name in the according tag JSON schema.
        Custom Tags are workspace tags, project tags and payment tags.

      period-offset-days:
        It is the offset of days after which chargeback statements are generated.
        This time should always be set to a higher value than the finalizeReportsAfterDays
        that are configured for kraken-worker, as only finalized reports are considered in chargeback statements.

      first-period:
        Chargeback statement periods will be created monthly starting from this date on (UTC datetime format: yyyy-MM-ddTHH:mm:ssZ)
    -}
      { relevant-meta-keys : List Text
      , period-offset-days : Natural
      , first-period : Text
      }
```
<!--Example-->
```dhall
let example
    -- these relevant-meta-keys reference all statically available payment information
    : Statements
    = { relevant-meta-keys =
        [ "paymentName"
        , "paymentIdentifier"
        , "paymentExpirationDate"
        , "paymentAmount"
        ]
      , period-offset-days = 5
      , first-period = "2020-01-01T00:00:00Z"
      }

let example2
    -- these relevant-meta-keys reference tags that can be defined individually per meshImplementation
    : Statements
    = { relevant-meta-keys = [ "customTag1", "customTag2" ]
      , period-offset-days = 5
      , first-period = "2020-01-01T00:00:00Z"
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

> If you are interested in including budgeting into your chargeback process, have a look at the use of [payment methods](./meshcloud.payment-methods.md).

## Setting Internal Prices

In meshStack, you have the flexibility to define prices for [Platform Services](./marketplace.index.md) in addition to usage costs from providers. Configuring your internal prices allows you to account for various expenses such as licensing costs or the effort invested in maintaining and enhancing Platform Services. These internal prices will be displayed on the service details page within the Marketplace.

![Marketplace price](assets/marketplace/marketplace-costs.png)

For Platforms, you can now establish monthly or daily recurring prices per meshTenant, which will be charged only once when a user adds a Platform Tenant. You can configure prices within meshStack by navigating to the Pricing tab of the Platform Settings. Additionally, prices for Platforms per Landing Zone can be set up by contacting the meshcloud support team, among other pricing options.

![platform pricing](assets/marketplace/price-platform.png)

For Building Blocks prices can be configured as recurring monthly or daily fees per Building Block instance. To set prices, navigate to the Pricing tab of the Building Block setting or you can set it during Building Block creation.

![bb pricing](assets/marketplace/price-buildingblock.png)

If you would like to add prices for OSBs, please contact our support team and they will assist you in setting them up.

>Please note that any changes in the price of Platform Services will be reflected in the chargeback statements based on the period in which the change occurred. For instance, a new price set for a Building Block on March 28th will be applied to the March chargeback statement.

### Private Platform

When configuring a product for private cloud billing, Partners need to choose the cloud resource type to target and how the metering engine
should generate usages and apply prices to them. The documentation section of each private cloud platform lists the supported resource types and the traits available in the metering engine.
Traits are a properties of a cloud resource like CPU or RAM. Partners can use traits to configure predicates (filter resources applicable to a pricing rule) and to control how meshMetering calculates usages.

meshMetering supports flexible rules for creating usages, like

- **time**: charge consumption based on the usage of a resource over a time period
- **quantity**: charge consumption based on a quantity
- **time-quantity**: charge consumption based on the product of time and quantity

Quantities are represented with prefixable units according to the [UCUM standard](https://ucum.org/ucum.html) inside meshMetering.
Specifically, meshMetering uses the UCUM "print" formatting where units need to be human readable (e.g. in usage reports).
In configuration (e.g. when defining a product catalog entry), meshMetering uses the UCUM "case-sensitive" representations.
This can lead to small differences when describing units. For example, one kilo-byte would be represented as

- `1 kB` in a usage report
- `1 kBy` in a product catalog entry

When building a product catalog, Partners can define rates to define prices for usages.
It's also possible to define rates with a different prefix, e.g. if the primitive unit of the resource
trait is measured in "MB", Partners can define a price in "GB". meshMetering will automatically apply
the necessary conversions so that usage reports are presented in the unit defined in the product catalog. This is useful to provide human-readable and intuitive units for pricing rules. meshMetering supports the following prefixes, with examples described in bytes
according to UCUM "case-sensitive" representation.

| Metric Prefix | Example | Binary Prefix | Example |
| ------------- | ------- | ------------- | ------- |
| kilo (10^3)   | 1 kBy   | kibi (1024^1) | 1 KiBy  |
| mega (10^6)   | 1 MBy   | mebi (1024^2) | 1 MiBy  |
| giga (10^9)   | 1 GBy   | gibi (1024^3) | 1 GiBy  |
| terra (10^12) | 1 TBy   | tebi (1024^4) | 1 TiBy  |
| peta (10^15)  | 1 PBy   | pebi (1024^5) | 1 PiBy  |


### Other Pricing Concepts

#### Scope Selectors

Every cloud resource has a scope in meshcloud, defined by the meshTenant in belongs to.
ScopeSelectors are hierarchical selectors that allow Product Catalog entries to specify the resource scopes they apply to. ScopeSelectors can target all platforms of a certain platform type, a specific meshPlatform or an individual meshTenant.

Using ScopeSelectors, Operators can for example define different prices for platforms running in different locations or platforms.

<!--snippet:mesh.kraken.productcatalog.scopeselector#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let ScopeSelector =
    {-
      The Scope Selector specifies the cloud resource scopes that a product catalog entry applies to.
      Fields, depending on the type of scope selected:

        platformType:
            The PlatformType to target

        location:
            The meshLocation identifier to target

        platformInstance:
            The meshPlatform identifier to target

        localProjectId:
            The platform identifier for the meshTenant, e.g. an Azure Subscription Id.
    -}

      let ByPlatformType = { platformType : PlatformType }

      let ByPlatformInstance =
            ByPlatformType ⩓ { location : Text, platformInstance : Text }

      let ByTenant = ByPlatformInstance ⩓ { localProjectId : Text }

      in  < PlatformType : ByPlatformType
          | PlatformInstance : ByPlatformInstance
          | Tenant : ByTenant
          >
```
<!--Example-->
```dhall
let example =
    -- this ScopeSelector targets all platforms of type "Azure"
      ScopeSelector.PlatformType { platformType = PlatformType.Azure }

let example2 =
    -- this scope selector targets a specific OpenStack platform
      ScopeSelector.PlatformInstance
        { platformType = PlatformType.OpenStack
        , location = "eu.de-central"
        , platformInstance = "pike"
        }
```
<!--END_DOCUSAURUS_CODE_TABS-->


#### Discounts

Discounts allow Partners to add or deduct charges to Tenant Usage Reports. A common use case for Platform Operators is to configure a discount with a positive rate to charge projects with a "management fee" based on the project's actual cloud consumption.

<!--snippet:mesh.kraken.productcatalog.discount#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let Discount =
    {-
        scope:
            Specifies the scope this discount applies to, see ScopeSelector

        discountRule:
            Specifies the type of discount rule used to calculate the discount.

        displayName:
            The name to display for this discount on the tenant usage report.

        description:
            The description to display for this discount on the tenant usage report.

        sellerId:
            The id of the seller to charge this discount to. A positive discount netAmount will be credited to this
            seller during chargeback, while a negative netAmount will be charged to this seller.

        sellerProductGroup:
            A product group identifier for the seller. Specifying this field allows sellers to aggregate
            charges and credits by different categories for reporting purposes.
    -}
      { scope : ScopeSelector
      , discountRule : DiscountRule
      , displayName : Text
      , description : Text
      , sellerId : Text
      , sellerProductGroup : Text
      }
```
<!--Example-->
```dhall
let example
    : Discount
    =
      -- This Discount charges a 5% Management Fee on all Azure consumption and is credited to the operations team
      { scope =
          ScopeSelector.PlatformType { platformType = PlatformType.Azure }
      , sellerId = "azure-cloud-foundation"
      , sellerProductGroup = "fees"
      , displayName = "Azure Management Fee"
      , description =
          "Management Fee for Azure Cloud Operations Team, based on usage"
      , discountRule =
          DiscountRule.fixedPercentage
            { discountPercentage = 5.0
            , discountScope =
              { productSellerIdRegex = Some "Azure"
              , productDisplayNameRegex = None Text
              , usageTypeDisplayNameRegex = None Text
              }
            }
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

#### Discount rules

Discount rules specify how a discount is computed.

meshStack currently provides two discount rules. Future releases could provide additional discount rule options.

<!--snippet:mesh.kraken.productcatalog.discountrule#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let DiscountRule =
      < fixedPercentage : FixedPercentageDiscountRule
      | tieredPercentage : TieredPercentageDiscountRule
      | tieredFixedAmount : TieredFixedAmountDiscountRule
      >
```
<!--END_DOCUSAURUS_CODE_TABS-->


A discount rule contains a discount scope that specifies which usage report line items are eligible for the discount.
The line items for the report are first filtered by this discount scope before calculating the sum and applying the discount.

<!--snippet:mesh.kraken.productcatalog.discountscope#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let DiscountScope =
    {-
       Specify the regular expressions for sellerId, product display name and usage type display name
       that should be matched when filtering usage report line items for applying a discount.
    -}
      { productSellerIdRegex : Optional Text
      , productDisplayNameRegex : Optional Text
      , usageTypeDisplayNameRegex : Optional Text
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

#### Fixed Percentage Discount Rule

The fixed percentage discount rules calculates the fee as a percentage of the total consumption.

<!--snippet:mesh.kraken.productcatalog.fixedpercentagediscountrule#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let FixedPercentageDiscountRule =

    {-
      Calculates the discount as a fixed percentage of a source amount using the formula
      ```
          discountNetAmount = sourceNetAmount * discountPercentage / 100
      ```

        discountScope:
            The discount is calculated on a source amount computed by summing the usage line item net amounts
            filtered by this DiscountScope. This is typically used so that the discount only applies to usages
            generated by cloud consumption.
            A string representation of this discount scope will be shown in the tenant usage report line item.

        discountPercentage:
            The discount percentage to apply. Use positive rates to generate additional fees, use negative rates
            to deduct charges.
    -}
      { discountScope : DiscountScope, discountPercentage : Double }
```
<!--Example-->
```dhall
let example
    : FixedPercentageDiscountRule
    = {-
      This fee adds 5% to to all azure consumption.
      -}
      { discountPercentage = 5.0
      , discountScope =
        { productSellerIdRegex = Some "Azure"
        , productDisplayNameRegex = None Text
        , usageTypeDisplayNameRegex = None Text
        }
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

#### Fixed percentage per tier

The tiered percentage discount rule defines tiers of cloud resource consumption. For each tier a discount percentage is used to calculate the discount to be used.

<!--snippet:mesh.kraken.productcatalog.tieredpercentagediscountrule#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let TieredPercentageDiscountRule =
    {-
      Calculates the discount as percentage of a source amount using the formula
      ```
          discountNetAmount = sourceNetAmount * "discountPercentage of activated tier" / 100
      ```

         discountScope:
            The discount is calculated on a source amount computed by summing the usage line item net amounts
            filtered by this discount scope. This is typically used so that the discount only applies to usages
            generated by cloud consumption.
            A string representation of this discount scope will be shown in the tenant usage report line item.

        discountPercentageTiersByLowerThresholds:
            lowerThreshold:
                Specify tiers by their threshold.
                    - If source amount is not greater than any lowerThreshold, no discount is given.
                    - If source amount is greater than more than one lowerThreshold, the tier with the highest threshold is activated.
                      Up to one tier is activated at a time.
            discountPercentage:
                The discount percentage to apply. Use positive rates to generate additional fees, use negative rates
                to deduct charges.
    -}
      { discountScope : DiscountScope
      , discountPercentageTiersByLowerThresholds :
          List { lowerThreshold : Double, discountPercentage : Double }
      }
```
<!--Example-->
```dhall
let example
    : TieredPercentageDiscountRule
    =
       {-
          This TieredPercentageDiscountRule is applied on all Azure consumption.

          The applicable fee depends on the source amount.

          In combination with TieredFixedAmountDiscountRule, complex discounts and fees can be modeled.

          Using interval notation the explicitly defined tiers can be described as:
              - source amount in [5,10) -> 2.5% fee
              - source amount in [10,∞) -> 1% fee

          Because the smallest lowerThreshold of the defined tiers is greater than 0 the TieredPercentageDiscountRule implicitly
          defines a tier with discountPercentage 0% for every source amount strictly less than the smallest tier.
          This results in the following fee
              - source amount in [0,5)  -> 0% fee
      -}
      { discountScope =
        { productSellerIdRegex = Some "Azure"
        , productDisplayNameRegex = None Text
        , usageTypeDisplayNameRegex = None Text
        }
      , discountPercentageTiersByLowerThresholds =
        [ { lowerThreshold = 5.0, discountPercentage = 2.5 }
        , { lowerThreshold = 10.0, discountPercentage = 1.0 }
        ]
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

#### Fixed cost per tier

The tiered discount rule defines tiers of cloud resource consumption. For each tier a fixed amount is added.

<!--snippet:mesh.kraken.productcatalog.tieredfixedamountdiscountrule#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let TieredFixedAmountDiscountRule =
    {-
        Adds a fixed amount discount based on source amount tier.

         discountScope:
            The discount tier is applied on a source amount computed by summing the usage line item net amounts
            filtered by this discount scope. This is typically used so that the discount only applies to usages
            generated by cloud consumption.
            A string representation of this discount scope will be shown in the tenant usage report line item.

        discountFixedAmountTiersByLowerThresholds:
            lowerThreshold:
                Specify tiers by their threshold.
                    - If source amount is not greater than any lowerThreshold, no discount is given.
                    - If source amount is greater than more than one lowerThreshold, the tier with the highest threshold is activated.
                      Up to one tier is activated at a time.
            fixedAmount:
                The discount to apply. Use positive amounts to generate additional fees, use negative amounts
                to deduct charges.
    -}
      { discountScope : DiscountScope
      , discountFixedAmountTiersByLowerThresholds :
          List { lowerThreshold : Double, fixedAmount : Double }
      }
```
<!--Example-->
```dhall
let example
    : TieredFixedAmountDiscountRule
    =
       {-
          This TieredFixedAmountDiscountRule is applied on all Azure consumption.

          The applicable fee depends on the source amount.

          TieredFixedAmountDiscountRule is commonly used for fees and rarely makes sense for modeling discounts.
          In combination with TieredPercentageDiscountRule, complex discounts and fees can be modeled.

          Using interval notation the explicitly defined tiers can be described as:
              - source amount in [5,10) -> 100€ (currency matches consumption currency)
              - source amount in [10,∞) -> 50€

          Because the smallest lowerThreshold of the defined tiers is greater than 0 the TieredFixedAmountDiscountRule implicitly
          defines a tier with discountFixedAmount 0 for every source amount strictly less than the smallest tier.
          This results in the following fee
              - source amount in [0,5)  -> 0€ alias "Free tier"
      -}
      { discountScope =
        { productSellerIdRegex = Some "Azure"
        , productDisplayNameRegex = None Text
        , usageTypeDisplayNameRegex = None Text
        }
      , discountFixedAmountTiersByLowerThresholds =
        [ { lowerThreshold = 5.0, fixedAmount = 100.0 }
        , { lowerThreshold = 10.0, fixedAmount = 50.0 }
        ]
      }
```
<!--END_DOCUSAURUS_CODE_TABS-->

## Currency Conversion

The best practice is to have a single chargeback currency for all cloud environments internally. meshStack simplifies the chargeback process with it's currency conversion capability. Regardless of the original currency from the cloud providers (e.g. AWS in USD) chargeback statements will be converted to a single currency. For chargeback, we use the daily exchange rate from the day your statement is finalized. For example, if your chargeback finalization day is March 31st, and the USD to Euro rate on that day is 0.93, then all March chargeback statements in USD will be converted and finalized at this rate.

>Note: Currently, currency conversion supports various currencies (USD, CNY, TWD, CAD, INR) but converts **to Euro only**.

### How to Set Up Currency Conversion

Navigate to the  Financials tab of the Settings Page in the Admin area to configure currency conversion.

#### meshStack Default Exchange Rates

This option fetches rates from [frankfurter.app](https://www.frankfurter.app/), using exchange rates from the European Central Bank.  
To enable this select **meshStack default exchange rates**.  

If meshStack is hosted privately, ensure it can make external requests (configure firewall rules if needed).

When currency conversion is turned on: Financial data will be presented in Euro starting with the current month
When currency conversion is turned off: Financial data will be presented in the original currency
When currency conversion is switched on and off multiple times: Then the financial data once converted will also be shown for previous months

#### Custom API Exchange Rates

With this second option you can provide your own exchange rates via API. If no rates are provided by the finalization date and the currency converter is turned on, **meshStack default exchange rates** will apply for that month.
To enable this go to the Financials tab and select **Custom API Exchange Rates**.

### Limitation

1. **Euro-only conversion**: Currently, only conversion to Euro is supported. We plan to support other currencies in the future.
2. **Payment Methods**: 
    Payment method amounts are currently limited to EUR, but we plan to support additional currencies in the future.
3. **Prices for Platforms and Building Blocks**: Currently, prices can only be set in EUR, but we plan to support other currencies in the future.
4. **Known Issue Detailed Tenant Usage Report**: Detailed tenant usage reports (available for OpenShift, OpenStack, Cloud Foundry, and OSB Services) provide additional insights, but even with currency conversion enabled, they continue to display the original currency from the provider.
5. **Presenting other Currencies: If you want to show a different currency besides Euro you have to reach out to support@meshcloud.io




---


---
id: meshstack.how-to.get-started-building-blocks
title: How to setup and manage a Building block
---

## Introduction

Building Blocks are a feature in meshStack that enables end users to automate resource provisioning through self-service. It also assists cloud engineers in creating pre-configured cloud resources by enforcing the use of Building Blocks assigned to Landing Zones. This document provides a step-by-step guide for users on the efficient setup of meshStack Building Blocks.

## Terminology

The Building Block *Definition* is the template/blueprint of Building Blocks. It describes what piece of e.g. Terraform or other infrastructure has to be rolled out.

A Building Block is an *instance* of a Building Block Definition.

In the marketplace, users can find *building block definitions,* and based on these, they can add them as a *building block* to their tenants.

## Overview

The diagram below illustrates the key components addressed in this document:

- A Provider oversees the management of Building Block definitions that are made available to users through the Marketplace.
- A User adds Building Blocks to existing or new projects.
- The meshStack front end offers a user interface for both Providers and Users, enabling Providers to create and maintain Building Block definitions, and Users to add these Building Blocks to their projects.
- The terraform runner executes the code defined in the Building Block, thereby provisioning platform resources.
- A GIT repository contains the terraform code, which is maintained by the provider and utilized in the Building Block definition. This code specifies the resources that need to be provisioned on the platform.
- A Platform represents a target private or public cloud environment to provision resources described in the terraform code.

![Building block key components](assets/bb-howto-1.png)

## Setup

To create a new Building Block definition, from Admin Area navigate to “Marketplace > Building Block Definitions” and then select “Create new Definition”. The configuration process is divided into multiple steps as outlined below.

Alternatively, you can switch to “Service Management” UI and navigate to “Building Blocks > Definitions” and then select “Create new Definition”.

### General

In the initial user interface for Building Block definition, the user is required to assign a **Definition name** to the Building Block, which will be displayed in the Marketplace. The **Description** field offers more detailed information about the Building Block, assisting users in comprehending its purpose and advantages.

In certain cases, newly created Tenants may require the automatic execution of a configuration routine, like setting up a VPN connection to an on-premises network. For these situations, a Building Block assigned to a Landing Zone can be utilized. This Building Block will execute each time a tenant is established in the Landing Zone, carrying out the required updates. To enable use of Building Block in a Landing Zone, toggle the switch “**Use in Landing Zone only**”. Subsequently, the Building Block will not be available in the Marketplace.

**Notification User** field lets you define mail addresses to send a notification in case of failed Building Block execution or whenever a Building Block requires platform operator input.

The **Support** and **Documentation** fields are designed to direct Building Block users to supplementary documentation, providing them with additional information and support.

![Building block configuration UI](assets/bb-howto-2.png)

### Tags

Like other meshStack objects, tags could be assigned to Building Block definitions. These tags can be used to establish compliance rules, for example, allowing only users from specific Workspaces to execute the Building Block. Matching values for Building Block and Workspace tags facilitate such scenarios.

### Implementation

#### Supported platforms

A Building Block is created to operate on one or several Platforms. This selection allows users to determine which Platforms qualify for the Building Block. Only projects with tenants on the corresponding platform will qualify for Building Block assignment.

#### Assignment

How often can the same Building Block be allocated to a particular project? Choose "One" for a single assignment, or "Multiple" for more than one.

#### Terraform vs manual

The building block definition has two implementation types: Terraform and manual. Using Terraform, the building block can automatically provision the infrastructure resources. This gives engineers and DevOps the ability to use the full power of IaC (Infrastructure as Code) to create self-service products available in the Marketplace.

Manual implementation is beneficial when the Building Block provider wants to gather end-user information (through inputs) and process it outside of meshStack.

#### Git repository authentication

When the implementation type is configured as Terraform, meshStack offers two methods for retrieving your code from a remote Git repository of your choice:

- HTTPS
- SSH using deploy keys

If you opt for SSH, please use the command below to create an SSH deploy key. Please do not set a password for the private key and replace `your_email@example.com` with appropriate value.

```bash
ssh-keygen -t ed25519 -C "your_email@example.com"
```

After generating the SSH key, upload the private key to meshStack using the "Upload" feature. Then, consult your repository's documentation for instructions on setting up SSH deployment keys.

Finally, if you are using a private Git repository, you should import the public portion of the SSH host keys into meshStack. To gather the public SSH host keys, run the command below, replacing 'GIT_HOST' with the hostname or IP address of your private repository.

```bash
ssh-keyscan GIT_HOST
```

Paste the command output into the text fields below.

![Known host setup](assets/bb-howto-3.png)

### Dependencies

Optionally, a user can specify relationships between the Building Blocks, making sure that Building Blocks designated as “prerequisites” are assigned to the Tenant prior to assignment of the current Building Block. By chaining the Building Blocks it is possible to use Building Block outputs as inputs for the dependent Building Block.

### Input

A Building Block input is used to supply configuration parameters to Terraform code. Each input has following settings:

- The input N**ame** must correspond to the Terraform variables.
- While the **Display Name** field is optional, it enables the provision of a user-friendly name for the Building Block requester, distinguishing it from Terraform's naming conventions.
- **Source** defines how the input is provided to the terraform: by the requester, platform operator, static value or generated by meshStack
- **Type** specifies the input format: String, Number, Boolean or Single select
- **Default value** provides a predefined value for the given input
- **Regular expression** and **Message on Regular expression failure** are utilized to define the data format of the input and guarantee the quality of the information provided.
- **Provide as** feature enables users to specify the method of input delivery to the Terraform code, either as an environment variable or as a regular variable (typically defined in the `variables.tf` file)
- Finally, users can choose to encrypt the input's value by toggling the corresponding switch on, which is particularly useful when supplying credentials to Terraform.

#### Credentials management

In most cases, Terraform code requires credentials to provision the infrastructure. Consider an example of a Terraform building block for AWS. The AWS provider typically looks as follows, assuming credentials are provided by an AWS profile named `demo-profile` stored on the same device where Terraform operates:

```json
provider "aws" {
 profile    = "demo-profile"
}
```

However this code cannot run on the meshStack Terraform runner for clear reasons. The runner starts from a fresh environment and does not have any preconfigured AWS profiles.

More optimal solution would be to rely on environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`. In that case the Terraform configuration for AWS provider could look like:

```json
 provider "aws" {}
```

These variables must be passed by meshStack to the Terraform runner as input variables created in the Building Block definition as following:

- **Source**: Static (in case you would like to use the same credentials to run the building block)
- **Input type**: String
- **Provided as**: Environment
- **Encryption**: enabled

The screenshots below provide examples of Building Block Input configurations.

![Key id](assets/bb-howto-4.png)

![Secret](assets/bb-howto-5.png)

This concept is not only limited to AWS, but applies to many Terraform providers that can use environment variables as credentials. Another example is the Datadog provider, which is configured similarly. The credentials are passed to the Terraform runner as Building Block Input environment variables, `DD_API_KEY` and `DD_APP_KEY`. Please refer to [https://registry.terraform.io/providers/DataDog/datadog/latest/docs](https://registry.terraform.io/providers/DataDog/datadog/latest/docs) for more details.

For implementing Terraform, meshStack will provide preconfigured inputs for setting up credentials, depending on the platform you've chosen for the Building block. For instance, if your building block runs on the AWS platform, select "Generate AWS auth inputs" from the "Generate Input" menu, as shown.

![Generate AWS credetials input](assets/bb-howto-6.png)

It will automatically generate two inputs corresponding to the AWS credentials. You only need to assign the appropriate static values to these inputs or allow the end user to supply them at runtime as “User input”. Similar applies to GCP and Azure.

![Generates AWS credetials input](assets/bb-howto-7.png)

#### User permissions

User permissions is a special type of input. It provides to the Terraform runner the list of all users assigned to the project including their mail address, first/last name and respective roles. The permissions are passed as JSON list as shown on the example below:

```json
[
  {
    "meshIdentifier": "bebeb91e-3bf8-11ec-8fcd-0242ac110002",
    "username": "one-user@mydomain.lo",
    "firstName": "One",
    "lastName": "User",
    "email": "user@mydomain.lo",
    "euid": "user@mydomain.lo",
    "roles": [
      "admin"
    ]
  },
  {
    "meshIdentifier": "fe4d0c65-955c-4dc9-a780-f1fdd5f93e25",
    "username": "second-user@mydomain.lo",
    "firstName": "Second",
    "lastName": "User",
    "email": "second-user@mydomain.lo",
    "euid": "second-user@mydomain.lo",
    "roles": [
      "reader"
    ]
  }
]
```

To handle such list in your Terraform code, define the following variable, usually in `variables.tf` file:

```json
variable "users" {
  type = list(object(
    {
      meshIdentifier = string
      username       = string
      firstName      = string
      lastName       = string
      email          = string
      euid           = string
      roles          = list(string)
    }
  ))
  description = "Users and their roles provided by meshStack"
}
```

Finally, to process this variable use the Terraform code below in `main.tf` file. It defines three lists corresponding to each default project role:

```json
locals {
  admins  = { for user in var.users : user.username => user if contains(user["roles"], "admin") }
  editors = { for user in var.users : user.username => user if contains(user["roles"], "user") }
  readers = { for user in var.users : user.username => user if contains(user["roles"], "reader") }
}
```

The following example demonstrates how to create a list of user identities with only admin roles. This list can subsequently be utilized to grant permissions on resources provisioned through Terraform:

```json
data "project_users" "admins" {
  for_each = local.admins
  email    = each.value.username
}
```

### Output

Generally, any output generated by Terraform code can be accessed by meshStack if required. A common example might be when Terraform creates a resource on a custom platform, which is considered a tenant for meshStack. In such a case, meshStack would need to know the tenant's ID. This can be done by creating a new output with the name that match Terraform output variable and having the following characteristics:

- **Type**: String
- **Assignment Type**: Platform Tenant ID

The example below demonstrates an output variable `tenant_id`. It will be initialized to the Terraform output of the same name following successful execution.

![Output UI](assets/bb-howto-8.png)

### Pricing

Recurring fees, which can be set on a monthly or daily basis, are an option. These fees will be charged to each project that has a Building Block assignment.

### Publish Building Block definition

Once you select "Create definition," the building block is recorded as a draft and is not yet eligible for the Marketplace.

![Building block draft](assets/bb-howto-9.png)

To alter this status, meshStack users with the Admin role must review the new definition. You should click "Submit for publishing" and then confirm with "Yes, submit for review" in the subsequent pop-up window.

![Submit for review](assets/bb-howto-10.png)

The status of the definition will be set to “in review”. Once approved, the status will change to “Published”.

## Building Block instances

meshStack enables Administrators and Platform owners to identify the tenants to which a Building Block has been added, that includes the versions used and the status of the Building Block, such as whether the run was successful or failed.

To view this, from the Admin View, go to “Marketplace > Building Blocks” and enter the name of the Building Block in the search field. The list of added Building Blocks will be displayed as illustrated in the screenshot below.

![Building block instances](assets/bb-howto-11.png)

## Change management

To apply changes to an existing Building Block, navigate to the Building Block definitions and select the required Building Block. Select "Create draft" to generate a new version of the building block. Afterward, the Building Block definition will switch to edit mode, allowing you to apply the necessary changes.

![Create building block draft](assets/bb-howto-12.png)

After applying the changes, select "Release" to publish a new version of the building block. This latest version will now be the default for users selecting this building block from the Marketplace. Users who have previously selected that building block continue to rely on the prior version.

The current instances of Building Blocks are not impacted by updates to the Building Block definition; thus, the provisioned resources stay unchanged. If necessary, you can force an upgrade of the instances. To do this, navigate to the Admin Area, then go to "Marketplace > Building Blocks". From the list of Building Blocks, check the box next to the ones you want to upgrade. Then, select “Upgrade,” as shown in the image below. This action will upgrade the selected Building Block definitions and **force a new run**, ensuring that end-users are using the latest version.

![Upgrade building block](assets/bb-howto-13.png)

The diagram illustrates the lifecycle of a Building Block definition. It indicates that only the initial version (V 1) necessitates approval before the definition can be published.

![Building block lifecycle](assets/bb-howto-14.png)

## Execution logs

Building Blocks with "Terraform" as the implementation type produce logs when they are added to a project by an end-user. These logs provide details on the resources provisioned or any errors if the execution is unsuccessful. Both Admins and owners of the Building Block definitions can access these logs. As an Admin, you can view them by going to the Admin Area, proceeding to "Marketplace > Building Block overview," and choosing the desired Building Block from the list of executed instances. On the next screen, you will find one or more "Runs," depending on the number of times the user has executed this specific Building Block. By selecting a Run, you can inspect the associated Terraform logs.

The owner of the Building Block definition can access the logs by switching to “Service Management” view and navigating to "Building Blocks > Overview".

![Building block logs](assets/bb-howto-15.png)


---


---
id: meshstack.how-to.integrate-meshplatform-gcp-manually
title: How to manually integrate GCP as meshPlatform
---

> The recommended way to set up GCP as a meshPlatform is via the public terraform [GCP meshPlatform Module](https://github.com/meshcloud/terraform-gcp-meshplatform). The steps below are not needed if you decide to use it.

## Set up the Service Account for Replication

meshStack needs a well-defined set of permissions for its automation. meshStack is designed so that it **does not require
access to workload**. We highly recommend that permissions are configured according to the "least privilege" principle.

Platform Operators need to define a [Custom IAM Role](https://cloud.google.com/iam/docs/understanding-custom-roles) called `meshfed-service` at the **Organization Level** with the following permissions

```text
resourcemanager.folders.get
resourcemanager.folders.list
resourcemanager.organizations.get
resourcemanager.projects.create
resourcemanager.projects.get
resourcemanager.projects.getIamPolicy
resourcemanager.projects.list
resourcemanager.projects.move
resourcemanager.projects.setIamPolicy
resourcemanager.projects.update
resourcemanager.projects.createBillingAssignment
resourcemanager.projects.deleteBillingAssignment
billing.resourceAssociations.create
serviceusage.services.enable
serviceusage.services.get
deploymentmanager.deployments.delete
deploymentmanager.deployments.create
deploymentmanager.deployments.update
deploymentmanager.deployments.get
```

In order to enable meshStack to delete GCP Projects as part of [tenant deletion](./administration.delete-tenants.md), please also include the following permission. We strongly recommend you assign this permission only on those Folders where you want to allow automated tenant deletion.

```text
resourcemanager.project.delete
```

### Configure the Root Project

meshStack requires a project in GCP for some of the resources it uses. It is reserved for use by meshstack and Platform Operators. For this guide, we’ll call the project `meshstack-root`.

### Enable APIs

Enable the following APIs on the `meshstack-root` project from the API Library

- [Admin SDK](https://console.cloud.google.com/apis/api/admin.googleapis.com/overview)
- [Cloud Resource Manager API](https://console.cloud.google.com/apis/api/cloudresourcemanager.googleapis.com/overview)
- [Cloud Billing API](https://console.cloud.google.com/apis/library/cloudbilling.googleapis.com/overview)

### Create meshfed-service Service Account

Create a `meshfed-service` [Service Account](https://cloud.google.com/iam/docs/service-accounts) in the `meshstack-root` project.
Enable the Service Account for “G Suite Domain-wide Delegation” and note the generated `Client Id`.
The Service Account will be identified by an email address like

```text
meshfed-service@meshstack-root.iam.gserviceaccount.com
```

Next, configure either a service account key or workload identity federation for authentication purposes.

#### Service Account Key

Generate and Download a [Service Account Key](https://cloud.google.com/iam/docs/creating-managing-service-account-keys) which will be used by meshStack.

#### Workload Identity Federation

Setting up [Workload Identity Federation](https://cloud.google.com/iam/docs/workload-identity-federation) is more involved but allows meshStack to use short lived credentials without explicitly handing over any secrets or requiring manual rotation.

To use Workload Identity Federation you must create a Workload Identity Pool and Provider ([IAM → Workload Identity Federation](https://console.cloud.google.com/iam-admin/workload-identity-pools)) as part of the meshStack root project.

- For the provider, select "OpenID Connect" and add provider details for "Issuer" and "Allowed audiences" as they're specified by the panel when selecting "Workload Identity Federation" as authentication type for a GCP platform.
- Create an attribute condition to restrict access to replicator and/or metering service accounts: ```google.subject in ['<replicator_subject_from_panel>', '<kraken_subject_from_panel']```. Make sure to replace the placeholders.

After setting up identity pool and provider you need to grant access to the meshStack workload service accounts to access the GCP service accounts.

- Select the workload identity pool and click "grant access".
- Select the GCP service account (e.g. for replication).
- Define the appropriate principal by mapping "subject" to the subject name you received from the panel.
- When prompted, enter anything for OIDC ID token path and download the generated configuration file. Open it to get the `audience` value that is required by meshStack.

In addition to the permissions required to perform resource management or metering the replicator/metering service account must also be permitted to create ID tokens for itself.
ID tokens must be used when calling cloud functions and authentication via workload identity federation does not automatically create such tokens.
Add this permissions by assigning the roles `roles/iam.serviceAccountOpenIdTokenCreator` and `roles/iam.serviceAccountTokenCreator` to the the service account.

#### Grant Resource Permissions

The Service Account will be used by meshStack to perform project replication. Operators thus need to grant it the permissions of the
`meshfed-service` IAM role on those folders of the [GCP resource hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy)
that make up the [Landing Zones](meshstack.gcp.landing-zones.md) for client projects.

> It's a best practice to segregate "user" and "infrastructure" projects in GCP using the resource hierarchy.
> By setting granular permissions (instead of organization-wide permissions) this can limit the access of meshStack's replicator
> to only the parts of the resource hierarchy that it needs to actively manage (principle of least privilege).

#### Grant Billing Account Permissions to the Service Account

In order to associate created projects with a Billing Account, the replicator needs to be granted the
`billing.resourceAssociations.create` permission on the Billing Account. This is best achieved by assigning the
`meshfed-service` IAM Role to the `meshfed-service` Service Account on the Billing Account in [the Billing Account's permissions](https://cloud.google.com/billing/docs/how-to/billing-access#update-cloud-billing-permissions).

#### Optional: Billing Account owned by a different organization

In order to use a billing account that is owned by a different organization the permissons for `meshfed-service` user need to be adjusted.

Platform Operators create a custom role `meshfed-billing-creator` in the organization that owns the target billing account with the following permisson

```text
billing.resourceAssociations.create
```

The `meshfed-service` user needs to be granted the `meshfed-billing-creator` role in the organization that owns the target billing account.

Following the principle of least privilege, operators should remove the `billing.resourceAssociations.create` permisson from the custom role `meshfed-service` created in [meshfed-service IAM Role](#set-up-the-service-account-for-replication).

#### Optional: Using Different Billing Accounts for Different Google Cloud Projects

By default, meshStack will associate all created Google Cloud projects with the same billing account. If you want to use different
billing accounts for different projects, you can do so via the following steps:

1. Create a dedicated tag in meshStack with the exact name `billingAcc` to track custom billing account IDs.
   This has to be a tag on either the workspace, project or payment method.
2. You can now use this tag to explicitly set the billing account ID. Upon tenant replication, it will set the 
   billing account ID to the value given inside the tag. If no tag is set on the
   object in meshStack, it will default to the default billing account ID from the platform configuration.

## Set up Cloud Identity

### Authorize the Service Account

In order to perform certain group related administrative tasks the previously created `meshfed-service` service account needs the "Groups Admin" role from the Admin Console (G Suite).

To authorize the Service Account **via the Google Admin Console** navigate to `@Account` in the sidebar and then `Admin Roles → Groups Admin` and click `Assign Service Accounts`. In the prompt that appears, enter the service account email, which looks like `user@project.iam.gserviceaccount.com`.

You can alternatively authorize the Service Account **via the Cloud Identity Groups API**. Please find the instructions in for this in the official [Google guide](https://cloud.google.com/identity/docs/how-to/setup#auth-no-dwd).

## Set up the Service Account for Metering

meshStack needs a separate service account to provide metering functionality. Create a new service account `kraken-service` and
assign it the following [predefined roles](https://cloud.google.com/bigquery/docs/access-control):

```text
roles/bigquery.jobUser (on the project of the ServiceAccount)
roles/bigquery.dataViewer (on the project that holds the bigquery billing/carbon export dataset)
```

To enable meshStack to periodically collect active projects, create an IAM role with the following permissions and assign it to the service account.

```text
resourcemanager.folders.get
resourcemanager.folders.list
resourcemanager.projects.get
resourcemanager.projects.list
```

### Set up GCP Billing data export

Complete the GCP instructions to set up [Cloud Billing data export to BigQuery](https://cloud.google.com/billing/docs/how-to/export-data-bigquery#setup).
We recommend using the "standard usage cost data" export with meshStack.

Once billing export has been setup as explained in the GCP documentation linked above, set up the `kraken-service` service account with
access to the exported billing dataset. You can set up this permission either on the project containing the dataset
or directly on the dataset itself.

```text
roles/bigquery.dataViewer
```

### Optional: Provide a custom BigQuery table

Beyond the default BigQuery Billing Export, meshStack can also support custom BigQuery tables. You might want to apply
some custom transformations or logic on the data. As long as the view or table is given in the same format as the
default BigQuery Billing Export, meshStack can handle and process the data.

Below, the columns are listed that are required by meshStack, and in which format. Make sure that the data types are
the same as the default export.

- invoice.month
- project.id
- service.id
- service.description
- sku.id
- sku.description
- currency
- usage.pricing_unit
- cost
- credits.amount
- usage.amount_in_pricing_units
- cost_type
- Partition Time*

*Since BigQuery doesn't allow column names that start with an underscore character, you have to map the `_PARTITIONTIME`
column to a different name (see example query [below](#example-multiple-billing-accounts-for-the-same-gcp-organization)). This column name has to be configured in the platform configuration
under 'Partition Time Column'.

Make sure that the `kraken-service` service account has permission on the table or view as described above.
Then, enter the BigQuery reference in the GCP meshPlatform configuration in meshStack, which you can find under
'Metering Configuration' → 'BigQuery Table'.

#### Example: multiple billing accounts for the same GCP organization

There can be situations where you want the projects inside a single GCP meshPlatform to be associated with multiple
billing accounts. One such example is when you have one billing account which has
[Spend-based committed use discounts](https://cloud.google.com/docs/cuds-spend-based) applied and another billing account
which contains free credit applied. To ensure that meshStack collects data from both the accounts, you can to create
a view in BigQuery which is a union of the two billing data exports from the two billing accounts. Such a union can be
created with a query which looks similar to the following.

```sql
(SELECT _PARTITIONTIME as PARTITIONTIME, billing_account_id,service, sku, STRUCT(project.id as id, project.ancestry_numbers as ancestry_numbers) as project, labels, system_labels,
        location, cost, currency, usage, credits, invoice, cost_type, adjustment_info
        from `project-name-root.billing_export.gcp_billing_export_general`)
UNION ALL
(SELECT  _PARTITIONTIME as PARTITIONTIME,billing_account_id,service, sku, STRUCT(project.id as id, project.ancestry_numbers as ancestry_numbers) as project, labels, system_labels,
        location, cost, currency, usage, credits, invoice, cost_type, adjustment_info
        from `project-name.billing_export.gcp_billing_export_credit`)
```

Configure this view as mentioned in the section above and meshStack will start using this data for cost collection.

### Optional: Filter billable projects from the export

The GCP platform configuration offers an "additional filter" setting. meshStack will include configured filters in the
`WHERE` clause of its query to read billing data from the export table. This enables scenarios like excluding projects
under a certain part of the organizational hiearchy from meshStack.

The following example excludes all projects nested underneath folder `123456789` in your resource hierarchy.

```sql
AND "123456789" IN UNNEST(SPLIT(project.ancestry_number, "/"))
```

### Optional: Enable GCP Cloud Carbon Footprint Export

meshStack metering supports general environmental reports based on GCP Cloud Carbon Footprint data.
To enable this feature,set up a big query data set containing the carbon footprint export data, see
[Export your carbon footprint](https://cloud.google.com/carbon-footprint/docs/export#bigquery) on the GCP documentation.

Then enable the `kraken-service` service account to read this dataset.

```text
roles/bigquery.dataViewer
```

Finally configure the table id containing the exported carbon data in the meshPlatform configuration.

> Setting up GCP Big Query Transfer configuration will execute the transfer job on behalf of the user setting up
> the transfer config. The user must therefore grant permission to the big query service to access their account.
> This is a [limitation](https://cloud.google.com/bigquery/docs/use-service-accounts) of the big query data transfer service authorization model.

## Optional: Enable Audit Logs for meshfed-service User

The actions of the `meshfed-service` User can be monitored via [Audit Logs](https://cloud.google.com/logging/docs/audit/). This allows an in-depth view meshStack activities for GCP project at any moment.

### Enable Audit Logs

> Enabling Audit Logs may incur charges.

meshcloud recommends to enable Audit Logs on the organizational level for monitoring `meshfed-service` User. This is achivied by following these steps:

1. Navigate to the organizational level in [GCP Cloud Console](https://console.cloud.google.com/)
2. Navigate to [IAM & Admin → Audit logs](https://console.cloud.google.com/iam-admin/audit)
3. Filter the table for `Cloud Resource Manager API` and select the resulting entry
4. Enable all log types

You may want to check the [official Google instructions](https://cloud.google.com/logging/docs/audit/configure-data-access#config-console-enable) on enabling Auit Logs for further information.

The below screen shot show how to set up the Audit Logs for the organization `dev.meshcloud.io`

![GCP Audit Logs](assets/gcp-enable-audit-logs.png)

### Query Audit Logs in Google Cloud Console

Please consult [Google docs](https://cloud.google.com/logging/docs/audit#viewing_audit_logs) for options to querying Audit Logs.



---


---
id: meshstack.aks-platform-quickstart-guide
title: AKS Platform Quickstart Guide
---


## Introduction

Welcome to the **First Platform: AKS guide**! This guide provides step-by-step instructions to help you quickly set up
your first meshStack platform integration with Azure Kubernetes Service (AKS).

## Goals

By the end of this guide, you will have achieved:

1. Creating a platform integration with AKS. This will allow:
   - provisioning new namespaces
   - assign users
   - assign tags (optional)
2. Successfully testing the AKS integration

This allows your application teams to open up meshStack and provision themselves namespaces and authorization on AKS.

## Prerequisites

Before starting, ensure you have the following:

- An AKS Cluster that is publicly accessible via the internet
- A place to run Terraform. For example, your local machine, or the Azure cloud shell.

## Preparing Infrastructure in Azure

To integrate your AKS cluster into meshStack properly, we require a few things to be in place in AKS & Azure for a successful integration.

In this guide, we will use our Terraform module to set these things up. You can also do this manually, but we highly recommend doing this with Terraform, and for this guide we assume you did.

Amongst other things, the Terraform module will create a service user with the right permissions in the Kubernetes cluster and create a service principal in Azure to interact with your Entra tenant.

Click [here](https://github.com/meshcloud/terraform-aks-meshplatform) and follow along the guide in the README to use the Terraform module.

Make sure you execute the last step of exporting the outputs and save these somewhere. We need them later in this guide.

## Creating the Platform

1. **Open the platform list in the platform builder**

   When entering your workspace, click the blue “Platform Builder” button at the top-right if you haven’t already. Then open the menu on the left-hand side and click on “Platform → Platforms”.

2. **Create a new platform**

   In the list, click on the button “+ Create new platform”. A wizard will open where we will have to enter some information.

3. **Select platform type**

   Under “Platform Type” pick “Azure Kubernetes Service”.

4. **Enter name, identifier & description**

   Enter a fitting name, for example “Azure Kubernetes Service”. You can pick a more specific name if you have multiple clusters for example.

   For the identifier pick something similar to the name, for example `aks`.

   For the description you can write a little bit of additional information about your cluster that people can see in the marketplace. You can also leave this empty for now.

5. **Enter cloud platform web console URL**

   Enter a URL here that users can use to open the web console of your AKS cluster. You can enter the API Server Address that can be found in Azure Portal when opening up your AKS cluster.

   The support & documentation fields below can be left empty.

6. **Create a new location**

   Locations are a grouping mechanism for multiple platforms in meshStack. For now you can create a new location and give it the name and identifier “AKS”. After that, click “Next”.

7. **Pricing**

   You will be prompted to enter a price for your new platform. You can skip this for now.


🎉 The platform is created in meshStack! But it won’t be usable yet. We will have to properly integrate it now


## Configuring Integration

1. **Open the configuration**

   In the last step you should have landed on the configuration page. If not, or if you navigated away again in the meantime, open up the platform and go to “Settings → Configuration”.

2. **Enter base URL**

   Enter the base URL for calling the APIs of your cluster. An example URL is `https://aks-meshcloud-dev-dns-95df19f5.hcp.westeurope.azmk8s.io`.

3. **Add replication config**

   Click the green “+ Add config” button under “Replication Configuration”. This configuration is responsible for managing namespaces & IAM.

4. **Enter access token**

   From your Terraform outputs from before (Preparing Infrastructure step) grab the `replicator_expose_token` value and paste it into the “Access Token” field.

   The next field “Namespace Name Pattern” you can leave as-is for now.

5. **Configure Entra tenant**

   In the section below under “Additional Access Configuration” go AKS-specific configuration so that meshStack can manage user & groups in your Entra tenant.

   Under “AAD Tenant” enter either the domain name or ID of your Entra tenant that holds the service principal.

   For Authentication Type, you get to pick whether you use Workload Identity Federation or Credentials. Please continue below in the section of your choice. We recommend Workload Identity Federation because it is more secure.

   **Workload identity federation (recommended)**

   Select “Workload Identity Federation” for Authentication Type and you will see a blue banner pop up. Copy the code mentioned there and paste that into the meshPlatform AKS Terraform module from before (if you haven’t already). This will set up Workload Identity Federation for the Service Principal in Azure.

   After that is done, you can look up the `replicator_service_principal` output of the Terraform module and copy the value of the property `Application_Client_ID` into the field in meshStack called “Application (client) ID”.

   In the same object, you should also find the property `Enterprise_Application_Object_ID`. The value of this should go into the field “Enterprise Application Object ID”.

   **Credentials**

   Select “Credentials” for Authentication Type. Make sure you also set `create_password = true` in the meshPlatform AKS Terraform module as a new password is needed for the Service Principal.

   After that is done, you can look up the `replicator_service_principal` output of the Terraform module and copy the value of the property `Application_Client_ID` into the field in meshStack called “Application (client) ID”.

   In the same object you should also find the property `Enterprise_Application_Object_ID`. The value of this should go into the field “Enterprise Application Object ID”.

   Lastly, enter the value of `Client_Secret` into the field “Client Secret”.

6. **Cluster configuration**

   Next up we have to configure more specifics of the cluster that is hosted in Azure.

   You can leave “User Group Name Pattern” as is. If you configured an Administrative Unit for the service principal then enter its ID in the field “Administrative Unit ID”.

   Enter the subscription ID where the AKS cluster is hosted in “Subscription ID”.

   Enter the name of the AKS cluster in “Cluster Name”.

   Enter the Resource Group name where the AKS cluster is hosted in “Resource Group”.

   You can leave User Lookup Strategy as is and you can leave the B2B User Federation section untouched.

   We will also skip the “Metering Configuration” part of this guide as it is related to monitoring costs and setting prices of your cluster.


🎉 All the necessary configuration has been filled in! Let’s create a landing zone now and then test the new platform.

## Creating a Landing Zone

The last step before testing the platform is creating a so-called landing zone. The landing zone contains configuration for auto-deletion settings, role mappings & more. Landing zones can be used to split up different behavior depending on environments e.g. dev & prod. It is mandatory for a platform to have a landing zone.

1. **Create new landing zone**

   Open up the “Landing Zones” tab in your platform and click “+ Create new Landing Zone”.

2. **Fill in general information**

   Enter a fitting name, identifier and description for the landing zone. You can simply enter “AKS” for name and identifier and enter a simple description such as “Default setup for a new AKS namespace.

3. **Enable deletion**

   If wanted, you can enable automated tenant deletion by checking both boxes under “Tenant Deletion”. This will allow your application teams to delete their namespaces in self-service using meshStack.

4. **Enter role mappings**

   On the right-hand side create a total of three role mappings by clicking “+ Add Role Mapping” three times.

   In here we can select which role in meshStack relates to which role in your kubernetes cluster. As a start, we recommend the following mapping:

   - Project Admin → `admin`
   - Project User → `edit`
   - Project Reader → `view`

5. **Create the landing zone**

   Below the role mappings is a section called Quotas. We will skip this for now, but it allows you to manage default quotas for newly created namespaces.

   Finish the process by clicking “Save” at the bottom of the page.


🎉 The landing zone has been created! Let’s get to testing

## Testing Tenant Creation

We will now use the same workspace to test the flow of creating a new namespace (also known as a meshStack **tenant**) from the completely same perspective as your application teams.

1. **Open the workspace manager**

   The easiest way to do this is by clicking the meshStack logo all the way on the top-left of meshStack.

2. **Open the marketplace**

   Open the marketplace tab and look for your AKS platform and open it up

   > You’ll notice it says “Private”. This platform is already available in your own marketplace but it won’t be for anyone else yet until it is tested and published.

3. **Add the platform**

   Click “Add to project” and you’ll be prompted to select a project. You can either pick an existing project (if you have one) or create a new one.

4. **Create the new tenant**

   Depending on what you did above finish the creation of the tenant (and project) and follow the instructions on the screen.

5. **Monitor the tenant status**

   Open up the tenant you just created and wait for it to finish the replication process. This should not take longer than a minute.

6. **Success?**

   If all went well, you should see a green “Replication Success” label pop up. If not, and an error occurred, let’s investigate the issue.

7. **Fixing replication issues**

   (This part is only relevant if the replication failed) You can go back to the Platform Builder and open up the list of tenants under “Platforms → Tenants”. Open up the newly created tenant and you should see more detailed logs on why the replication process failed. This can have many reasons such as wrong credentials or mistyped configuration. You can try and solve the issue by changing your configuration and running replication again on the tenant.


🎉 That’s it! You successfully integrated your AKS cluster as a platform in meshStack and tested that it works

## What’s next?

- [Publish the platform](./marketplace.service-management-area.md#publishing) so anyone in the organization can use it and provision namespaces in self-service.
- [Build a developer platform](./meshstack.aks-developer-platform-quickstart-guide.md) on top of the AKS platform.
  This can be a developer platform that contains all the tools your developers need to build applications on top of Kubernetes.
- Build your own building blocks on top of the platform for commonly used services in Kubernetes.
- [Integrate more platforms](./meshstack.how-to.integrate-meshplatform.md) such as AWS, Azure or GCP.


---


---
id: administration.building-blocks
title: "Building Blocks"
---

Building Blocks are a useful tool to make the journey to successful cloud projects even faster and more automated.
For use cases where you roll out or offer pieces of cloud infrastructure & configuration repetitively, meshStack's
Building Blocks can help you take work out of your hands.

Building Blocks can be added on-demand by your users in self-service in the tenant control plane, or when
your users create a new meshProject or meshTenant.

Building Blocks are instantiated from so-called Definitions. These Building Block Definitions are created and maintained
in the Admin Area by the Cloud Foundation Team. Read more below on how you can create and deploy a new Building Block
Definition.

## meshStack Hub

[meshStack Hub](https://hub.meshcloud.io) serves as a central hub for building block modules.
We invite you to explore and take advantage of the existing modules, or even contribute your own if you have created any.
Our modules are conveniently organized by cloud providers, making it easy for you to quickly find what you need in the respective folders.

## Creating a new Building Block Definition

In the Admin Area, click on the "Building Block" item in the sidebar under "Platforms". On this page, click
"Create new Definition". A wizard opens that guides you through the creation of the entire Building Block Definition.

> meshStack supports Terraform up to version 1.5.5 and supports OpenTofu versions starting with 1.6.0.

## Building Block Types

There are currently two options for a building block type.  
**Important:** This decision is crucial and **cannot be changed later**.

### Workspace Building Block

A workspace building block is created under a workspace and is globally available to the entire workspace to all projects.  
Use this type when the service does **not need to be tied to a specific cloud tenant**—for example, project tooling or a central identity service.
Workspace building blocks don't have prerequisites such as platform type, platform, landing zone or a tenant. They have an individual
life cycle. Furthermore, their consumption can be restricted via policies.

### Tenant Building Block

A tenant building block is tied directly to a specific cloud tenant, such as a virtual network or database within an AWS Account or Azure Subscription.  
When the tenant is deleted, the building block **must also be deleted**. Tenant building blocks can have a price setup for them that is added to 
the tenant usage report and chargeback statement. Furthermore, they can be restricted via policies.


### General Building Block Definition Information

On the first page, you simply have to put in:

- A name that distinguishes your Building Block.
- A description where you can further explain what the Building Block is.
- A symbol of the Building Block that will be visible to you and your customers. This can be useful when you provide
  a service that already has a logo.

### Implementation Details

Next, you have to enter how the implementation of the Building Block works.

First of all, pick for which platform type(s) the Building Block is supported. Usually this is just one platform type
but you could have one that works for multiple clouds or maybe it is even a cloud-agnostic block.

Next, you have to decide how often the Building Block definition can be added for a meshTenant:

- Multiple: there is no limit to how often you add a building block of this definition to a meshTenant.
- Once: there can only be one Building Block of this definition added to a meshTenant.
  This is useful for core Building Block, e.g. a virtual network for connecting to a central hub network.

Next up is an important decision: the implementation type. As of now these are only two, but we hope to add a lot more
in the future and even let you develop your own implementation types for Building Blocks. Now, you can either pick:

- Manual: this means the Building Block is fully managed manually. Ideally you always automate your Building Blocks
  but manual Building Blocks can be a good start to get familiar with the concept and give a clear ordering flow
  to your customers. It can also be an easy option to evaluate if a need for a new building block definition exists.
  You just create a manual block and observe how many application teams use the definition.
  You can switch the definition to an automated building block in the future.
- Terraform: this is the option to automate your Building Block. You only need a Terraform module and meshStack will
  run this configuration everytime a user adds a new Building Block to a meshTenant.
  In a later step you can setup Inputs for your
  Terraform script. There is also a [section](#developing--deploying-a-terraform-building-block)
  below with further tips for developing Terraform Building Blocks.

If you pick Terraform you have to enter a few further values:

- Terraform Version: the version your Terraform modules shall be executed with.
- Git Repository URL: the URL of the Git repository where your Terraform module resides.
- (Optional) Git Repository Path: the specific directory in the repository where your Terraform module resides.
- (Optional) Private SSH Key: This is needed and the only option to access private repositories.
  Upload an SSH key that has access to the provided Git repository.

Lastly, you have to decide what the behavior of the Building Block is when it is deleted by the customer user. This can be

- Purge in meshStack: (this is the only option if you have a manual Building Block) The Building Block is deleted
  in meshStack, but no underlying resources (e.g. in a cloud platform) are deleted. You have to do this yourself.
- Delete Resources: this option also cleans up the underlying resources. The workings depend on the implementation
  type, but e.g. for Terraform meshStack will call `terraform destroy` on the Terraform module.

### Dependencies

> Please note that the use of dependencies is completely optional and this step can be skipped.

In some cases you might find that you have multiple Building Block definitions, and one depends on the other.
For example, you might have a Virtual Network, which is a prerequisite for a Virtual Machine.

You can model and enforce such dependencies in meshStack using the Building Blocks feature.

In the wizard, on the "Dependencies" page, you have to select the Building Block(s) definitions
that the _about to be created_ Building Block depends on. So in the example above you would have to do the following:

1. Create the Virtual Network Building Block without any dependencies.
2. Create the Virtual Machine Building Block and select the Virtual Network as a dependency.

> For Terraform users: you can provide the output of the Virtual Network Building Block as input for the Virtual
> Machine Building Block.
> It is also possible that Building Blocks definitions of different implementation types can be dependent on each other
> and share inputs & outputs.

### Building Block Inputs

As with a lot of configuration, input is required. Building Blocks in meshStack can collect as much input as you want,
in many ways possible.

There are different kinds of inputs, with different behavior, which can be decided under the "Source" section. You can
read in the meshPanel what each kind of input does and how it behaves.

The inputs' behavior can be further decided:

- Provide as: you can decide whether the input is regularly provided as an input variable or as an environment variable.
  (only applies to Terraform Building Blocks)
- Sensitivity: you can decide that an input is sensitive (e.g. a secret). It will then be encrypted in meshStack and not
  shown to any users. Also meshStack only has very limited access to this secret. Only once Terraform gets executed,
  the secret is decrypted.

#### Input Types

We support the following types of inputs:

- String
- Number
- Boolean
- Single Select
- File (this will place a file in the working directory of Terraform. The name of the input will be used as the filename. Usually you can use a relative path to access the provided file like ./FILENAME.)

In the future we also plan to have more complex types such as LIST and MAP as well.

#### User Permissions

On top of all the input types described above there is also a special kind of input where you receive all assigned project users & roles.
This input is called "User Permissions" and it has to be selected under "Source -> User Permissions". This can be useful to provide users with access to certain resources in a 
platform. It provides a list of objects to the Building Block, with a JSON structure that looks like this:

```json
[
  {
    meshIdentifier: 'identifier1',
    username: 'johndoe',
    firstName: 'John',
    lastName: 'Doe',
    email: 'johndoe@test.com',
    euid: 'johndoe',
    roles: ['reader']
  },
  {
    meshIdentifier: 'identifier2',
    username: 'lisaluck',
    firstName: 'Lisa',
    lastName: 'Luck',
    email: 'lisaluck@test.com',
    euid: 'lisaluck',
    roles: ['admin', 'reader', 'user']
  }
]
```

### Building Block Outputs

You can also extract the Terraform outputs into meshStack. This is useful in two scenarios:

1. You want to provide an output variable to a dependent Building Block. As the example that was mentioned above, if
   you have a virtual machine that depends on the VNET ID of a virtual network, you can output the
   variable and provide it as an input to the dependent virtual machine Building Block.
2. You want the customer user to be able to see the output result. This might be useful if there is an output that is
   important to the customer user. They will be able to read the value in their tenant control plane.

Last but not least, save your Building Block definition, and it is be ready to be consumed by your application teams!

## Developing & Deploying a Terraform Building Block

For Terraform blocks, meshStack will run the required Terraform in the background.

### State Storage Recommendations

Storing state is a crucial aspect of Terraform. We have the following recommendations regarding state storage when
using Terraform-based Building Blocks in meshStack:

1. Use a remote backend to store your state like Amazon S3, Azure Storage or Google Cloud Storage.
2. Use a single storage per Building Block Definition. meshStack organizes the storage on a per workspace/project basis.
   By using a single storage per Building Block Definition you keep a clear separation of your state.
3. Apply backup best practices to your remote backend so you can restore your state in case you run into an issue.

### Configure remote backend

1. Copy one of these examples into a file named `backend.tf` and adopt the parameters.
2. Either put this backend.tf file inside your terraform module folder or upload it as a static file input along with the other inputs inside your Building Block definition. 
3. Make sure to include the necessary credentials required for accessing the storage account. For instance, for a storage account in Azure, you can add "ARM_CLIENT_ID" and "ARM_CLIENT_SECRET" of the Service Principal as an Environment Variable.

**Important:** When making use of an input parameter of type "File," it's important to note that the "Name" you assign to the input parameter will be used as the filename for the uploaded file. For example, if your Terraform code references a credential file as "key.json" in your terraform code, you should use the exact same name in your input "Name" field.

#### AWS S3 Bucket

```hcl
terraform {
  backend "s3" {
    bucket = "<bucket name>"
    key    = "<Prefix of the state file name>"
    region = "<Location name>"
  }
}
```

#### Azure storage account

```hcl
terraform {
  backend "azurerm" {
    tenant_id            = "<Tenant ID>"
    subscription_id      = "<Subscription ID>"
    resource_group_name  = "<Name of the resource group holding the state file>"
    storage_account_name = "<Name of the Storage account holding the state file>"
    container_name       = "<Name of the Container holding the state file>"
    key                  = "<Prefix of the state file name>"
  }
}
```

#### GCS Bucket

```hcl
terraform {
  backend "gcs" {
    bucket  = "<Name of the bucket holding the state file>"
    credentials = Local path to Google Cloud Platform account credentials in JSON format
    prefix  = "<Prefix of the state file name>"
  }
}
```

### How to debug

You can view the logs of meshStack running the Terraform files. To do so, go to the Tenant Overview in the Admin Area
and look for a meshTenant that has added the Building Block. In there you will be able to find the Building Block
and read the logs that were written while executing the Terraform.

## Editing Building Block Definitions

It is possible to edit existing Building Block Definitions, but you will be required to create a new **version**. This way
any users of your "old" Building Block Definitions will not experience any impact. 

To properly make changes to your Building Block Definition and also upgrade the existing Building Blocks, do the following:

1. Open the Building Block Definition.
2. On the right-hand side there is a version dropdown. Click the button "Create Draft" next to it and confirm the creation.
3. Your Building Block Definition is now in draft state. While in draft state, you can make any changes that you like
   such as removing inputs, adding inputs, or changing the Git commit hash.
4. When you are happy with your changes, publish the new version. On the right-hand side, next to the version dropdown, click on "Publish".
5. The new version is now published! This also means that any workspace users that create new Building Blocks will use that version by default

At this point, any existing Building Blocks still use the old version. To make sure that these are also upgraded to the latest version do the following:

1. On the left-hand side open up the list of all Building Blocks.
2. In the list, search for all Building Blocks of the recently upgraded Building Block Definition.
3. Tick all Building Blocks that you want to upgrade and click on the right-hand side on "Actions > Upgrade".
4. Confirm the upgrade, enter any missing input (if applicable) and run the upgrade.
5. That's it! The Building Block is now upgraded! A new run has also started in the meantime so that any changes to the
   Terraform are applied as soon as possible.

## Updating a Building Block Definition

As an admin or owner of the Building Block Definition, you can select one or more Building Blocks and click “Actions -> Update” at the top of the screen to update to the newest version. Application teams do not have permission to update Building Block Definitions.


---


---
id: meshstack.identity-provider
title: Identity Provider
---

Partners must be aware of the following requirements and limitations for IdPs serving as identity sources for meshStack.

## Supported Federation Technologies

The main supported technologies for Identity Federation with meshStack are

- LDAP
- Open ID Connect
- SAML
- Azure AD

meshStack supports the simultaneous integration of multiple [Enterprise Identity Providers (IdPs)](https://en.wikipedia.org/wiki/Identity_provider) at the Identity Broker. This allows Partners to combine identities from different sources in the platform and unify management of multi-cloud access in meshStack.

## User Attribute Requirements

- IdPs must provide
  - a stable and immutable user identifier (e.g. an OIDC `sub` claim)
  - a human-readable, unique username*
  - an email address
  - an `euid` when using [externally-provisioned identities](#externally-provisioned-identities)
- IdPs should provide name (first name, given name) information to improve user experience

> \* Please note that meshStack currently only offers limited support for propagation of changed usernames from IdPs.


## Identity Provider Configuration Tutorials

### Active Directory Federation Services (AD FS)

Initially provide the URL of your AD FS to meshcloud, so a Identity Provider can be configured in the meshIdB. meshcloud will then provide a SAML descriptor URL, that can be used to configure AD FS.

With AD FS 3.0 (2012 R2) and newer, a Relying Party Trust must be created in AD FS. As OIDC Support is limited in AD FS 3.0, SAML should be used in that case and is described here. For newer AD FS versions you may also define an OIDC client, which is not part of this documentation.

In AD FS Management console, right-click "Trust relationships → Relying Party Trusts" and select "Add Relying Party Trust" from the menu. At the beginning of the wizard, enter the SAML descriptor URL that will be provided by meshcloud (it is individual per meshcloud installation) into the Federation metadata address field. Let AD FS import the settings. Proceed with the wizard, and adjust the settings where appropriate. Here we use only the default settings. Note that you will need to edit the claim rules so when asked to do so at the last page of the wizard, you can leave the checkbox checked on.

Now the SAML protocol would proceed correctly, AD FS would be able to correctly authenticate the users according to requests from Keycloak, but the requested name ID format is not yet recognized and SAML response would not contain any additional information like e-mail. It is hence necessary to map claims from AD user details into SAML document.
We will set up three rules: one for mapping user ID, second for mapping standard user attributes, and optionally third for a user group, if needed.

#### Rule for Mapping user ID

1. Open the `Edit Claim Rules` dialog.
2. In the `Add Transform Claim Rule` dialog, select `Transform an incoming claim`.
3. Map the following attributes:
    - `Name ID` as `rule name`
    - `Windows account name` for property `Incoming claim type`
    - `Name ID` for property `Outgoing claim type`
    - `Windows qualified Domain Name` for property `Outgoing name ID format`
4. Click Finish to add the rule.

#### Rule for Mapping the Attributes of the Standard User

1. Open the `Edit Claim Rules` dialog.
2. In the `Add Transform Claim Rule` dialog, select `Send LDAP attributes as Claims rule`.
3. Map the following attributes:
    - `E-Mail-Addresses` to `E-Mail Address`
    - `SAM-Account-Name` to `Subject Name`
    - Your LDAP attributes for `surname` and `given name`

#### Rule for Mapping AD groups

If meshcloud shall restrict access via certain AD groups, you can define another claim.

1. Start again in the `Edit Claim Rules` dialog.
2. Select `Send Group Membership as a Claim` rule type.
3. Usually two groups should be defined via this. They should result in Outgoing claim type `Group` with Outgoing claim values `meshUser` and `meshManager`. A `meshUser` can login to meshcloud and be invited to existing meshWorkspaces. A `meshManager` is allowed to create new `meshWorkspaces`.

### Azure AD (AAD)

To set up Azure Active Directory for IDP authentication follow these steps:

1. Create a new non-gallery Enterprise Application in AAD ([Microsoft Documentation](https://docs.microsoft.com/en-us/azure/active-directory/app-provisioning/use-scim-to-provision-users-and-groups#getting-started)) with display name `meshcloud SSO` or similar.

    ![Register non-gallery Enterprise Application](./assets/aad_identity_provider/aad-1.png)

    > We create a non-gallery Enterprise Application (that creates an App Registration) instead of directly creating an App Registration here because [provisioning via SCIM](meshstack.user-group-provisioning.html#aad-configuration) will be set up later with this Enterprise Application.

2. Open the App Registration for `meshcloud SSO`. Navigate to Authentication and add a new Platform of Type Web. Enter the redirect URI for your meshStack that was provided by meshcloud.

    ![Add Authentication to App Registration](./assets/aad_identity_provider/aad-2.png)

3. Create a client secret via "Manage -> Certficates & Secrets". This secret must be shared with meshcloud.

    ![Add Secret to App Registration](./assets/aad_identity_provider/aad-3.png)

4. Share "Application (client) ID" and "Directory (tenant) ID", that is shown in the Overview screen of your new app registration, with meshcloud.

    ![Read Client ID and Tenant ID of App Registration](./assets/aad_identity_provider/aad-4.png)

5. Provide delegated admin consent for the `User.ReadAll` permission of the app registration.

    ![Grant admin consent](./assets/aad_identity_provider/aad-5.png)

### Google Cloud Directory (GCD)

The setup of the GCD Federation is quite straight forward. The easiest way to do is to setup a SAML login federation between meshstack and Google. To do so follow these steps (for more detailed steps you can also follow the [SAML guide](https://support.google.com/a/answer/6087519?hl=en) from Google):

1. Login into the GCD Admin area ([admin.google.com](https://admin.google.com)).
2. Click on `SAML Apps` and create a new SAML app by clicking on the plus button bottom right, then `Setup my own custom app`
3. In the upcoming windows please download the IDP metadata. This data is important for setting up the Keycloak. Also copy the `SSO URL` and provide both to meshcloud.
4. Chose a name (e.g. `meshstack sso`), a picture and description as you like.
5. You probably need to input first a placeholder for the `ACS URL` and `Entity ID`, as meshcloud can only provide you these values when we setup the SSO with the data you gathered in the earlier steps. When this was done and we notified you about the correct `ACS URL` and `Entity ID` you can edit this SAML App again and finalize its setup with the information we provided you.

You must also add three mappers so essential user information to identify the user is transferred to meshcloud during the SAML handshake. The attribute name must match exactly. The attributes are:

| Attribute Name |            Source Property            |
| -------------- | :-----------------------------------: |
| email          | Basic Information -&gt; Primary Email |
| firstName      | Basic Information -&gt; First Name    |
| lastName       | Basic Information -&gt; Last Name     |


---


---
id: meshstack.how-to.onboard-team-to-project
title: How to onboard your team to a meshProject
---

If you are not familiar with what a meshProject is, please check the [official meshcloud documentation](meshcloud.project.md).

## Pre-Requisites

- Users you want to add to an meshProject needs to be added to the meshWorkspace first. Check out the `Onboarding your team to your meshWorkspace` guide.
- Permissions: Your user needs either the Workspace Manager or Workspace Owner role in the meshWorkspace

## Step to Step Guide

- Make sure you are in the meshWorkspace you want to add further users. Do this by checking the drop-down in the upper-left corner.

![Select meshWorkspace in the upper left corner](assets/workspace/choose-workspace.png "Pick meshWorkspace")

- You need to navigate to the meshProject where you want to onboard your project team members.

- Select the meshProject using the top navigation bar

![Select meshProject in the upper left corner](./assets/project/project-in-top-nav.png)

- Select the meshProject from the meshWorkspace overview

![Select meshProject in meshWorkspace overview](./assets/project/project-in-overview.png "Access Control - Access Requests")

- Go to the access control panel by clicking on the `Project Access` tab
- At the end of the `Current Access` list will be an input field. Type in the first-, last-name or email address to find and select the user you want to add. Choose a Project Role and press the `+` button.

![Add a user to the workspace](./assets/project/project-access-control.png "add a user")

### Optional

meshStack enterprise supports 4-eyes access controls.
Please check the [official meshcloud documentation](meshcloud.project.md#access-control-on-a-meshproject).

- A second user with Workspace Manager or Workspace Owner permission needs to approve the access request. The second user must also navigate to the specific meshWorkspace (see step 1.), select the meshProject (see step 2.), go to the `Workspace Access` tab (see step 3.) and then click on the `Access Requests` tab in the second tab-row.
![Click the Access Requests tab](./assets/project/project-access-approve.png "Access Control - Access Requests")


---


---
id: meshstack.meshmarketplace.metering
title: Metering
---

meshStack supports metering of OSB Services. This allows Service Owners to collect charges using
meshStack's multi-cloud chargeback process.

## Product Catalog Configuration

Serice Owners that want to charge consumers of their services via meshStack need to expose cost information
in the service catalog of their Service Broker implementations. meshStack metering will then automatically calculate charges
and generate a [Tenant Usage Report](./meshcloud.project-metering.md) for each OSB Services Platform used in a meshProject.

In the context of OSB Services metering Service Owners are also called **Sellers**. The id of a seller is the
identifier of the meshWorkspace that has registed the Service Broker with the meshMarketplace.

### OSB API Service Catalog

The Service Broker's OSB API service catalog must provide cost information for each service plan as described in the [OSB API spec](https://github.com/openservicebrokerapi/servicebroker/blob/v2.15/profile.md#service-metadata). The code snippet below provides an example for describing
the cost of a service plan.

```json
{
  "plans":[
    {
      "id":"024f3452-67f8-40bc-a724-a20c4ea24b1c",
      "name":"bunny",
      "description":"A mid-sided plan.",
      "metadata":{
        "bullets":[
          "20 GB of messages",
          "20 connections"
        ],
        "costs":[
          {
            "amount":{
              "eur":99.0
            },
            "unit":"MONTHLY"
          },
          {
            "amount":{
              "usd":1000.00
            },
            "unit":"SETUP FEE"
          }
        ],
        "displayName":"Big Bunny"
      }
    }
  ]
}
```

meshStack interprets the `costs` property for each plan and automatically maintains corresponding entries in the
[meshStack metering product catalog](meshstack.billing.md#defining-a-custom-product-catalog).

> meshStack relies on Service Owners to provide accurate cost information in their service plans. When generating
> Tenant Usage Reports, meshStack metering uses the latest available cost information in the meshStack product catalog.
> Service Owners must thus be careful to ensure that any price changes are communicated to service consumers in advance
> and get published in OSB API service catalogs after usage reports of the previous period were finalized.

The following sections detail how meshStack interprets OSB API plan [cost objects](https://github.com/openservicebrokerapi/servicebroker/blob/v2.15/profile.md#cost-object) to create meshStack metering product catalog entries.

### Supported Unit Types

[Cost objects](https://github.com/openservicebrokerapi/servicebroker/blob/v2.15/profile.md#cost-object) in the OSB API specification support only a single `unit` field. However, service owners can specify multiple cost objects
for each plan so that different types a single service instance can incur multiple different types of charges simultaneously.

> Service Brokers must not publish multiple cost objects with the same `unit` value on any given service plan, i.e. a `unit` value can only be used once per plan.

#### Time-based Units

meshStack supports the following `unit` values for time-based metering.

```text
HOURLY
DAILY
WEEKLY
MONTHLY
YEARLY
```

meshStack metering normalizes all time units specified in OSB API service catalogs to an hourly rate using the
following conversion table:

| unit      | hours      |
| --------- | ---------- |
| `HOURLY`  | 1 h        |
| `DAILY`   | 24 h       |
| `WEEKLY`  | 24 h * 7   |
| `MONTHLY` | 30 * 24 h  |
| `YEARLY`  | 365 * 24 h |

Service instances are charged for each started hour using the normalized hourly rate from the moment a user initiates provisioning of the service instance until it is deleted.

#### Quantity-based Units

Direct support for charging based on quantity units (e.g., "GB of messages stored") is not available. However, you can report custom cost data using the [meshResourceUsageReports API](https://docs.meshcloud.io/billing-api/index.html#_put_meshresourceusagereports) to meshStack.

#### Setup Fees

Setup fees allow service owners to charge consumers a flat-fee for provisioning a new service instance. This is useful
if provisioning a service instance incurs a specific one-time overhead (e.g. because it's a very expensive operation or even involves manual work).

Service Owners need to use the following `unit` value to designate a setup fee:

```text
SETUP FEE
```

Note that service plans can have multiple cost objects, so it's possible to e.g. charge an initial setup fee for a
service instance while also charing a monthly usage fee.

#### Flat Fees

meshStack metering will interpret any other `unit` type value not specified above as a "flat fee".
Flat fees always incur the same charge in each reporting period, regardless of the length that the service instance
was actually used in the period. For example, a service instance that was provisioned on the last day of reporing period #1
and deleted on the first day of reporting period #2 would incur a full charge of the flat fee in each reporting period.

### Configuring "out of scope" Sellers

Partners can mark sellers as "out of scope" via configuration. Once a seller is marked as out of scope,
the costs for that seller's products will be set to zero in the meshStack metering product catalog.

The line items for the seller will appear in the usage reports and chargeback statements with an appended "Out of Scope" suffix on the usage type. The total column for those line items will be zero, but the used quantity will be shown correctly.

This feature can be used for services for which usage should be tracked but the chargeback process is not yet completely established.


The following configuration options are available at `mesh.kraken.meshMarketplace`:
<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let MeshMarketplace =
    {-
        outOfScopeMarketplaceSellers:
            A list of seller ids that are "out of scope" for meshMarketplace metering.
            All usage rates for service plans published by these sellers will be replaced with 0.0.

            Note: Seller id's are the meshWorkspace identifiers of the meshWorkspace owning the Service Broker
            registration
    -}
      { outOfScopeMarketplaceSellers : List Text }
```
<!--Example-->
```dhall
let example
    : MeshMarketplace
    = { outOfScopeMarketplaceSellers = [ "demo-seller" ] }
```

## Reviewing Metering Data

Metering & Usage information for Service Owners is available for your Service Brokers from the "Service Broker" tab in your [workspace control plane](./meshcloud.workspace.md#managing-your-meshworkspace).

You see a list of all plans of your Service Broker's services provisioned in projects per period (usually monthly). This information is available individually per OSB Services platform you published your Service Broker to. Click the "Metering & Usage" Button of the according Service Broker to see the Metering & Usage data. You can filter by several criteria like period or service name.

The screen provides you with information about:

- Which workspaces and projects are using your services?
- How long have certain plans been used in projects?
- What are the costs per plan and project for one period?

## Seller Usage Report (CSV Export)

All the metering usage data for your services can be downloaded as CSV. This is called a seller usage report in meshcloud because the service owner acts as a seller on the OSB Services platform.

The download can be triggered directly from Metering & Usage information page. The data transformations like sorting and filtering are also included. Additional meta information can be configured beneath the metering usage information. This information will only be visible within the exported CSV document.


---


---
id: meshstack.billing
title: Cost Management
---

meshStack's cost management functionality enables developers to track resource usage, while platform teams can monitor overall costs and allocate them to specific teams. These cost management capabilities can be broken down into three key sections: metering, billing, and chargeback.


> Learn more about how your cloud foundation team can enable cloud cost management in
> the [Cloud Foundation Maturity Model](https://cloudfoundation.meshcloud.io/maturity-model/cost-management/)


## Metering

> Metering is the process of collecting and calculating cloud resource usage. Metering also involves pricing this resource usage to calculate cost.

meshStack collects all usage information from public cloud providers, each of which has its own metering processes. For private clouds like OpenStack, OpenShift, and Cloud Foundry, meshStack has its own metering system to for example accurately calculate how many RAM hours and vCPU hours a virtual machine consumes over a given period.

Cloud resources exhibit various traits. For instance, a virtual machine typically includes both RAM and vCPU. A crucial component of meshStack is the Product Catalog, which is a list of traits that are relevant for you and prices for them. With the Product Catalog, you can set not only usage prices but also additional prices to cover licensing costs and maintenance of a Platform. Please read more information about the Product Catalog [here](meshstack.billing-configuration.md#setting-internal-prices).


## Billing

> Billing is the process of attributing resource usage to cloud tenants and creating appropriate invoices.

meshStack is creating monthly [Tenant Usage Reports](meshcloud.project-metering.md) that aggregate cloud resource usage data for each tenant over a specific period. These reports not only summarize resource consumption but can also include additional pricing information, as mentioned earlier, along with discounts, such as volume discounts.

Furthermore, instead of providing a single, large invoice as cloud providers do, meshStack prepares invoices tailored to dedicated teams based on their usage, so that they will have a clear overview of cloud costs. This invoice is called a chargeback statement, which is also used to correctly allocate costs to teams. 


> To learn more about enabling a solid private cloud billing process, check [private cloud pay-per-use chargeback](https://cloudfoundation.meshcloud.io/maturity-model/cost-management/private-cloud-pay-per-use-chargeback.html) section in the Cloud Foundation Maturity Model

## Chargeback 

> Chargeback is the process of distributing cloud costs from a consolidated bill to the specific teams or departments that incurred those expenses. This ensures that each team is accurately charged for the resources they consumed, promoting cost accountability.

This chargeback statement is attached to each project in meshStack and each chargeback statement is composed of tenant usage reports. For example, if your project uses both AWS and GCP, you will have one chargeback that combines two tenant usage reports. If you would liket o learn more about chargeback, check [here](meshcloud.project-metering.md)

---


---
id: faq.projects
title: Projects FAQ
---

## How do I move a meshProject from one meshWorkspace to another meshWorkspace?

While it is possible, we advise against moving meshProjects. The recommended option is to create a new meshProject.

Process for moving a meshProject from meshWorkspace `source-workspace` to meshWorkspace `target-workspace`:

1. A Workspace Managers of `source-workspace` marks the meshProject for deleted in the meshWorkspace
2. A Partner Admin confirms deletion of the meshProject in the admin area
3. meshcloud support un-blocks the tenant localId (there is a safety mechanism in place to prevent double billing of resources when re-using a tenant).
4. A Partner Admin of `target-workspace` adopts the tenant via API into the meshWorkspace `target-workspace` and a project of their choosing.

We have received the request to support moving meshProjects via the panel. If you have any additional input, please put it in a comment of this [canny post](https://meshcloud.canny.io/feature-requests/p/move-projects-between-customers).


---


---
id: meshstack.openshift.metering
title: Metering
---

meshStack supports metering and billing for most common OpenShift versions.

## Prerequisites

- The "meshfed-metering" service account must be configured as described [here](./meshstack.openshift.index.md#metering-service-account)
- CPU and memory limits have to be defined for all containers, as metering is currently based on these limits
- OpenShift APIs are accessible by meshStack metering collector components

## Supported Resources

Resources with the following traits are addressable in the [Product Catalog](meshstack.billing-configuration.md#defining-a-custom-product-catalog). Platform Operators or Partners can use the traits of these resources to define fine-granular product and pricing rules.

Currently OpenShift metering is based on Pods. They are metered via the configured limit of CPU and memory of their containers.

### Pod
<!--snippet:mesh.kraken.productcatalog.traits.kubernetes.pod#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let PodResourceTraits =
    {-
      milliCpu:
        Configured total CPU limit of all containers in this Pod, in milli CPU (1/1000 of a CPU).
        The primitive usage quantity unit in product catalog entries is 'mCPU', e.g. '2500 mCPU'.

      ramMb:
        Configured total RAM limit of all containers in this Pod, in MiB.
        The primitive usage quantity unit in product catalog entries is 'MiBy', e.g. '1024 MiBy'.

      status:
        Status phase of this pod. See https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/
    -}
      { milliCpu : Integer, ramMb : Integer, status : Text }
```
<!--Example-->
```dhall
let example
    : PodResourceTraits
    = { milliCpu = +2500, ramMb = +1024, status = "Running" }
```
<!--END_DOCUSAURUS_CODE_TABS-->

### PersistentVolumeClaim
<!--snippet:mesh.kraken.productcatalog.traits.kubernetes.persistentvolumeclaim#type-->


<!--DOCUSAURUS_CODE_TABS-->
<!--Dhall Type-->
```dhall
let PersistentVolumeClaimResourceTraits =
    {-
      status:
        Status phase of this PersistentVolumeClaim. See https://docs.openshift.com/container-platform/4.1/storage/understanding-persistent-storage.html#pv-phase_understanding-persistent-storage

      storageClassName:
        Name of the Storage Class used for this volume.

      storageMb:
        Total Capacity of the Volume, in MiB.
    -}
      { status : Text, storageClassName : Text, storageMb : Integer }
```
<!--Example-->
```dhall
let example
    : PersistentVolumeClaimResourceTraits
    = { status = "Bound", storageClassName = "slow", storageMb = +5120 }
```
<!--END_DOCUSAURUS_CODE_TABS-->


---


---
id: meshstack.aks-developer-platform-quickstart-guide
title: AKS Developer Platform Guide
---

## Introduction

Welcome to the **First Developer Platform Guide**! This guide provides step-by-step instructions to help you set up your first developer platform experience incorporating AKS, GitHub & GitHub Actions to deliver an easy-to-use starter kit to your application teams.

## Goals

By the end of this guide, you will have built a complete starter kit for your users that will provide:

- A new GitHub repository
- A “dev” project with:
  - an AKS namespace
  - a GitHub actions workflow with credentials to the AKS namespace
- A “prod” project with:
  - an AKS namespace
  - a GitHub actions workflow with credentials to the AKS namespace

## Prerequisites

Before starting, ensure you have the following:

- You have a basic understanding of building blocks in meshStack.
  - *If you don’t, we recommend running through the [AWS S3 guide](./meshstack.building-aws-quickstart-guide.md) to learn how building blocks work.*
- You have integrated an AKS cluster into meshStack.
  - *If you don’t, we recommend running through the [First Platform guide for AKS](./meshstack.aks-platform-quickstart-guide.md) where you are guided to integrate an AKS cluster as a platform in meshStack*

## What Will We Do in This Guide?

Shortly put, we will set up the following in this guide:

- A building block definition that allows application teams to provision new repositories.
- A building block definition that adds a GitHub Action workflow with the right credentials in the AKS namespace so application teams have an out-of-the-box working Kubernetes CI/CD.
- A building block definition that combines all these elements & more into a single packaged starter kit.

## 1. GitHub Repository

### Preparing GitHub Repository

The GitHub Repository building block definition needs access to your GitHub organization.
Follow the following steps to create a GitHub App that will be used to manage the repositories.

1. [**Register a GitHub App**](https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/registering-a-github-app)
    1. Make sure you give it sufficient permissions. When creating the app you’ll see a section “Repository permissions”. Under here make sure that you set the following:
        1. “Administration” is set to “read & write”.
        2. “Environments” is set to “read & write”.
        3. “Secrets” is set to “read & write”.
        4. “Contents” is set to “read & write”.
    2. After creating the app you will see an “App ID” listed. Make sure to save this somewhere as we will need it later.
2. Install the GitHub App
    1. On the left-hand side go to “Install App” and install the app where you want to manage repositories.
    2. Follow the guide and once finished you will end up on the installation configuration page. On this page, have a look at the URL and extract the number behind `/installations/<installation ID>`. Make sure to save this somewhere as we will need it later.
3. [**Create a GitHub App Private Key**](https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/managing-private-keys-for-github-apps)
    1. Save this file somewhere convenient as we will also need it later.

### Creating the Repository Building Block Definition

To make things easy, we will use the [meshStack Hub](https://hub.meshcloud.io) to create the new building block definition.

1. Open the Github Repository Creation Definition in the meshStack hub [here](https://hub.meshcloud.io/definitions/github-repository).
2. Click on “Add to meshStack” and enter your meshStack URL (if not given already).
3. Continue the flow in meshStack.
    1. Right away you will be asked for a “Type”. Pick “Workspace Building Block” here.
    2. Continue until you reach the “Inputs” page. On this page you will be forced to fill in the following:
        1. `GITHUB_APP_ID` - This is the value saved under “Preparation” step 1b.
        2. `GITHUB_APP_INSTALLATION_ID` - This is the value saved under “Preparation” step 2b.
        3. `GITHUB_APP_PEM_FILE` - This is the value saved under “Preparation” step 3a. Take the entire content of the file and paste it in here.
4. Finish the flow and create the building block definition.

🎉 The GitHub Repository Building Block Definition is ready!

## 2. GitHub Actions Connector

### Preparing the GitHub Actions Connector

This building block definition will interact with both GitHub & AKS, so we need authorization for both.

For GitHub, you can simply reuse what we set up before.

For AKS, you will need to run the Terraform code in the backplane that will set up all necessary preparation such as preparing service principals with the right permissions. You can find this Terraform code [here](https://github.com/meshcloud/meshstack-hub/blob/main/modules/aks/github-connector/backplane).

Make sure you save the `config_tf` output and save it as a file called `config.tf`. We will use it later.

### Creating the GitHub Actions Connector Building Block Definition

We will again use the [meshStack Hub](https://hub.meshcloud.io) to create the new building block definition.

1. Open the Github Actions Integration with AKS definition in the meshStack hub [here](https://hub.meshcloud.io/definitions/aks-github-connector).
2. Click on “Add to meshStack” and enter your meshStack URL (if not given already).
3. Continue the flow in meshStack.
    1. Right away you will be asked for a “Type”. Pick “Tenant Building Block” here and select “AKS” as the supported platform.
    2. Continue until you reach the “Dependencies” page. On this page, select the “Github Repository Creation” building block definition that you created before.
    3. Continue until you reach the “Inputs” page. On this page you will be forced to fill in the following:
        1. `namespace` - This refers to the AKS namespace. Open this up and set the “Source” to “Platform Tenant ID”.
        2. `github_repo` - This refers to the GitHub repository to connect to. Open this up and set the “Source” to “Parent Building Block Output” and set the corresponding output to “repo_name”.
        3. `GITHUB_APP_ID` - This is the value saved under “Preparation” step 1b from the previous building block definition
        4. `GITHUB_APP_INSTALLATION_ID` - This is the value saved under “Preparation” step 2b from the previous building block definition
        5. `GITHUB_APP_PEM_FILE` - This is the value saved under “Preparation” step 3a from the previous building block definition. Take the entire content of the file and paste it in here.
        6. Create a new input called `config.tf` and set the Source to “Static” and the Type to “File”. Mark the input as encrypted and upload the config.tf file from the preparation step.
4. Finish the flow and create the building block definition.

🎉 The GitHub Actions Connector Building Block Definition is ready!

## 3. Starter Kit

The last piece of the puzzle in the guide is the starter kit that will bundle up all previously created resources into one, easy-to-use package for application teams.

### Preparation

We will create resources within meshStack. This means we need an API Key to interact with meshStack in our Terraform code.

- Create a new API Key in meshStack in the Admin Area. Make sure you save the **API key ID** & **API key secret** somewhere, as you’ll need it later.
- Give it the following permissions:
  - “Admin: Create and Update Building Blocks in any Workspace”
  - “Admin: List Building Blocks in any Workspace”
  - “Admin: Create and Update Projects in any Workspace”
  - “Admin: List Projects in any Workspace”
  - “Admin: Create and update Tenants in any Workspace as well as import existing platform tenants”
  - “Admin: List Tenants in any Workspace”

### Creating the Building Block Definition

As the starter kit is very individual to your meshStack (project tags, definition IDs, platform IDs) it is not possible to directly reference a public example, but we provide a template below where you can fill in the missing information.

You can also change the behavior if you want in this starter kit. In its current behavior it will create a workspace building block GitHub repository, two projects with an AKS Namespace and a GitHub Actions connector

- Take the following Terraform code snippet and place it in a Git repository of choice that you can access from your meshStack. Make sure you fill in locals with your own values.

    ```hcl
    locals {
      # TODO: fill in the values here
      github_repo_definition_uuid = "TODO" # UUID of the GitHub repo definition
      github_repo_definition_version_uuid = "TODO" # UUID of the GitHub repo definition version
      github_connector_definition_uuid = "TODO" # UUID of the GitHub connector definition
      aks_platform_identifier = "aks" # Platform identifier for the AKS platform
      aks_location_identifier = "my-aks-location" # Location identifier for the AKS platform
      landing_zone_identifier = "aks-lz" # Landing zone identifier for the AKS platform
    }
    
    # main.tf
    resource "meshstack_project" "dev" {
      metadata = {
        name               = "${var.project_name_prefix}-dev"
        owned_by_workspace = var.workspace_identifier
      }
      spec = {
        display_name = "${var.project_name_prefix}-dev"
        # Add any tags here if you use tags on projects
        # tags = {
        #  "environment"          = ["dev"]
        # }
      }
    }
    
    resource "meshstack_project" "prod" {
      metadata = {
        name               = "${var.project_name_prefix}-prod"
        owned_by_workspace = var.workspace_identifier
      }
      spec = {
        display_name = "${var.project_name_prefix}-prod"
        # Add any tags here if you use tags on projects
        # tags = {
        #  "environment"          = ["prod"]
        # }
      }
    }
    
    resource "meshstack_tenant" "dev" {
      metadata = {
        owned_by_workspace  = var.workspace_identifier
        owned_by_project    = meshstack_project.dev.metadata.name
        platform_identifier = local.aks_platform_identifier
      }
    
      spec = {
        landing_zone_identifier = local.landing_zone_identifier
      }
    }
    
    resource "meshstack_tenant" "prod" {
      metadata = {
        owned_by_workspace  = var.workspace_identifier
        owned_by_project    = meshstack_project.prod.metadata.name
        platform_identifier = local.aks_platform_identifier
      }
    
      spec = {
        landing_zone_identifier = local.landing_zone_identifier
      }
    }
    
    resource "meshstack_building_block_v2" "repo" {
      spec = {
        building_block_definition_version_ref = {
          uuid = local.github_repo_definition_version_uuid
        }
    
        display_name = "GitHub Repo ${var.repo_name}"
        target_ref = {
          kind       = "meshWorkspace"
          identifier = var.workspace_identifier
        }
    
        inputs = {
          repo_name = {
            value_string = var.repo_name
          }
        }
      }
    }
    
    # takes a while until github repo and aks namespace are ready
    resource "time_sleep" "wait_45_seconds" {
      depends_on = [meshstack_building_block_v2.repo]
    
      create_duration = "45s"
    }
    
    resource "meshstack_buildingblock" "github_actions_dev" {
      depends_on = [time_sleep.wait_45_seconds]
    
      metadata = {
        definition_uuid    = local.github_connector_definition_uuid
        definition_version = 1
        tenant_identifier  = "${meshstack_tenant.dev.metadata.owned_by_workspace}.${meshstack_tenant.dev.metadata.owned_by_project}.${local.aks_platform_identifier}.${local.aks_location_identifier}"
      }
    
      spec = {
        display_name = "GitHub Actions Connector"
        parent_building_blocks = [{
          buildingblock_uuid = meshstack_building_block_v2.repo.metadata.uuid
          definition_uuid    = local.github_repo_definition_uuid
        }]
      }
    }
    
    resource "meshstack_buildingblock" "github_actions_prod" {
      depends_on = [meshstack_building_block_v2.repo, meshstack_buildingblock.github_actions_dev]
    
      metadata = {
        definition_uuid    = local.github_connector_definition_uuid
        definition_version = 1
        tenant_identifier  = "${meshstack_tenant.prod.metadata.owned_by_workspace}.${meshstack_tenant.prod.metadata.owned_by_project}.${local.aks_platform_identifier}.${local.aks_location_identifier}"
      }
    
      spec = {
        display_name = "GitHub Actions Connector"
        parent_building_blocks = [{
          buildingblock_uuid = meshstack_building_block_v2.repo.metadata.uuid
          definition_uuid    = local.github_repo_definition_uuid
        }]
      }
    }
    
    # providers
    terraform {
      required_providers {
        meshstack = {
          source  = "meshcloud/meshstack"
          version = ">= 0.5.5"
        }
    
        time = {
          source  = "hashicorp/time"
          version = "0.11.1"
        }
      }
    }
    
    provider "meshstack" {}
    
    # variables
    variable "workspace_identifier" {
      type = string
    }
    
    variable "repo_name" {
      type        = string
      description = "Name of the repository to connect."
    }
    
    variable "project_name_prefix" {
      type        = string
      description = "Prefix for the project. This will result in `prefix`-dev & `prefix`-prod projects"
    }
    ```

- Create a new building block definition in meshStack. Make sure you set the following:
  - Type = Workspace Building Block
  - Implementation Type = Terraform
  - For the inputs you will have to enter an API key ID & API key secret for the meshStack API user you created before.

## What’s Next?

- [Publish all building blocks](./marketplace.service-management-area.md#publishing) so anyone in the organization can use it and provision namespaces in self-service.


---


---
id: meshstack.managed-service
title: Managed Service
---

meshcloud will operate your meshStack as a managed service for you.
Some aspects of the managed service operation apply to all meshStacks (mentioned under [meshStack General](#meshstack-general)),
but other aspects apply only to specific plans. Please have a look at the dedicated section of your plan,
which can be either [meshStack SaaS](#meshstack-saas) or [meshStack SaaS On-Prem](#meshstack-saas-on-prem).

## meshStack General

### Configuration

Most of meshStack's configuration can be done in self-service via the meshPanel in the Administration area.
However, some advanced product functionality is currently only available via a configuration as code model based on [dhall](https://dhall-lang.org/).

When applicable to your chosen meshStack plan, meshcloud can make the configuration model of your meshStack instance available to you as a git repository.
This is useful to track configuration changes, for example to integrate with a change management process.

To request advanced configuration changes for your meshStack instance, please contact your contact from customer success or support@meshcloud.io.

### Versioning & Continuous Delivery

meshcloud continuously releases new versions of meshStack to provide more value to our users.
As can be seen by viewing our [release notes](/blog), this can happen multiple times a week.
Our managed service ensures that your installation and configuration is up-to-date at all
times when delivering new releases to your meshStack environment(s).

#### Versioning Scheme

All meshStack releases have a version number based on the schema `$year.$minor.$patch`:

- `$year` is the year in which the release was done.
- `$minor` is a number that increments with every **feature release**.
  Feature releases can contain new functionality and introduce non-backwards compatible changes.
- `$patch` is a number that increments with every **patch release**.
  Patch releases provide fixes or minor improvements for existing functionality.
  Patch releases always refer to a particular feature release (i.e. they are backwards compatible to that
  release – except, potentially, for bug fixing) and do not introduce new functionality.

All releases contain [release notes](/blog) describing the changes to the product in the respective release.

#### Versioning Example

`2023.42.0` indicates the 42nd **minor release** of meshStack released, in the **year** 2023.
This release may be followed by a **patch release** `2023.42.1`, which indicates the 1st patch release
for the `2023.42.0` minor release.

#### Supported Versions

meshcloud maintains meshStack as a rolling release. This means that releases follow a "fix-forward" paradigm and
do not support (nor require) rollbacks. Any release is generally considered "End of Life" (EOL) as soon as a release
with a higher version number becomes available. meshcloud's managed service supports operation for EOL releases for
a limited time period (upgrade window) before the customer is expected to approve an update to the next release.

For meshStack SaaS On-Prem users, meshcloud can offer extended support for feature releases that have officially
reached end of life as part of an individual managed service agreement. Extended support covers managed operation
of an EOL release as well as a commitment to providing further patch releases for critical bugs and security
issues found in a given feature release.

### Compliance

meshcloud provides customers with comprehensive security and compliance documentation for meshStack.
This includes documentation of the security measures and controls implemented in the system.
Based on this documentation, meshcloud can assist customers in evaluating and documenting compliance
of their individually configured meshStack installation to various industry standard control
frameworks such as ISO 27001 and ISO 27017.

### Monitoring and Support

Every meshStack installation includes sophisticated [logging](./meshstack.logging.md)
and [monitoring](./meshstack.monitoring.md) infrastructure. meshcloud uses these tools
to monitor system availability and diagnose any possible issues.

The monitoring infrastructure of your installations can be made available to your own operations teams on request.
For meshStack SaaS On-Prem users, it is also possible to integrate meshStack with a Security Operations Center (SOC).
For more details, please contact our experts.

## meshStack SaaS

The meshStack SaaS plan is always subject to a generic customer agreement.
This agreement will be provided upon purchasing a meshStack SaaS plan.

### SaaS: Infrastructure

Each meshStack SaaS installation is managed in a standardized way, and it is not possible to deviate from this
standard unless the installation is upgraded to the [meshStack SaaS On-Prem plan](#meshstack-saas-on-prem).

meshStack SaaS is hosted on a Google Cloud-managed kubernetes cluster (this service is known as GKE).
Each individual meshStack SaaS environment is hosted in its own so-called Kubernetes namespace, secured
with a network policy blocking traffic from other meshStacks.
This means that communication and access between different meshStacks is impossible.

### SaaS: Environment

Each meshStack SaaS customer will have one environment which is always the production environment
and this environment is fully managed by meshcloud on the infrastructure mentioned above.

### SaaS: Rollouts

meshStack SaaS environments are automatically updated to the newest version of the meshStack software
depending on the maintenance window of the customer agreement.
The rollout of these updates can be one of the following:

- Weekly, on Mondays between 5 PM and 9 PM CEST.
- Weekly, on Thursdays between 5 PM and 9 PM CEST.

## meshStack SaaS On-Prem

The meshStack SaaS On-Prem plan comes with an individual customer agreement.
This agreement will be created and provided when signing up for a meshStack SaaS On-Prem plan.

### SaaS On-Prem: Infrastructure

The infrastructure of a meshStack SaaS On-Prem installation always depends on what is agreed upon with the customer.

meshcloud supports both on-premise installations and public cloud (AWS, Azure & Google Cloud) installations
that are owned by the customer. meshcloud's operations team will need access to the environment and will fully
manage the meshStack installation from there.

### SaaS On-Prem: Artifact Delivery

It is possible for meshcloud to push artifacts for new meshStack releases to a customer-provided artifact store.
This enables meshcloud to fulfill software admission/delivery and archival requirements that you might have.

### SaaS On-Prem: Environments

#### Staging / QA Environment

When on the meshStack SaaS On-Prem plan, it is possible to get a staging environment (on top of a production environment)
for quality checks & testing purposes, which is useful for testing new releases or new integrations.
The staging environment will be automatically managed by meshcloud.

#### Production Environment

The production environment of meshStack SaaS On-Prem is the real environment where all your users will be consuming
your cloud foundation services.
The production environment is managed by meshcloud.
The timeline of rolling out new releases can be decided by the customer (more on that below).

### SaaS On-Prem: Rollouts

#### Rolling out Staging Environment

A CI/CD pipeline (either one provided by meshcloud or provided by you) automatically rolls out new releases to the staging / QA environment.
This allows you to test new releases as soon as possible. The timing of rollouts can be decided as desired,
e.g. as soon as possible or at a certain time window.

#### Rolling out Production Environment

Production releases are also automated via a CI/CD pipeline but rollouts are typically not automatically triggered by meshcloud.
Instead, you can provide a manual approval or gating process before updates are rolled out to the production environment.

### SaaS On-Prem: Configuration Copy

For meshStack SaaS On-Prem plans we offer the possibility to get a copy of the configuration as code repository.
This might be useful for e.g. auditing reasons. Contact support@meshcloud.io to get this set up.

---


---
id: administration.projects
title: meshProjects
---

## Manage Projects

### Edit Workspace Tag Values

Partner users can edit tag values for tags defined in both [restricted and unrestricted meshTags](meshstack.metadata-tags.md) for managed **meshProjects**.

1. Login to the meshPanel with your administrator credentials.
2. Navigate to the **Administration** via the settings button on the top right.
3. Click on **Workspaces**. You will see a list of your workspaces here.
4. Under the **Actions** column, you can click on **Workspace Projects** and you will see a list of all the projects belonging to that workspace.
5. Select a project and click the `Project Tags` button in the **Actions** column.

### Set Project Quotas

The **Administration** Area includes a quota dashboard that lets you define the amount of resources your workspaces can use for their projects. These resource definitions are called quotas. Quotas can be set per workspace project. OpenStack and Cloud Foundry quotas are defined independently.

To edit the quotas, follow these steps:

1. Login to the meshPanel with your Administrator credentials.
2. Navigate to the **Administration** via the settings button on the top right.
3. Click on **Workspaces**. In this area you can create new workspaces and manage your workspaces’ quotas. You will see a list of your workspaces here.
4. Under the **Actions** column, you can click on **Workspace Projects** and you will see a list of all the projects belonging to that workspace.
5. Also under the **Actions** column, you reach the **Quota Dashboard**. These quotas are project-specific.
6. You can now change the quotas as desired.

### Delete Projects & Tenants

Projects can currently only be deleted by Workspace Managers.

If a meshProject is marked for deletion by a user, and all meshTenants of the meshProject
have been successfully deleted, the meshProject is then automatically deleted.

> Read more about the tenant deletion & approval procedure [here](./administration.delete-tenants.md).

## Audit Projects

### Project Export

If you need to get an overview of all projects or want to use them inside a spreadsheet application you can export all projects as a
[.csv file](https://en.wikipedia.org/wiki/Comma-separated_values). This export contains one row for each Platform that is configured for a project. The configured billing addresses, project tags, local IDs of the project in the cloud platforms and more is available in this export.

To export projects, follow these steps:

1. Login to the meshPanel with your Administrator credentials.
2. Navigate to the **Administration** Area via the settings button on the top right.
3. Click on **Workspaces**.
4. In the upper right there is the button `Project Export`. By clicking it, the download of the Project .CSV file for all workspaces will start.

### Quota Export

This export is an extension of the [Project Export](#project-export). It adds the configured Project Quota to the export. The `Quota Export` button is available in the upper right of **Workspaces** section in the **Administration** Area as well.

### Project History

Sometimes additional information about the lifecycle of the project is required. The archive icon in the list of deleted projects shows all major events that happened on the project. This history is also available for existing projects in the **Workspaces** section of the **Administration** area. Navigate to the **Workspace Projects** of a specific workspace and click the archive icon on the project you want to see details about.

The following events are available:
| Event | Description|
| ------| -----------|
| **PROJECT_CREATED**| A new meshProject was created |
| **PROJECT_PROJECT_MARKED_FOR_DELETION**<br>`since v7.141.0`| A meshProject was deleted by a workspace manager.|
|**PROJECT_DELETED**| `since v7.141.0` When the meshProject was submitted for deletion by a workspace manager and the deletion of all tenants is successful, this event is written.<br>`until v7.141.0`A meshProject was deleted by a workspace manager.|
|**PROJECT_DELETION_CONFIRMED**<br>`deprecated`| A partner or platform operator confirmed a meshProject deletion that required manual deletion of platform tenants|
|**PROJECT_DELETION_DECLINED**| `since v7.141.0` When the project has been deleted by a workspace manager and the deletion of any tenant requiring manual deletion has been declined by a partner or platform operator, this event is written.<br>`until v7.141.0`A partner or platform operator declined a meshProject deletion that required manual deletion of platform tenants.|
|**ALL_PROJECT_TENANTS_DELETED**<br>`deprecated`| Tenants of a meshProject are deleted asynchronously after the user deleted the project. When this deletion is successful, this event is written.
|**TENANT_ADDED**| A tenant was added to a project.|
|**TENANT_MARKED_FOR_DELETION**<br>`since v7.141.0`| A tenant was submitted for deletion by a workspace manager.
|**TENANT_REMOVED**| A tenant was removed from a project by a successful deletion in the corresponding platform.
|**TENANT_DELETION_CONFIRMED**<br>`since v7.141.0`| A partner or platform operator confirmed a tenant deletion that required manual deletion in the corresponding platform.
|**TENANT_DELETION_DECLINED**<br>`since v7.141.0`| A partner or platform operator declined a tenant deletion that required manual deletion in the corresponding platform.
|**USER_ASSIGNED**| A user was assigned to the project. If [4-EP](meshstack.authorization.md#user-project-role-approval) is active, this event is written after successful approval of the role request.|
|**USER_UNASSIGNED**| A user was removed from the project.|
|**PROJECT_ROLE_CHANGED**| The user role was changed on the project. If [4-EP](meshstack.authorization.md#user-project-role-approval) is active, this event is written after successful approval of the role request.|
|**PROJECT_ROLE_APPROVED**| If [4-EP](meshstack.authorization.md#user-project-role-approval) is active, this event is written for every approval.|
|**PROJECT_ROLE_REJECTED**| If [4-EP](meshstack.authorization.md#user-project-role-approval) is active, this event is written when a role request is rejected.|
|**EDIT_PROJECT_TAGS**| If Project Tags are configured, this event is written every time a tag is edited by a workspace manager.|
|**PARTNER_EDIT_PROJECT_TAGS**| If Project Tags are configured, this event is written every time a partner/admin edits the restricted project tags.|
|**QUOTA_EDITED**| Quota Settings for the project were changed.|


---


---
id: meshstack.azure.landing-zones
title: Landing Zones
---

In Azure, a [Landing Zone](./meshcloud.landing-zones.md) is defined via a Management Group the Subscription for the project will be assigned to. Policies can be applied to these Management Groups. Optionally a Blueprint can also be defined. Via an Azure Blueprint default resources can be deployed to the Subscription and additional specific policies can be defined. A Blueprint can be configured to decline users to change or delete the resources and policies created by the Blueprint.

Platform Operators can define and configure [Landing Zone](./meshcloud.landing-zones.md) in the `Administration` section. If a user configures a meshProject to use an Azure meshPlatform, the user must pick from one of the available Landing Zones available. This Landing Zone defines platform specific configuration that is automatically applied and reconciled by the meshStack replicator.

The next section describe the individual building blocks that platform operators can configure in an Azure Landing Zone.

## Azure Subscription

The following description targets the regular Azure Subscription based integration.

### Management Group Assignment

All newly created [meshProjects](./meshcloud.project.md) get their corresponding Subscription assigned to this [Management Group](https://learn.microsoft.com/en-us/azure/governance/management-groups/overview). **Please use the Management Group ID** (not its name), when setting it up in the Landing Zone. When the name is used, the group can not be found during the replication process.

> Management Groups used in different Azure [Landing Zones](./meshcloud.landing-zones.md) should not overlap or be nested into one another. A flatter Management Group hierarchy is significantly less complex to manage and thereby greatly reduces the risk of security issues through misconfiguration. However, you can nest Landing Zone Management Groups in other Management Groups controlled outside of meshStack to share common policies between landing zones.

### Blueprint Assignment

Platform Operators can optionally define one or more [Blueprints](https://docs.microsoft.com/en-us/azure/governance/blueprints/overview)
 which meshStack will assign to managed Subscriptions.

#### Blueprint Name

The name of the Blueprint which gets assigned to the tenant. If left empty, meshProject replication will not create any Blueprint assignments. Changing the name of the Blueprint will also change the resulting Blueprint Assignment name in Azure. If you change the name of a Blueprint e.g. to point to another Blueprint, this will result in two assignments. The old assignment is not automatically removed from the Subscription and must be removed manually.

#### Blueprint Management Group

Blueprints must reside inside a Management Group. It is assumed it is in the same group as the group where to put the Subscriptions by default. If the Blueprint is located in another group it can be configuered here.

Platform Operators must ensure to create these Management Groups in the meshcloud AAD Tenant before configuring them for use in a meshLanding Zone.

#### Available Blueprint Parameters

The following parameter can be used in the Blueprint:

| Parameter          | Description                                                                               |
|--------------------|:------------------------------------------------------------------------------------------|
| workspaceIdentifier | Workspace Identifier                                                                       |
| projectIdentifier  | The project identifier                                                                    |
| SubscriptionId     | The ID of the Azure Subscription associated with this meshProject                         |
| tagCostCenter      | Example for a  [metadata tags](./meshstack.metadata-tags.md) named `costCenter`           |

As the example `tagCostCenter` in the above table indicates, any payment settings, project tags or workspace tags can also be used in the Blueprints.
The following modifications are applied to metadata tag keys by meshstack before making them available as parameters:

- Parameters are prefixed with `tag`
- First letter of metadata tag key is capitalized

In the example, the value of the tag `costCenter` will be made available via the key `tagCostCenter`.
See [metadata tags](./meshstack.metadata-tags.md) for more information.

> If you are planning on converting any of the Blueprint parameters into Azure tags, please be aware of the limits and requirements
> that Azure has [described in their docs](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/tag-resources#limitations).
>
> Key takeaways here:
>
> - A resource can have a maximum of 50 tags.
> - The characters < > % & \ ? / are not allowed in tag keys.

**Please Note:** there are some specialities to keep in mind when dealing with Azure parameters. Resource group names and locations can not be parameterised via meshStack.

When parameters are marked as static in the Azure Panel, they can not be replaced or overwritten during replication. Usually default parameter should not be marked as static in the Azure Blueprint panel because doing so prevents their replacement by meshStack specific variables.

<figure>
  <img src="assets/azure-static-param.png" alt="Static Parameter usage in Azure Blueprint Panel">
  <figcaption>Static Parameter usage in Azure Blueprint Panel</figcaption>
</figure>

#### Max. Auto Upgrade Blueprint Version

Blueprints are versioned in Azure and can be managed via the Azure Portal. To avoid the accidental assignment of new (and possibly faulty) Blueprints, Platform Operators can configure the `Max. Auto Upgrade Blueprint Version` field. If you enter a version identifier here which corresponds to a existing Blueprint version in the Azure portal:

- Existing projects with this Landing Zone will get their Blueprint updated to this version on the next [replication](./meshcloud.tenant.md)
- Newly created projects will get the latest Blueprint version assigned (possibly higher then the version configured here)

#### Managed Identity

##### Using System Assigned Managed Identity (SAMI)

In order to assign [Blueprints](https://docs.microsoft.com/en-us/azure/governance/blueprints/overview), the meshStack replicator needs to be configured with the service principal id of the `Azure Blueprints` app provided by Microsoft.
Please refer to the [Azure Configuration Reference](./meshstack.azure.index.md#configuration-reference) for details.

##### Use User Assigned Managed Identity (UAMI)

This flag allows you to use a User Assigned Managed Identity (UAMI) instead of the standard System Assigned Managed Identity (SAMI) during the assignment of your Blueprint. For more details on their differences, refer to the [Azure Documentation](https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview#how-does-the-managed-identities-for-azure-resources-work)).

Currently we only recommend to use this flag if you want to create resources that require permissions outside of the meshcloud managed Subscription. A good example is if you want to connect a meshcloud managed Subscription to a central log workspace. In order to do this, you require permissions in both the meshcloud managed Subscription and the Subscription your central Log Workspace App resides in.

>**Please note**: meshStack can not handle permissions outside of the Subscriptions it manages. You need to make sure the Managed Identity has the correct permissions to access/create the resources your Blueprint requires. Additionally you must also give the replicator service principal the following permission on the target resource the Managed Identity lives in (e.g. the Subscription of the Managed Identitiy).
>
> ```Microsoft.ManagedIdentity/userAssignedIdentities/*/assign/action```
>

The following parameters are required:
| Parameter              | Description                                                                                                                                                                                                                                                            |
|------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| UAMI Azure Resource ID | Azure Resource ID of the identity; has the following form: `/subscriptions/[subscriptionId]/resourceGroups/[yourRG]/providers/Microsoft.ManagedIdentity/userAssignedIdentities/[userIdentity]`. When opening the UAMI in Azure Portal you can obtain this from the URL |
| UAMI Object ID         | Object ID of the identity; When opening the UAMI in Azure Portal you can obtain this from the `Object ID` field                                                                                                                                                        |

#### Locking Mode

Blueprint assignments are performed with a specific [resource locking mode](https://docs.microsoft.com/en-us/azure/governance/blueprints/concepts/resource-locking) which determines if locked resources managed by Blueprints can be deleted and/or modified.

| Locking Mode            | Description                                                                               |
|-------------------------|:------------------------------------------------------------------------------------------|
| None                    | Resources are not protected                                                               |
| AllResourcesReadOnly    | Locked resource groups are read only and other locked resources can't be modified at all. |
| AllResourcesDoNotDelete | Locked resources can be modifiede but not deleted.                                        |

## Azure Resource Group

The following description targets the Azure integration based on Resource Groups.

### Resource Group Location

The newly created Resource Group for the meshProjects will get assigned to this location. Please take care that the entered location must be all lower case and without spaces (e.g. eastus2 for East US 2).
In order to list the available locations you can use `az account list-locations --query "[*].name" --out tsv | sort`.

## Shared Configuration

These options are shared between both Azure Subscription & Azure Resource Group configuration.

### meshRole to Platform Role Mapping

The meshProject roles must be mapped to Azure specific roles. You can control this by setting up the meshProject role to Azure group suffix mapping. However depending on your configuration of the [AAD group name generation](./meshstack.azure.index.md#aad-group-name), this setting is used or not.

The Azure Role Definition is the RBAC ID of the Azure role you want to use. You can either create your own roles or use the [predefined global IDs](https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles) from Azure.

If you like you can also add an ABAC condition to role assignments done by meshStack as part of the role mapping configuration.
Azure allows for all kinds of advanced conditions on these role assignments.
For more information on this topic please refer to the [Azure documentation](https://learn.microsoft.com/en-us/azure/role-based-access-control/conditions-overview).

### Azure Function Invocation

Platform Operators can configure an Azure Function invocation to trigger a small piece of code in the cloud whenever meshStack's replicator reconciliates the Landing Zone definition against the Subscription. Currently this function is invoked via a `POST` request and receives parameters from meshStack via HTTP header values.

Please review the [HTTP header interface documentation](./meshstack.metadata-tags.md#http-header-interface) for metadata meshStack makes available to Azure Functions.

In addition to the headers referenced above, meshStack provides the following Azure-specific HTTP headers:


| HTTP Header Name           | Description                                                       |
|----------------------------|:------------------------------------------------------------------|
| x-mesh-subscription-id     | The ID of the Azure Subscription associated with this meshProject |

#### Azure Function URL

Enter the URL of your Azure Function here. This is typically a value like `https://my-function-app.azurewebsites.net/myfunc`.

#### Azure Function Scope

To securely call an Azure Function, meshStack uses Microsoft's [App Authentication](https://docs.microsoft.com/en-us/azure/app-service/app-service-authentication-how-to) feature.

This means that behind the scenes meshStack is fetching a JWT token uniquely scoped to your function and passes it during the Azure Function call.

In order for meshStack to fetch the right token, it needs to know the unique ID of the Azure Enterprise Application your function belongs to. You can obtain this ID by navigating to your Azure Function App, click on your Cloud Function and then select `Authentication` (you need to upgrade from the 'Classic Authentication Experience' to the latest version in order to get the `Client ID`). In the new view you can directly see the `App (client) ID` which is the ID required for the Landing Zone "Azure Function Scope" parameter.

![Retrieval of the App (client) ID.](assets/azure_function/cloud-function-scope.png)


#### Required Platform Configuration

In order to make an Azure Function only accessible via the replicator's Service Principal, follow these steps:

> If these steps are automated via Terraform you end up with a non working Azure Function. Until Terraform solves this problem, please perform the setup steps manually in the Azure panel.

1. Create a SAMI or UAMI for your function (this is only required if you need the function to have permissions for Azure based resources like starting VMs, connecting Log Workspaces etc).

    ![System assigned identity](assets/azure_function/system-assigned-identity.png)

2. Lock down your function to only allow assigned users in the `Properties` section of the Enterprise Application created for the SAMI or UAMI in step 1.

    ![Assigned users only](assets/azure_function/assigned-users.png)

3. Modify the Manifest of the Enterprise Application from step 2. Create a custom [Application Role](https://docs.microsoft.com/en-us/azure/architecture/multitenant-identity/app-roles). It's only possible to assign real users and unfortunatly no Service Principals directly to the function so this additional steps are required. Edit the Application Roles manifest like in this JSON:

    ```json
    {
      "allowedMemberTypes": [
        "Application"
      ],
      "description": "Allows an SPP to get a token to a restricted application",
      "displayName": "SPP-Access",
      "id": "<RANDOM_UUID>",
      "isEnabled": true,
      "lang": null,
      "origin": "Application",
      "value": "Access"
    }
    ```

    ![App Role Manifest](assets/azure_function/app-role-manifest.png)

4. Now modify the API permissions of the **App Registration** belonging to the **replicator Service Principal**. This will allow meshStack's replicator to invoke the Azure Function. Open the `API permissions` screen and add the newly created `SPP-Access` Application Role. Don't forget to grant admin consent again afterwards.

    ![Assign the Application Role to SP](assets/azure_function/sp-role.png)

5. _Optional_ In case you see an authorization error when the replicator wants to invoke the function try to set `"accessTokenAcceptedVersion" : "2"` in the app registration manifests of the replicator service principal and the app registration manifest of the Azure Function.

After these steps, the meshStack replicator should be able to fetch a token scoped to this Application Role so it can invoke the Azure Function using App Authentication.
